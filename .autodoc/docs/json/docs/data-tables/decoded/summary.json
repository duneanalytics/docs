{
  "folderName": "decoded",
  "folderPath": "docs/data-tables/decoded",
  "url": "https://dune.com/docs/data-tables/decoded",
  "files": [
    {
      "fileName": "call-tables.md",
      "filePath": "docs/data-tables/decoded/call-tables.md",
      "url": "https://dune.com/docs/data-tables/decoded/call-tables.md",
      "summary": "# Call Tables\n\nThis technical guide explains how Dune parses all message calls and transactions made to smart contracts in their own tables. The guide provides information on how the tables are named and how they are created on an individual contract level or a class of contracts. \n\nThe guide also explains how Dune records transactions in the table when a smart contract is called by an externally owned account (EOA) or another smart contract. The guide provides an example of how Dune records a transaction when a Uniswap v3 pool gets created via the Uniswap v3 factory function `createPool`. \n\nThe guide also explains how Dune decodes all calls to all instances of a smart contract into one table when multiple instances of a contract exist. The guide provides an example of how Dune collects data in the table when there is a transaction calling the `swap` function of any instance of a Uniswap v3 pair contract. \n\nThe guide also highlights a common misconception that web3.js, web3.py, and all other methods of locally calling a `pure`, `read`, or `constant` function do not broadcast or publish anything on the blockchain and are therefore not recorded in Dune. However, if one of these functions is invoked by another smart contract in the context of a transaction, this will be broadcast on the chain and therefore accessible in Dune. \n\nThe guide concludes by providing further reading materials on the difference between a transaction and a call, Soliditylang.org documentation, and how Calldata is encoded. \n\nOverall, this technical guide provides a comprehensive understanding of how Dune parses all message calls and transactions made to smart contracts in their own tables. It is a useful resource for developers who want to understand how Dune records transactions and how to access the data recorded in Dune.",
      "questions": "1. What specific blockchain networks does Dune Docs support for parsing message calls and transactions? \n- The app technical guide does not provide information on the specific blockchain networks supported by Dune Docs for parsing message calls and transactions.\n\n2. Can Dune Docs record message calls made by smart contracts to external systems or APIs? \n- The app technical guide does not provide information on whether Dune Docs can record message calls made by smart contracts to external systems or APIs.\n\n3. How does Dune Docs handle state data stored in the memory of a smart contract? \n- The app technical guide states that state data stored in the memory of a smart contract is not available on Dune, but it does not provide information on how Dune Docs handles this type of data."
    },
    {
      "fileName": "event-logs.md",
      "filePath": "docs/data-tables/decoded/event-logs.md",
      "url": "https://dune.com/docs/data-tables/decoded/event-logs.md",
      "summary": "# Event Logs\n\nThis technical guide covers the concept of event logs in smart contracts. Smart contracts emit event logs when certain predefined actions are completed. The structure published in these logs is predefined by the developer of the smart contract, and the content is dynamically created during the transaction. \n\nThe guide explains that logs are useful for monitoring, alerting, and keeping track of what happens inside a smart contract. Logs are also useful for data analysis since they reliably present data that is intended to be analyzed post factum. The guide provides an example of how to search for the keyword `emit` in the source code of a smart contract to see which logs can be emitted by a smart contract.\n\nThe guide also explains how event logs for smart contracts are decoded into tables named accordingly to a specific schema. The schema is different for the V2 Engine (Spark SQL) and V1 Engine (PostgreSQL). The guide provides examples of how to name tables for each engine.\n\nThe guide provides an example of how to look at the event logs of a transaction in Etherscan. The example is in the context of the uniswap v3 factory, and the event that gets emitted upon the creation of a new pool. The event is called `PoolCreated`, and it gives information like the tokens in the pool, the fee tier of this pool, and the tick spacing. The guide provides examples of how to name tables for each engine.\n\nThe guide explains that if there are multiple instances of a contract, all event logs across all instances of this smart contract are collected in one table. The guide provides an example of how all uniswap v3 pool `swap` events (on ethereum) are stored in a table.\n\nFinally, the guide provides further reading resources on understanding event logs on the Ethereum blockchain and everything you ever wanted to know about events and logs on Ethereum. \n\nOverall, this guide provides a comprehensive explanation of event logs in smart contracts and how they are decoded into tables. It also provides examples of how to name tables for each engine and how to look at event logs of a transaction in Etherscan.",
      "questions": "1. What is the purpose of the Dune Docs app and how does it relate to blockchain SQL analysis?\n   \n   The Dune Docs app provides technical documentation for decoding event logs emitted by smart contracts on the blockchain. This information is useful for blockchain SQL analysts who want to monitor, alert, and keep track of what happens inside a smart contract.\n\n2. How are event logs stored in Dune Docs and what is the naming convention for the tables?\n\n   Event logs for smart contracts are decoded into tables named according to the schema `[projectname_blockchain].[contractName]_evt_[eventName]` for the V2 Engine (Spark SQL) and `[projectname].\"[contractName]_evt_[eventName]\"` for the V1 Engine (PostgreSQL). For example, the event log for the Uniswap V3 pool creation event is stored in the table `uniswap_v3_ethereum.Factory_evt_PoolCreated` for the V2 Engine and `uniswap_v3.\"Factory_evt_PoolCreated\"` for the V1 Engine.\n\n3. How are event logs from multiple instances of a contract handled in Dune Docs?\n\n   Event logs from multiple instances of a contract are collected in one table. For example, all Uniswap V3 pool swap events on Ethereum are stored in the table `uniswap_v3_ethereum.Pair_evt_Swap` for the V2 Engine and `uniswap_v3.\"Pair_evt_Swap\"` for the V1 Engine. The `contract_address` column indicates which smart contract emitted the event."
    },
    {
      "fileName": "index.md",
      "filePath": "docs/data-tables/decoded/index.md",
      "url": "https://dune.com/docs/data-tables/decoded/index.md",
      "summary": "The Decoded Tables guide covers the process of decoding smart contract activity into human-readable tables on the Dune platform. It explains how Dune uses the ABI (Application Binary Interface) for smart contracts and the interface standard for standardized token smart contracts (ERC20, ERC721, etc.) to create tables for each event and function defined in the smart contract's ABI. \n\nThe guide provides examples of how to access decoded data for specific events and function calls using the V2 Engine (Spark SQL) and V1 Engine (PostgreSQL). It also explains how to check if contracts are already decoded by querying the `[blockchain].contracts` tables or using a dashboard.\n\nThe guide further explains how decoding works, using the ABI to call a smart contract or interpret the data it emits. It provides an example of decoding an ERC20 transfer event log and how to understand decoded data.\n\nThe guide also discusses which tables to use (events or calls) and provides queries to explore decoded contracts, such as seeing all projects with decoded data or checking for multiple instances of a contract.",
      "questions": "1. **How can I check if a specific contract has already been decoded in the Dune database?**\n\nYou can check if a contract has been decoded by querying the `[blockchain].contracts` tables through the database or by using the provided dashboard links for V2 Engine (Spark SQL) and V1 Engine (PostgreSQL) in the app technical guide.\n\n2. **How long does it take to decode a smart contract once it has been submitted?**\n\nIt usually takes about 24 hours to initially decode a smart contract. You can check the status of your contract's decoding process using the \"Is my Contract decoded yet?\" dashboard link provided in the app technical guide.\n\n3. **How can I submit multiple contracts for decoding at the same time?**\n\nTo submit a batch of contracts for decoding, use the provided CSV template in the app technical guide and fill it in with the appropriate information for the contracts you want to decode. Then, send the completed CSV file to decoding@dune.com."
    }
  ],
  "folders": [],
  "summary": "The Decoded Tables guide in the `docs/data-tables/decoded` folder focuses on decoding smart contract activity into human-readable tables on the Dune platform. This guide is essential for analysts and developers who want to understand and access the decoded data of smart contracts, events, and function calls on the Dune platform.\n\nThe guide covers the following topics:\n\n1. **Call Tables**: This section explains how Dune parses all message calls and transactions made to smart contracts in their own tables. It provides information on how the tables are named and how they are created on an individual contract level or a class of contracts. It also highlights a common misconception about `pure`, `read`, or `constant` functions not being recorded in Dune.\n\n2. **Event Logs**: This section covers the concept of event logs in smart contracts and how they are decoded into tables named according to a specific schema. It provides examples of how to name tables for the V2 Engine (Spark SQL) and V1 Engine (PostgreSQL) and how to look at event logs of a transaction in Etherscan.\n\n3. **Decoding Process**: This section explains how Dune uses the ABI (Application Binary Interface) for smart contracts and the interface standard for standardized token smart contracts (ERC20, ERC721, etc.) to create tables for each event and function defined in the smart contract's ABI. It provides an example of decoding an ERC20 transfer event log and how to understand decoded data.\n\n4. **Accessing Decoded Data**: This section provides examples of how to access decoded data for specific events and function calls using the V2 Engine (Spark SQL) and V1 Engine (PostgreSQL). It also explains how to check if contracts are already decoded by querying the `[blockchain].contracts` tables or using a dashboard.\n\n5. **Which Tables to Use**: This section discusses which tables to use (events or calls) and provides queries to explore decoded contracts, such as seeing all projects with decoded data or checking for multiple instances of a contract.\n\nThis guide is useful for analysts who want to access and analyze decoded data from smart contracts, events, and function calls on the Dune platform. For example, an analyst might use this guide to understand how to access decoded data for a specific ERC20 token transfer event or how to explore all projects with decoded data on the platform. By understanding the decoding process and how to access the decoded data, analysts can gain valuable insights into smart contract activity and interactions on the Dune platform.",
  "questions": ""
}
