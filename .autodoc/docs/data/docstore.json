[["0",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/analytics_guidelines.md)\n\nThe Web3 Analytics Guidelines technical guide provides end-to-end tutorials on how to analyze specific protocols in web3. The guide covers the basics of analyzing protocols in web3, including how to find what to analyze, metrics-driven analysis, and sharing your work with the community. The guide also includes community guides for Spark SQL and PostgreSQL, which provide additional resources for learning SQL and blockchain concepts. \n\nThe guide starts by explaining that analyzing protocols in web3 is both easy and hard. It is easy because everything is transparent and standardized, but it is also an ever-expanding data battlefield as new protocols, tokens, and wallets join the fray and add to the chaos. The guide then provides tips on how to scope your work when looking into a protocol, including understanding the contract architecture and context, functions, events, and wallets overviews. \n\nThe guide then explains how to perform metrics-driven analysis, which involves understanding token and wallet segments and leveraging labels to enhance your analysis. The guide provides two great end-to-end video series guides for metrics analysis, including Uniswap in 12 Days and Gnosis Safe Point-in-Time. The guide also includes links to an ERC20 dashboard and an NFT dashboard to help understand token trends and contexts. \n\nFinally, the guide explains how to share your work with the community, including sharing your work in the Discord `#üì∫Ô∏±show-your-work` channel and on Twitter tagging @duneanalytics. The guide also includes a link to the Dune official guides and community guides for Spark SQL and PostgreSQL. \n\nOverall, the Web3 Analytics Guidelines technical guide is a comprehensive guide for analyzing specific protocols in web3. It provides step-by-step instructions on how to find what to analyze, perform metrics-driven analysis, and share your work with the community. The guide also includes additional resources for learning SQL and blockchain concepts.\n## Questions: \n 1. What is the purpose of the Dune Docs app and how does it relate to blockchain data analysis?\n   \n   The Dune Docs app provides end-to-end tutorials on how to analyze specific protocols in web3 using SQL and blockchain concepts. It is a resource for blockchain data analysts to learn how to effectively analyze blockchain data and become a full-fledged Dune Wizard.\n\n2. What are some of the challenges that a blockchain SQL analyst might face when analyzing protocols in web3?\n   \n   One of the challenges that a blockchain SQL analyst might face when analyzing protocols in web3 is the ever-expanding data battlefield as new protocols, tokens, and wallets join the fray and add to the chaos. Additionally, understanding the contract architecture and context, as well as the mix of onchain events happening, can be complex.\n\n3. What resources are available for a blockchain SQL analyst to learn how to analyze protocols in web3 using Dune Analytics?\n   \n   There are several resources available for a blockchain SQL analyst to learn how to analyze protocols in web3 using Dune Analytics, including a quickstart dashboard built for understanding contract architecture and context, two end-to-end video series guides for metrics analysis, an ERC20 dashboard and an NFT dashboard for understanding token trends and contexts, and labels to enhance analysis of wallet/user segments. Additionally, the Dune official guides and the OurNetwork Course are recommended resources for learning SQL and blockchain basics.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\analytics_guidelines.md"}}],["1",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\authentication.md)\n\n# Authentication\n\nThis section of the Dune Docs technical guide covers how to authenticate API requests for the Dune API. The guide emphasizes the importance of keeping API keys secure and not sharing them in publicly accessible areas. \n\nTo authenticate requests, the Dune API uses API keys. These keys are used to determine the permissions of private queries and which account to bill for the requests. The guide provides an example of how to add an \"x-dune-api-key\" property to the request header for authentication. This property is required for all request types. \n\nThe guide also includes an example of how to perform authentication with an Execute POST API request using cURL. \n\nOverall, this section of the technical guide is important for developers working with the Dune API to ensure that their requests are properly authenticated and secure.\n## Questions: \n 1. What type of authentication does the Dune API use?\n   - The Dune API uses API keys to authenticate requests.\n\n2. What is the purpose of the \"x-dune-api-key\" property in the request header?\n   - The \"x-dune-api-key\" property is used for authentication with the API and is needed on all request types.\n\n3. What precautions should be taken with API keys?\n   - API keys should be kept secure and not shared in publicly accessible areas such as GitHub or client-side code.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\authentication.md"}}],["2",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\cancel-execution.md)\n\nThe app technical guide covers the process of canceling execution requests in the Dune API. The guide is located in the `app` folder of the Dune Docs project. The guide provides a detailed explanation of how to cancel an execution request, including the arguments required, the expected return value, and examples of how to make a request using cURL or a POST request. \n\nThe guide starts with a brief introduction to the Cancel Execution API, followed by a header for the POST request method. The POST request method is used to cancel an execution request. The header provides a brief description of the method and what it does. \n\nThe next header is Arguments, which explains that no arguments are required for the Cancel Execution API. \n\nThe Returns header explains that the API returns a boolean value indicating whether the execution was successfully canceled. \n\nThe Example Request header provides an example of how to make a request to the Cancel Execution API. The example shows how to pass the `execution_id` obtained from making an Execute Query ID POST request to complete a Cancel Execution API request. \n\nThe cURL header provides an example of how to make a request using cURL. The example shows how to use the `-X POST` flag to specify the POST request method, and how to pass the `execution_id` and `api_key` as parameters. \n\nThe Example Response header provides an example of what the response from the Cancel Execution API looks like. The response is delivered in JSON format and contains a `success` boolean value indicating whether the request to cancel the query execution was made successfully. \n\nOverall, the Cancel Execution API technical guide provides a comprehensive explanation of how to cancel execution requests in the Dune API. The guide is useful for developers who need to cancel execution requests and provides clear examples of how to make requests using different methods.\n## Questions: \n 1. What is the purpose of the Dune API and how does it relate to blockchain technology?\n- This app technical guide does not provide information on the purpose of the Dune API or its relation to blockchain technology.\n\n2. Can the Cancel Execution API request be used to cancel multiple execution requests at once?\n- The app technical guide does not provide information on whether the Cancel Execution API request can be used to cancel multiple execution requests at once.\n\n3. Are there any limitations or restrictions on canceling execution requests using the Dune API?\n- The app technical guide does not provide information on any limitations or restrictions on canceling execution requests using the Dune API.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\cancel-execution.md"}}],["3",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\errors.md)\n\nThis app technical guide covers how to handle errors that may occur when working with the Dune API. The guide is divided into two main sections: Invalid API Key and An Internal Error Occurred. Each section provides a response object and a list of checks to help users troubleshoot the issue. \n\nThe Invalid API Key section provides a response object of {'error': 'invalid API Key'} and two checks to help users resolve the issue. The first check is to ensure that the API key is passed to the endpoint in a header, as described in the Authentication section. The second check is to ensure that the API key is correctly entered. \n\nThe An Internal Error Occurred section provides a response object of {'error': 'An internal error occurred'} and two checks to help users resolve the issue. The first check is to ensure that the query_id entered for GET endpoints is correct. The second check is to ensure that the execution_id obtained from the GET endpoint is correctly passed on to the POST endpoint for POST endpoints. \n\nThe guide also includes a note that if users find the guide too technical or confusing, they can reach out to the Dune API team for support on the #dune-api Discord channel. \n\nOverall, this guide is a helpful resource for users of the Dune API who may encounter errors and need guidance on how to resolve them.\n## Questions: \n 1. What is the Dune API and how does it relate to blockchain technology?\n- The app technical guide does not provide information on what the Dune API is or how it relates to blockchain technology.\n\n2. Are there any specific error codes related to blockchain transactions or smart contracts?\n- The app technical guide does not provide information on specific error codes related to blockchain transactions or smart contracts.\n\n3. Is there any guidance on how to troubleshoot errors related to data retrieval or manipulation?\n- The app technical guide provides some guidance on how to troubleshoot errors related to data retrieval or manipulation, but it is not exhaustive and may not cover all possible scenarios.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\errors.md"}}],["4",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\execute-query-id.md)\n\n# Explanation of the App Technical Guide\n\nThe app technical guide is a documentation for the Dune Docs project, which explains how to execute a query with or without parameters to retrieve data. The guide is focused on the `query` folder of the project. \n\nThe guide starts with a header that explains the purpose of the file, which is to execute a query ID. The header is followed by a section that explains how to execute a query with or without parameters to retrieve data. \n\nThe next section of the guide explains the arguments required to execute the query. In this case, no arguments are required, but query parameters can be added optionally. The guide provides an example of how to add query parameters using cURL. \n\nThe guide then explains what the API returns when the query is executed. In this case, the API returns an `execution_id` for the specified request. The guide provides an example of what the response looks like in JSON format. \n\nThe guide also provides an example request using cURL to execute the query. The example request includes the API endpoint and the query ID. The guide also provides an example of how to execute the query with parameters using cURL. \n\nFinally, the guide explains what the `execution_id` and `state` mean in the response. The `execution_id` is a unique ID that is generated every time the API is called, and the `state` is the current state of the query's execution. \n\nOverall, the app technical guide provides a detailed explanation of how to execute a query with or without parameters to retrieve data. The guide is focused on the `query` folder of the Dune Docs project and provides examples of how to use cURL to execute the query.\n## Questions: \n 1. What is the purpose of the `execution_id` returned by the API?\n   \n   The `execution_id` is a unique ID generated every time the API is called, and it can be saved to pass on to other API endpoints.\n\n2. Can this API be used to execute queries on a blockchain database?\n   \n   The app technical guide does not provide information on whether this API can be used to execute queries on a blockchain database or not.\n\n3. Are there any limitations on the number or size of query parameters that can be passed to the API?\n   \n   The app technical guide does not provide information on any limitations on the number or size of query parameters that can be passed to the API.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\execute-query-id.md"}}],["5",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\execution-results.md)\n\nThis technical guide covers how to get the results data of an execution request in the Dune Docs project. The guide provides information on how to use the Execution Results API to retrieve the status, metadata, and query results from a query execution. The guide includes a detailed explanation of the arguments and returns of the API, as well as an example request and response in JSON and CSV formats. \n\nThe guide also provides information on the different properties of the query execution, such as the execution ID, query ID, state, submitted_at, expires_at, execution_started_at, and execution_ended_at. Additionally, the guide explains the properties of the result, including rows and metadata, such as column_names, result_set_bytes, total_row_count, datapoint_count, pending_time_millis, and execution_time_millis. \n\nThe guide also includes a FAQ section that answers common questions about reading results data, such as whether data can be ingested by getting a direct connection to the database, whether query results data are saved for faster retrieval, how long the results data from an execution are stored for, and how much data can be retrieved in a single API result call. \n\nOverall, this guide provides a comprehensive overview of how to use the Execution Results API to retrieve query execution results in the Dune Docs project.\n## Questions: \n 1. What is the purpose of the Dune Docs app and how does it relate to blockchain technology?\n   \n   Answer: The app technical guide does not provide information on the purpose of the Dune Docs app or its relation to blockchain technology. Further documentation or context is needed to answer this question.\n\n2. How does the app handle security and authentication for API requests, particularly for sensitive data related to blockchain transactions?\n   \n   Answer: The app technical guide does not provide information on security and authentication for API requests. Further documentation or context is needed to answer this question.\n\n3. What is the maximum number of rows or datapoints that can be retrieved in a single API result call, and how does this limit impact the app's usability for analyzing large datasets related to blockchain transactions?\n   \n   Answer: The app technical guide states that there is currently a 1GB limit on the amount of data that can be retrieved in a single API result call. However, it is unclear how this limit impacts the app's usability for analyzing large datasets related to blockchain transactions. Further documentation or context is needed to answer this question.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\execution-results.md"}}],["6",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\execution-status.md)\n\n# Execution Status\n\nThis technical guide explains how to check the status of an execution request in the Dune Docs project. The guide is focused on the `app` folder of the project. The guide provides a detailed explanation of the `GET` Execution Status API request, including its arguments, returns, example request, and example response.\n\nThe Arguments section of the guide explains that no arguments are required for the API request. The Returns section explains that the API request returns the status of a query execution along with relevant metadata of the results if the execution is completed.\n\nThe Example Request section provides an example of how to pass the `execution_id` obtained from making an Execute Query ID POST request to complete an Execution Status API request. The example shows the endpoint URL and the cURL command to make the request.\n\nThe Example Response section provides two examples of the JSON response that the API request returns. The first example shows the response when the query is still executing, while the second example shows the response when the execution is complete. The section explains the meaning of each property in the response, including `execution_id`, `query_id`, `state`, `submitted_at`, `expires_at`, `execution_started_at`, `execution_ended_at`, and `result_metadata`.\n\nThe guide also includes a Check Execution Status FAQ section that answers common questions about the different status codes for `state`. The section explains the difference between the states \"Executing\" and \"Pending\" and provides a list of all status codes for reference.\n\nOverall, this technical guide provides a comprehensive explanation of how to check the status of an execution request in the Dune Docs project. It is a useful resource for developers who need to monitor the progress of their query executions.\n## Questions: \n 1. What is the purpose of this API and how does it relate to blockchain technology?\n   - This API is used to check the status of a query execution request. It is not directly related to blockchain technology, but it could potentially be used in conjunction with blockchain data queries.\n2. What authentication methods are required to use this API?\n   - The cURL example shows that an API key is required to make requests to this API. It is unclear from this documentation whether any other authentication methods are supported.\n3. Are there any limitations on the size or complexity of queries that can be executed using this API?\n   - The documentation does not provide any information on limitations for query size or complexity. A blockchain SQL analyst may need to test the API with various query types and sizes to determine any potential limitations.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\execution-status.md"}}],["7",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\api-reference\\index.md)\n\n# API Reference\n\nThis section of the Dune Docs project covers the API endpoints and common errors that may occur when using them. The purpose of this guide is to provide developers with a comprehensive understanding of the API and how to use it effectively.\n\n## Authentication\n\nThis header covers the authentication process for accessing the API. It explains the different authentication methods available and how to use them. For example, it may include information on how to generate an API key or how to use OAuth to authenticate requests.\n\n## Execute Query ID\n\nThis header covers the endpoint for executing a query by ID. It explains how to use this endpoint to execute a query and retrieve the results. It may include information on the expected input parameters and the format of the response.\n\n## Execution Status\n\nThis header covers the endpoint for checking the status of a query execution. It explains how to use this endpoint to retrieve the status of a query execution and what the different status codes mean. It may also include information on how to handle errors that may occur during the execution process.\n\n## Execution Results\n\nThis header covers the endpoint for retrieving the results of a query execution. It explains how to use this endpoint to retrieve the results of a query and what the different response formats are. It may also include information on how to handle errors that may occur when retrieving the results.\n\n## Cancel Execution\n\nThis header covers the endpoint for canceling a query execution. It explains how to use this endpoint to cancel a query that is currently executing and what the expected response is. It may also include information on how to handle errors that may occur when canceling a query.\n\n## Error Codes\n\nThis header covers the different error codes that may be returned by the API. It explains what each error code means and how to handle it. It may also include information on how to troubleshoot common errors that may occur when using the API.\n\nExample: If a developer encounters an error code when using the API, they can refer to this section of the guide to understand what the error means and how to resolve it.\n\nOverall, this API Reference guide provides developers with a comprehensive understanding of the API endpoints and common errors that may occur when using them. It is a valuable resource for anyone looking to integrate with the Dune Docs API.\n## Questions: \n 1. What type of data is being accessed through the API endpoints listed in this technical guide?\n- It is unclear from this technical guide what type of data is being accessed through the API endpoints. \n\n2. Are there any security measures in place to protect the data being accessed through the API endpoints?\n- It is unclear from this technical guide whether there are any security measures in place to protect the data being accessed through the API endpoints. \n\n3. Is there any information on how to handle errors that may occur when using the API endpoints?\n- Yes, there is information on how to handle errors that may occur when using the API endpoints in the \"Error Codes\" section.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\index.md"}}],["8",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\api\\api-reference)\n\nThe `.autodoc\\docs\\json\\docs\\api\\api-reference` folder contains a collection of technical guides that provide comprehensive information on how to interact with the Dune API. These guides cover various aspects of the API, such as authentication, executing queries, checking execution status, retrieving results, and handling errors. The primary focus of these guides is on the `api` folder of the Dune Docs project.\n\nFor example, the `authentication.md` guide explains the importance of securing API keys and demonstrates how to add the \"x-dune-api-key\" property to the request header for proper authentication. This guide is essential for developers to ensure their API requests are secure and properly authenticated.\n\nThe `execute-query-id.md` guide provides a detailed explanation of how to execute a query with or without parameters to retrieve data. It includes examples of how to use cURL to execute the query, making it a valuable resource for developers looking to retrieve data from the Dune API.\n\nThe `execution-status.md` guide offers a comprehensive explanation of how to check the status of an execution request. It includes example requests and responses, as well as a FAQ section that answers common questions about the different status codes for query execution states. This guide is particularly useful for developers who need to monitor the progress of their query executions.\n\nThe `execution-results.md` guide covers how to retrieve the results data of an execution request. It provides information on the different properties of the query execution and the result, as well as a FAQ section that answers common questions about reading results data.\n\nThe `cancel-execution.md` guide explains the process of canceling execution requests in the Dune API. It provides a detailed explanation of how to cancel an execution request, including the arguments required, the expected return value, and examples of how to make a request using cURL or a POST request.\n\nLastly, the `errors.md` guide helps users handle errors that may occur when working with the Dune API. It provides response objects and troubleshooting steps for common errors, such as Invalid API Key and An Internal Error Occurred.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\api\\api-reference` folder provide a comprehensive understanding of the Dune API and its various features. These guides are essential for developers looking to integrate with the Dune API and work effectively with its endpoints and functionalities.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\api-reference\\summary.md"}}],["9",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\FAQ\\billing-pricing.md)\n\n# Dune API Billing & Pricing\n\nThis technical guide provides information about Dune's API billing and pricing. It covers the following topics:\n\n## FAQ: Billing & Pricing\n\nThis section provides answers to frequently asked questions about Dune's API billing and pricing.\n\n### How will API Billing work with the new Team plans?\n\nThis header explains that Dune will soon support API keys on a team level in the first few months of 2023. Any usage associated with a team API key will be billed to their respective team. This feature is relevant to the app folder of the project, as it pertains to the billing and pricing of the API.\n\n### What‚Äôs a datapoint?\n\nThis header defines a datapoint as rows * columns with an additional limit of 50 avg bytes per cell in a set of results. It also provides a formula to express datapoints. This information is relevant to the data tables folder of the project, as it pertains to the calculation of datapoints.\n\n### Do I get charged datapoints for every execution?\n\nThis header explains that Dune charges datapoints in the result for the 1st read result of every distinct query execution and every subsequent 100th read per billing cycle. This information is relevant to the query folder of the project, as it pertains to the billing and pricing of query executions.\n\nOverall, this technical guide provides important information about Dune's API billing and pricing, including how it works with team plans, how datapoints are calculated, and how they are charged for query executions.\n## Questions: \n 1. What is the pricing model for Dune's API and how is it calculated?\nA blockchain SQL analyst might want to know more about the specific pricing model for Dune's API and how it is calculated based on usage and datapoints.\n\n2. How does Dune handle data privacy and security for API billing and pricing?\nA blockchain SQL analyst might be interested in understanding how Dune ensures data privacy and security for API billing and pricing, especially if sensitive data is being transmitted.\n\n3. Are there any limitations or restrictions on the number of API calls or datapoints that can be used per billing cycle?\nA blockchain SQL analyst might want to know if there are any limitations or restrictions on the number of API calls or datapoints that can be used per billing cycle, as this could impact the cost and feasibility of using Dune's API for their blockchain project.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\FAQ\\billing-pricing.md"}}],["10",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\FAQ\\functionality.md)\n\n# Dune API Functionality\n\nThis technical guide provides answers to frequently asked questions about how the Dune API works. The guide is divided into sections that cover different aspects of the Dune API functionality. \n\n## General\n\nThis section provides general information about the Dune API.\n\n### How many Requests Per Minute can I make?\n\nThe API is currently set to a rate limit of 60 requests per minute. \n\n### Are there specified SLAs?\n\nSLAs will be available in the future on Enterprise pricing plans.\n\n## Executing Queries\n\nThis section provides information on how to execute queries using the Dune API.\n\n### How do I find a query id?\n\nWhen navigating to a query, it‚Äôs the first number after ‚Äú/queries/‚Äù in the URL. An example is provided in the guide.\n\n### Does the API support Query Parameters?\n\nThe API does support Query Parameters. The guide provides information on how to pass parameter data using cURL and Python.\n\n### What are the performance and overall differences between the Dune API and the Dune web app? What are the differences in what I can query?\n\nThere are no major performance differences or differences in what can be accessed between the two if both are using the same app plan tier. The Dune API gives you programmatic access to the capabilities and data sets that can already be accessed from the Dune web app.\n\n### What is the execution timeout limit and can I request a longer limit?\n\nThe query execution timeout limit matches the Dune web app - 30 minutes.\n\n### Which query engine should I use with the API?\n\nThe guide recommends using the API with v2 Dune SQL as the old v1 engine and v2 Spark SQL are being deprecated.\n\n## Check Execution Status\n\nThis section provides information on how to check the execution status of a query.\n\n### What is the difference between the states ‚ÄúExecuting‚Äù and ‚ÄúPending‚Äù?\n\nPending means the execution is waiting for an available execution connection slot. Executing means the query is currently executing against the database.\n\n## Reading Results Data\n\nThis section provides information on how to read results data from a query.\n\n### Can I ingest data by getting a direct connection to the database instead?\n\nNot currently. In the interim, the guide recommends periodically fetching data in regular intervals.\n\n### Are query results data saved for faster retrieval?\n\nYes!\n\n### How long are the results data from an execution stored for?\n\nCurrently set to 2 years but may be reduced to something closer to 90 days in the future.\n\n### How much data can I retrieve in a single API result call?\n\nThere is currently a 250MB limit, but there is a chance this may increase for certain paid plans. The API does not currently return an explicit error upon hitting this limit but will instead fail (timeout) when attempting to retrieve the results.\n## Questions: \n 1. What is the maximum rate limit for requests per minute and will it change in the future?\n   \n   The API is currently set to a rate limit of 60 requests per minute, but it will soon be set to match the rate limits specified in the varying API plan tiers.\n\n2. How long are the results data from an execution stored for and will it change in the future?\n   \n   Currently, the results data from an execution are stored for 2 years, but it may be reduced to something closer to 90 days in the future.\n\n3. Is there a limit to the amount of data that can be retrieved in a single API result call and will it change in the future?\n   \n   There is currently a 250MB limit, but there is a chance it may increase for certain paid plans. The API does not currently return an explicit error upon hitting this limit but will instead fail (timeout) when attempting to retrieve the results.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\FAQ\\functionality.md"}}],["11",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\FAQ\\other.md)\n\n# Dune API Other FAQs\n\nThis section of the Dune app technical guide provides answers to frequently asked questions about the Dune API. The Dune API is a feature of the Dune app that allows developers to access and interact with Dune's data and functionality programmatically.\n\n## Contacting Dune for API Support\n\nThis header provides information on how to contact Dune for API support. Users can reach out to [api-feedback@dune.com](mailto:api-feedback@dune.com) or join the #[dune-api](https://discord.com/channels/757637422384283659/1019910980634939433) Discord channel for the fastest path towards getting additional questions answered.\n\nThis section is important for developers who may encounter issues or have questions about the Dune API. It provides clear instructions on how to get in touch with Dune's support team for assistance.\n\nExample:\n```\nIf you encounter any issues or have questions about the Dune API, please reach out to api-feedback@dune.com or join the #[dune-api](https://discord.com/channels/757637422384283659/1019910980634939433) Discord channel for assistance.\n```\n\nOverall, this section of the Dune app technical guide is a helpful resource for developers who are working with the Dune API. It provides clear and concise answers to common questions and offers guidance on how to get additional support if needed.\n## Questions: \n 1. **What is the Dune API and how does it work?** The app technical guide does not provide a detailed explanation of what the Dune API is and how it works. A blockchain SQL analyst might want to know more about the API's functionality and how it interacts with blockchain data.\n2. **What kind of data can be accessed through the Dune API?** The app technical guide does not provide a comprehensive list of the types of data that can be accessed through the Dune API. A blockchain SQL analyst might want to know what specific blockchain data can be queried and analyzed using the API.\n3. **Are there any limitations or restrictions on API usage?** The app technical guide does not mention any limitations or restrictions on API usage, such as rate limits or access controls. A blockchain SQL analyst might want to know if there are any restrictions on how frequently they can query the API or what types of queries are allowed.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\FAQ\\other.md"}}],["12",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\api\\FAQ)\n\nThe `.autodoc\\docs\\json\\docs\\api\\FAQ` folder contains a collection of technical guides that provide detailed information and answers to frequently asked questions about the Dune API. These guides cover various aspects of the API, including billing and pricing, functionality, and other miscellaneous topics. They are essential for developers and analysts who want to understand and work with the Dune API effectively.\n\nThe `billing-pricing.md` file focuses on the billing and pricing aspect of the Dune API. It explains how API billing works with team plans, the definition of a datapoint, and how datapoints are charged for query executions. This guide is particularly useful for developers who need to manage their API usage and costs.\n\nExample:\n```\nTo calculate the number of datapoints in a query result, use the formula: rows * columns with an additional limit of 50 avg bytes per cell.\n```\n\nThe `functionality.md` file provides answers to frequently asked questions about the Dune API's functionality. It covers general information, executing queries, checking execution status, and reading results data. This guide is essential for developers who want to understand the capabilities and limitations of the Dune API.\n\nExample:\n```\nThe API supports Query Parameters. To pass parameter data using cURL or Python, follow the instructions provided in the guide.\n```\n\nThe `other.md` file addresses miscellaneous questions about the Dune API. It provides information on how to contact Dune for API support, which is crucial for developers who may encounter issues or have questions about the API.\n\nExample:\n```\nFor API support, reach out to api-feedback@dune.com or join the #[dune-api](https://discord.com/channels/757637422384283659/1019910980634939433) Discord channel.\n```\n\nThe `TOS.md` file covers the Dune API Terms of Service (TOS), which is a legal agreement between Dune and the users of the API. It highlights the importance of reading and understanding the TOS before using the API.\n\nExample:\n```\nBefore using the Dune API, read the API TOS to ensure compliance with the terms and conditions outlined in the agreement.\n```\n\nOverall, the guides in this folder are essential resources for developers and analysts working with the Dune API. They provide clear and concise information about various aspects of the API, helping users to understand its capabilities, limitations, and requirements.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\FAQ\\summary.md"}}],["13",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\FAQ\\TOS.md)\n\n# Dune API TOS\n\nThis section of the app technical guide covers the Dune API Terms of Service (TOS). The TOS is a legal agreement between Dune and the users of the API. It outlines the terms and conditions that govern the use of the API and the responsibilities of both Dune and the users.\n\nThe header provides a link to the actual API TOS document, which is hosted on the Dune website. Users of the API should read and understand the TOS before using the API. The TOS covers important topics such as acceptable use, intellectual property rights, and liability.\n\nExample:\nIf a developer wants to use the Dune API to build an application, they should first read the API TOS to ensure that their use of the API is in compliance with the terms and conditions outlined in the agreement.\n\n# Conclusion\n\nThe Dune API TOS is an important legal agreement that governs the use of the Dune API. This section of the app technical guide provides a link to the actual TOS document and highlights the importance of reading and understanding the agreement before using the API.\n## Questions: \n 1. What type of data does the Dune API provide and how is it stored?\n- This app technical guide does not provide information on the type of data provided by the Dune API or how it is stored.\n\n2. Are there any limitations or restrictions on the usage of the Dune API?\n- The Dune API Terms of Service can be found at the provided link, which may contain information on limitations or restrictions.\n\n3. Is there any documentation available on how to integrate and use the Dune API?\n- This app technical guide does not provide information on how to integrate and use the Dune API, but it may be available through the provided link to the API Terms of Service.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\FAQ\\TOS.md"}}],["14",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\index.md)\n\n# Dune API Technical Guide\n\nThe Dune API Technical Guide is a documentation for developers who want to use the Dune API. The guide provides an overview of the API and how it works, as well as instructions on how to get started with the API. \n\nThe guide starts with an introduction to the Dune API, which gives developers full access to the queries and data available on the Dune website. The API allows users to execute and read results from any public query, as well as any personal private queries that their Dune account has access to. The guide also provides a link to the Discord channel where developers can ask questions or provide feedback.\n\nThe guide then explains how the API works, which includes executing a query, checking the status of an execution, and getting the results of an execution. The results are stored separately from anything visible on the Dune website, so the only way to get query results from the Dune API is to execute a query using the API. The results from API executions are not currently reflected on Dune‚Äôs website.\n\nThe guide provides instructions on how to get started with the API, which includes obtaining an API key after purchasing an app plan and API package. The API key can be found in the user's settings page. The guide also provides quick start guides for Python and Node.js, as well as links to community clients available for the API.\n\nFinally, the guide provides important links to the API documentation, the Discord channel, and the API client (community sourced). \n\nOverall, the Dune API Technical Guide is a comprehensive documentation that provides developers with all the information they need to use the Dune API.\n## Questions: \n 1. What kind of data can be queried using the Dune API?\n   - The Dune API gives full access to the queries and data visible on the Dune website, including both public and private queries.\n2. How are query results stored and accessed through the API?\n   - Query results are stored separately from the Dune website and can only be accessed by executing a query using the Dune API.\n3. What programming languages are supported for consuming the Dune API?\n   - The Dune API can be consumed in any programming language, but quick start guides are currently available for Python and Node.js. Community clients are also available.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\index.md"}}],["15",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\quick-start\\api-js.md)\n\nThe app technical guide provides a tutorial on how to access the Dune API via JavaScript. The guide is not yet comprehensive, and users are advised to reach out to the Dune team via the dune-api channel on Discord if they have any questions. The guide assumes that users have some level of familiarity with Node.js, Node Package Manager (NPM), and Node Version Manager (NVM). \n\nThe guide provides a step-by-step process for getting set up, which includes ensuring that users are using the current LTS version of Node.js (Node 18) and the latest version of NPM. Users are also required to install the node-fetch package and create a project directory and initiate an ESM-compatible Node project. \n\nThe guide provides an example Dune API script that fetches a small set of data using a simple query with the query_id 1258228. Users are required to replace `#! YOUR_API_KEY` with their Dune API key in the code. The guide also provides an example Dune API script for a parameterized query that takes in a wallet address as a parameter. \n\nThe guide concludes by providing instructions on how to run the script from the command line and a link to the code in a Github repository. The guide is focused on the app folder of the Dune Docs project and provides a detailed explanation of how to access the Dune API via JavaScript.\n## Questions: \n 1. What is the Dune API and how does it relate to blockchain technology?\n- The app technical guide provides information on how to access the Dune API via JavaScript, but it does not explain what the Dune API is or how it relates to blockchain technology.\n\n2. Are there any security measures in place to protect user data when using the Dune API?\n- The app technical guide does not mention any security measures in place to protect user data when using the Dune API, which may be a concern for a blockchain SQL analyst.\n\n3. Are there any limitations or restrictions on the types of queries that can be executed using the Dune API?\n- The app technical guide provides examples of how to execute queries using the Dune API, but it does not mention any limitations or restrictions on the types of queries that can be executed, which may be important information for a blockchain SQL analyst.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\api-js.md"}}],["16",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\quick-start\\api-py.md)\n\nThis app technical guide covers how to access the Dune API using Python. It provides a step-by-step guide to set up the environment, install necessary libraries, and create functions to interact with the Dune API. The guide assumes prior experience with Python and recommends using Python3, a virtual environment, and the `pip` package manager.\n\nThe guide covers the following sections:\n\n1. **Getting Set Up**: Installing the `requests`, `pandas`, and `jupyter notebook` libraries.\n2. **Import the necessary libraries**: Importing `requests` and `pandas`.\n3. **API Keys**: Setting up the API key and header for making API calls.\n4. **Simplifying URL generation**: Creating a function to generate URLs for different API endpoints.\n5. **Wrapping API endpoints in functions**: Defining functions to execute a query, get query status, get query results, and cancel query execution.\n6. **Using the Dune API**: Demonstrating how to execute a query, get query execution status, get query results, and cancel query execution.\n7. **Parameterized Queries**: Creating a function to execute queries with parameters.\n\nThe guide provides examples for each section, making it easy to follow and implement the code. The complete code for this tutorial is available on [GitHub](https://github.com/SusmeetJain/dune_api_python).\n## Questions: \n 1. **How do I pass my API key to the Dune API?**\n\n   You need to pass your API key in the header of your API calls. In the example provided, the API key is stored in a variable called `API_KEY`, and the header is created as a dictionary: `HEADER = {\"x-dune-api-key\" : API_KEY}`.\n\n2. **How can I execute a parameterized query using the Dune API?**\n\n   To execute a parameterized query, you need to create a dictionary containing the parameter values and pass it to the `execute_query_with_params` function along with the query ID. For example: `parameters = {\"wallet_address\" : \"0xb10f35351ff21bb81dc02d4fd901ac5ae34e8dc4\"}` and `execution_id = execute_query_with_params(\"638435\", parameters)`.\n\n3. **How can I cancel a query execution if it's taking too long?**\n\n   You can cancel a query execution by calling the `cancel_query_execution` function and passing the `execution_id` of the running query. For example: `response = cancel_query_execution(execution_id)`.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\api-py.md"}}],["17",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\quick-start\\api-ready-queries.md)\n\nThis app technical guide provides a list of queries that are ready for API use in the Dune Docs project. The guide is divided into four sections, each containing a query with its respective query ID, parameters, and output columns. The first query is for getting the ERC20 balances for a given address. The parameters include the address, block number, chain, and dust, while the output columns include the symbol, notional value, total value, and token price. The second query is for getting all the holders and their balances for a given ERC20 address. The parameters include the address, block number, and chain, while the output columns include the holder, holder_ens, notional value, total value, and token price. The third query is for getting the NFT balances for a given address. The parameters include the address, block number, and chain, while the output columns include the symbol, name, category, token_id, contract_address, acquired_how, and acquired_on_block_number. The fourth query is for getting all the holders and their balances for a given NFT address. The parameters include the address, block number, and chain, while the output columns include the holder, holder_ens, tokens_held, and token_ids. The guide also provides valid choices for each parameter and examples of how to use the queries. Overall, this guide serves as a reference for developers who want to use the Dune Docs API and provides them with the necessary information to use the queries effectively.\n## Questions: \n 1. What are the available EVM chains that this app supports?\n   - The available EVM chains that this app supports are `ethereum`, `polygon`, `bnb`, `optimism`, `arbitrum`, `avalanche_c`, and `gnosis`.\n2. Can this app retrieve NFT balances and holders for non-EVM blockchains?\n   - No, this app can only retrieve NFT balances and holders for EVM blockchains.\n3. How often is the data updated for the balances and holders queries?\n   - The data is updated every ~3 minutes/15 blocks, as specified in the `blocknumber` parameter.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\api-ready-queries.md"}}],["18",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\quick-start\\community-clients.md)\n\n# Community Clients\n\nThis guide provides a list of Dune API clients built by the community. It is focused on the `app` folder of the Dune Docs project. The purpose of this guide is to showcase the various API clients built by the community and provide instructions on how to install them. \n\nThe guide starts with a brief introduction to the API clients and a call to action for the community to share their own clients. It also includes a warning disclaimer that the clients are not directly maintained by the Dune team.\n\nThe guide then proceeds to list the various API clients available, including the Cow Protocol Python Client, Cow Protocol Typescript Client, Dune Go Client, and Dune Ruby Client. Each client is introduced with a brief description and the name of the developer who built it. The guide also includes links to the respective GitHub pages and installation instructions for each client.\n\nFor example, the Cow Protocol Python Client can be installed with a simple pip install command:\n\n```python\npip install dune-client\n```\n\nThe guide also includes a link to the client's GitHub page for more information on how it works. Similarly, the Dune Ruby Client can be installed by adding the following line to the Gemfile:\n\n```ruby\ngem \"dune\"\n```\n\nAnd then running `$ bundle install` from the terminal.\n\nOverall, this guide serves as a helpful resource for developers looking to use Dune API clients built by the community. It provides clear installation instructions and links to the relevant GitHub pages for more information.\n## Questions: \n 1. What is the purpose of the Dune Docs app?\n    \n    The app technical guide does not provide information on the purpose of the Dune Docs app, so a blockchain SQL analyst might have to look for additional documentation or context to understand the app's purpose.\n\n2. Are there any security concerns with using the community-built API clients?\n\n    The app technical guide mentions that the community-built API clients are not directly maintained by the Dune team, so a blockchain SQL analyst might want to investigate the security measures implemented by the community-built clients to ensure they are safe to use.\n\n3. Are there any limitations or restrictions on the usage of the API clients?\n\n    The app technical guide does not provide information on any limitations or restrictions on the usage of the API clients, so a blockchain SQL analyst might have to look for additional documentation or context to understand any potential limitations or restrictions.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\community-clients.md"}}],["19",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/api\\quick-start\\index.md)\n\n# API Quick Start\n\nThis technical guide covers the quick start guides for using the API in the Dune Docs project. The purpose of this guide is to provide users with the necessary information to get started with the API quickly. \n\nThe guide starts by providing a link to example queries that can be used with the API. These queries include NFT or ERC20 balances or holders. This section is useful for users who want to quickly test the API and see how it works.\n\nThe guide also provides a link to a pipeline setup using Python and Celery. This section is useful for users who want to set up an ingestion pipeline and need guidance on how to do so.\n\nThe main section of the guide provides quick start guides for using the API with Python, Javascript, and community clients. These guides provide step-by-step instructions on how to get started with the API using these programming languages. \n\nFor example, the Python guide covers how to install the necessary packages, how to authenticate with the API, and how to make requests. The Javascript guide covers how to make requests using the fetch API and how to handle responses. The community clients guide covers how to use community-built clients to interact with the API.\n\nOverall, this technical guide is a useful resource for users who want to get started with the API quickly and efficiently. The guide provides clear and concise instructions for using the API with different programming languages and includes links to example queries and pipeline setups.\n## Questions: \n 1. What kind of data does this API provide access to?\n- The API provides access to example queries for NFT or ERC20 balances or holders, as well as quick start guides for Python, Javascript, and community clients.\n\n2. Are there any limitations or restrictions on the usage of this API?\n- The app technical guide does not mention any limitations or restrictions on API usage.\n\n3. Is there any information on how the API handles data security and privacy?\n- The app technical guide does not provide any information on how the API handles data security and privacy.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\index.md"}}],["20",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\api\\quick-start)\n\nThe quick-start folder in the Dune Docs project focuses on providing users with a comprehensive guide to get started with the Dune API using different programming languages and tools. The guides in this folder are designed to help users quickly and efficiently set up their environment, authenticate with the API, and make requests to fetch data.\n\nFor example, the `api-js.md` guide provides a step-by-step tutorial on accessing the Dune API via JavaScript. It assumes users have some familiarity with Node.js, NPM, and NVM. The guide covers setting up the environment, installing the required packages, and provides example scripts for fetching data using simple and parameterized queries. This guide is useful for developers who prefer working with JavaScript and want to integrate the Dune API into their projects.\n\nSimilarly, the `api-py.md` guide covers accessing the Dune API using Python. It provides a detailed walkthrough on setting up the environment, installing necessary libraries, and creating functions to interact with the Dune API. This guide is beneficial for developers who prefer Python and want to fetch data from the Dune API for their projects.\n\nThe `api-ready-queries.md` guide offers a list of ready-to-use queries for the Dune API, including ERC20 and NFT balances and holders. This guide serves as a reference for developers who want to use the Dune API effectively and provides them with the necessary information to use the queries efficiently.\n\nThe `community-clients.md` guide showcases various Dune API clients built by the community, including Python, TypeScript, Go, and Ruby clients. It provides installation instructions and links to the respective GitHub pages for each client. This guide is helpful for developers who want to use community-built clients to interact with the Dune API.\n\nLastly, the `index.md` file serves as an overview of the quick-start guides, providing users with links to example queries, pipeline setups, and guides for using the API with Python, JavaScript, and community clients.\n\nOverall, the quick-start folder in the Dune Docs project is an essential resource for users who want to get started with the Dune API quickly and efficiently. The guides provide clear and concise instructions for using the API with different programming languages and include links to example queries and pipeline setups, making it easier for developers to integrate the Dune API into their projects.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\quick-start\\summary.md"}}],["21",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\api)\n\nThe `.autodoc\\docs\\json\\docs\\api` folder contains the Dune API Technical Guide, which is a comprehensive documentation for developers who want to use the Dune API. The guide provides an overview of the API, instructions on how to get started, and links to important resources such as the API documentation, Discord channel, and community clients.\n\nThe guide is focused on the `api` folder of the Dune Docs project and is essential for developers looking to integrate with the Dune API and work effectively with its endpoints and functionalities. For example, the guide explains how to obtain an API key, which is required for authentication when making requests to the API. It also provides quick start guides for Python and Node.js, making it easier for developers to start using the API with their preferred programming language.\n\nIn addition to the main guide, the folder contains subfolders with more detailed information on various aspects of the API, such as the `api-reference` folder, which contains technical guides on authentication, executing queries, checking execution status, retrieving results, and handling errors. These guides are essential for developers who want to understand the capabilities and limitations of the Dune API.\n\nFor example, the `execute-query-id.md` guide in the `api-reference` folder provides a detailed explanation of how to execute a query with or without parameters to retrieve data. It includes examples of how to use cURL to execute the query, making it a valuable resource for developers looking to retrieve data from the Dune API.\n\nThe `FAQ` folder contains guides that answer frequently asked questions about the Dune API, covering topics such as billing and pricing, functionality, and other miscellaneous topics. These guides are essential for developers and analysts who want to understand and work with the Dune API effectively.\n\nLastly, the `quick-start` folder provides guides for getting started with the Dune API using different programming languages and tools. These guides help users quickly and efficiently set up their environment, authenticate with the API, and make requests to fetch data. For example, the `api-js.md` guide in the `quick-start` folder provides a step-by-step tutorial on accessing the Dune API via JavaScript, including setting up the environment, installing required packages, and providing example scripts for fetching data using simple and parameterized queries.\n\nOverall, the `.autodoc\\docs\\json\\docs\\api` folder is an essential resource for developers and analysts working with the Dune API. It provides clear and concise information about various aspects of the API, helping users to understand its capabilities, limitations, and requirements.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\api\\summary.md"}}],["22",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\dashboards\\dashboards.md)\n\nThe app technical guide provides a detailed explanation of how to create a dashboard on Dune. The guide is divided into several sections, each of which covers a specific aspect of creating a dashboard. The first section provides an overview of what dashboards are and how they work on Dune. The second section explains how to create a new dashboard and how to name it. The third section explains how to add visualizations to the dashboard, while the fourth section explains how to add text boxes. The fifth section provides a subset of markdown syntax that can be used to manipulate text in the text boxes. The sixth section explains how to embed images and GIFs into the text boxes. Finally, the seventh section explains how to arrange the layout of the dashboard.\n\nThe guide is focused on the app folder of the Dune Docs project. It provides detailed instructions on how to create a dashboard, which is a key feature of the app. The guide explains how to add visualizations and text boxes to the dashboard, which are two important components of the app. The guide also explains how to manipulate text and embed images and GIFs into the text boxes, which are important features of the app. Finally, the guide explains how to arrange the layout of the dashboard, which is an important aspect of the app's user interface.\n\nThe guide provides several examples to illustrate how to create a dashboard on Dune. These examples include screenshots and GIFs that show how to perform specific tasks, such as adding visualizations and text boxes to the dashboard, embedding images and GIFs into the text boxes, and arranging the layout of the dashboard. The guide also provides a subset of markdown syntax that can be used to manipulate text in the text boxes. Overall, the guide is a comprehensive resource for anyone who wants to create a dashboard on Dune.\n## Questions: \n 1. What is the purpose of Dune Docs and how does it relate to blockchain technology?\n   \n   The app technical guide does not provide information on the purpose of Dune Docs or its relation to blockchain technology, so a blockchain SQL analyst may have to seek additional information from other sources.\n\n2. Can Dune Docs integrate with SQL databases commonly used in blockchain applications?\n   \n   The app technical guide does not provide information on whether Dune Docs can integrate with SQL databases commonly used in blockchain applications, so a blockchain SQL analyst may have to seek additional information from other sources or contact the Dune Docs team directly.\n\n3. Are there any security features in place to protect sensitive data that may be displayed on Dune Docs dashboards?\n   \n   The app technical guide does not provide information on any security features in place to protect sensitive data that may be displayed on Dune Docs dashboards, so a blockchain SQL analyst may have to seek additional information from other sources or contact the Dune Docs team directly.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\dashboards.md"}}],["23",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\dashboards\\ecosystem-dashboards.md)\n\nThis app technical guide covers the Ecosystem Dashboards feature of the Dune app. The purpose of this feature is to provide users with a way to explore and discover general ecosystem-level metrics related to blockchain data. The guide highlights two specific dashboards: Gas Prices and DeFi Adoption.\n\nThe Gas Prices dashboard, created by @kroeger0x, displays data on average gas spent per transaction, gas limit, gas spent in total in a block, and more. The dashboard is easy to view and provides users with valuable insights into gas prices on the blockchain. The guide includes two screenshots of the dashboard to give users an idea of what it looks like.\n\nThe DeFi Adoption dashboard, created by @rchen8, compiles user numbers of all important DeFi protocols into one dashboard. This dashboard provides users with a way to track the growth and adoption of DeFi over time. The guide includes a screenshot of the dashboard to give users an idea of what it looks like.\n\nOverall, this app technical guide provides users with an overview of the Ecosystem Dashboards feature of the Dune app and highlights two specific dashboards that users can explore. The guide is useful for users who want to gain insights into blockchain data and track the growth and adoption of DeFi.\n## Questions: \n 1. What blockchain data is included in Dune and how is it organized? \n- The app technical guide mentions that Dune has \"almost all blockchain data in one place,\" so a blockchain SQL analyst might want to know what specific data is included and how it is structured within the app.\n\n2. How does Dune gather and update its data? \n- A blockchain SQL analyst might be interested in understanding the data collection and maintenance process for Dune, in order to assess the accuracy and reliability of the metrics provided.\n\n3. Can Dune be integrated with other blockchain analytics tools or databases? \n- A blockchain SQL analyst might want to know if Dune can be used in conjunction with other tools or databases they are already using, in order to streamline their workflow and improve their analysis capabilities.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\ecosystem-dashboards.md"}}],["24",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\dashboards\\index.md)\n\n# Dune Docs Use Cases\n\nThis technical guide provides an overview of Dune, a blockchain data analytics platform, and its use cases. The guide is divided into two main sections: an introduction to Dune and its user groups, and a list of broad use cases for the platform.\n\n## Introduction to Dune\n\nDune is an open platform that serves three main user groups: Dune Spectators, Dune Wizards, and Dune Patrons. Dune Spectators can view on-chain data through dashboards on Dune.com. Dune Wizards use the raw data ingested by the Dune Platform to create dashboards, visualizations, and queries. Dune Patrons, including crypto communities, protocols, and companies, leverage Dune's powers to solve problems and share insights within their organizations.\n\n## Dune Use Cases\n\nDune can be used to explore nearly the entire world of blockchain data analytics. The guide provides three broad use cases for Dune:\n\n- Project Dashboards: Dashboards that provide insights into specific blockchain projects.\n- Sector Dashboards: Dashboards that provide insights into specific sectors of the blockchain industry.\n- Ecosystem Dashboards: Dashboards that provide insights into the broader blockchain ecosystem.\n\nThe guide notes that there are few limitations to what can be queried and visualized with Dune.\n\n## Dune Content\n\nTo get more insights into how people use Dune, the guide recommends following Dune's Twitter account, where the most interesting things that happen on Dune are retweeted. The guide provides a link to Dune's Twitter account and timeline.\n\nOverall, this technical guide provides a high-level overview of Dune and its use cases. It is useful for anyone interested in using Dune for blockchain data analytics, particularly those interested in creating dashboards, visualizations, and queries.\n## Questions: \n 1. What blockchain data does Dune ingest and analyze?\n- The app technical guide does not provide specific information on the type of blockchain data that Dune ingests and analyzes.\n\n2. Can Dune be integrated with SQL databases?\n- The app technical guide does not mention anything about integrating Dune with SQL databases.\n\n3. Are there any limitations to the amount of data that can be queried and visualized with Dune?\n- The app technical guide states that there aren't many limitations to what can be queried and visualized with Dune, but it does not provide specific information on any potential limitations.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\index.md"}}],["25",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\dashboards\\project-dashboards.md)\n\n# Project Dashboards\n\nThis technical guide covers the topic of Project Dashboards, which is a feature of the Dune Docs project. Project Dashboards allow users to easily assemble data on their favorite project in one place without having to maintain infrastructure or overhead. The purpose of this guide is to explain how to use Project Dashboards and provide an example of how they can be used.\n\nThe guide starts by explaining that Project Dashboards are a great way to track the metrics of your project. It then goes on to explain that you can simply query for the data you desire and assemble it on a Dashboard to make a Datahub for your project Reality. This means that users can easily view and understand important data about their project without having to go through multiple sources.\n\nThe guide then provides an example of a Project Dashboard for Tornado.Cash by @poma. The Dashboard shows many important metrics for the protocol, all in one place. The guide explains that @poma wanted to show a few \"at a glance\" counters which make important data like total deposits and unique users easy to view and understand by just about anyone. @poma follows this up with some interesting historical data points which show the growth in users and volume. The Dashboard continues, but you can clearly already see how much value these stats and charts can produce for a company, protocol, or community.\n\nFinally, the guide provides a link to the Dune Projects Page where users can find many other great Dashboards. This guide is useful for users who want to learn how to use Project Dashboards and how they can be used to track the metrics of their project.\n## Questions: \n 1. What kind of data sources does this app support for assembling project dashboards?\n   - The app technical guide mentions that users can \"simply query for the data you desire\" to assemble a dashboard, but it does not specify what kind of data sources are supported.\n\n2. Can this app be integrated with blockchain data sources?\n   - The app technical guide does not mention anything about integrating with blockchain data sources, which might be of interest to a blockchain SQL analyst.\n\n3. Are there any limitations to the types of metrics that can be tracked on a project dashboard?\n   - The app technical guide does not mention any limitations to the types of metrics that can be tracked on a project dashboard, but a blockchain SQL analyst might want to know if there are any restrictions or limitations to the types of data that can be displayed.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\project-dashboards.md"}}],["26",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\dashboards\\sector-dashboards.md)\n\n# Sector Dashboards\n\nThis technical guide covers the Sector Dashboards feature of the Dune Docs project. Sector Dashboards provide an overview of an entire sector of the crypto economy and allow users to analyze what's happening in real-time. The purpose of this guide is to explain how Sector Dashboards work and provide examples of how they can be used.\n\nThe guide starts with an overview of Sector Dashboards and their purpose. It then provides examples of three different Sector Dashboards: Dex Metrics, Indices, and Lending. Each example includes a link to the dashboard and a brief explanation of what it shows.\n\nThe Dex Metrics dashboard provides data on the entire Decentralized Exchange sector, including metrics like Dex Volume, Market Share, and Total Volume across all exchanges. The dashboard is maintained by the community, and new DEXes can be added by submitting code to the public GitHub.\n\nThe Indices dashboard covers the entire state of a sector in one glance, allowing users to compare different products and projects with ease. It provides data on the AUM (Assets Under Management) of different indices and projects.\n\nThe Lending dashboard allows users to easily check the state of lending as a sector and compare protocol performance. It provides data on lending deposits and borrowers.\n\nOverall, this guide provides an introduction to Sector Dashboards and how they can be used to analyze different sectors of the crypto economy. The examples provided demonstrate the usefulness of Sector Dashboards in providing real-time data and insights into different sectors.\n## Questions: \n 1. What data sources are used to populate the sector dashboards?\n   - The app technical guide does not provide information on the data sources used to populate the sector dashboards.\n2. Can the community add new sectors to the dashboard, or is it limited to the ones already included?\n   - The app technical guide mentions that new DEXes can be added to the dashboard by submitting their code to the public GitHub, but it does not specify if new sectors can be added in the same way.\n3. Is there any integration with blockchain or SQL databases to provide real-time data updates?\n   - The app technical guide does not mention any integration with blockchain or SQL databases to provide real-time data updates.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\sector-dashboards.md"}}],["27",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\app\\dashboards)\n\nThe `.autodoc\\docs\\json\\docs\\app\\dashboards` folder contains a collection of technical guides focused on the dashboard features of the Dune Docs project. These guides provide detailed explanations and examples on how to create, use, and explore various types of dashboards within the Dune app.\n\nThe `dashboards.md` guide offers a comprehensive tutorial on creating a dashboard on Dune, including adding visualizations, text boxes, manipulating text, embedding images and GIFs, and arranging the layout. This guide is essential for users who want to create custom dashboards to analyze and visualize blockchain data.\n\nThe `ecosystem-dashboards.md` guide highlights the Ecosystem Dashboards feature, which allows users to explore general ecosystem-level metrics related to blockchain data. The guide showcases two specific dashboards, Gas Prices and DeFi Adoption, providing valuable insights into gas prices and the growth of DeFi.\n\nThe `index.md` guide serves as an introduction to Dune, its user groups, and broad use cases for the platform. It outlines three main types of dashboards: Project Dashboards, Sector Dashboards, and Ecosystem Dashboards. This guide is useful for anyone interested in using Dune for blockchain data analytics.\n\nThe `project-dashboards.md` guide focuses on Project Dashboards, which enable users to assemble data on their favorite projects in one place. It provides an example of a Project Dashboard for Tornado.Cash, demonstrating how these dashboards can be used to track important metrics for a specific project.\n\nThe `sector-dashboards.md` guide covers the Sector Dashboards feature, which provides an overview of an entire sector of the crypto economy. It includes examples of three different Sector Dashboards: Dex Metrics, Indices, and Lending. These dashboards allow users to analyze real-time data and insights into different sectors of the crypto economy.\n\nOverall, the guides in this folder are essential for users who want to leverage the dashboard features of the Dune app to analyze and visualize blockchain data. The examples provided in these guides demonstrate the usefulness of dashboards in providing real-time data and insights into various aspects of the blockchain ecosystem.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\dashboards\\summary.md"}}],["28",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\decoding-contracts.md)\n\nThe app technical guide titled \"Decoding Contracts\" provides a comprehensive guide on how to submit contracts for decoding on the Dune platform. The guide is divided into several sections, each with a specific focus. The first section provides an overview of Decoded Contracts and how they are brought into the platform through Wizard submissions. The section explains how contracts are decoded into human-readable tables for each event and function defined in the smart contract's ABI. The section also provides a link to learn more about how Decoding works and what Decoded tables are available.\n\nThe second section of the guide focuses on submitting a new contract for decoding. The section provides three ways to submit contracts for decoding, including the New contract form, the My Creations > Contracts Tab, and within the dataset explorer in the Query editor's sidebar. The section also provides a contract submission form that consists of two steps. The first step requests the contract's address and blockchain to enable the review of potential duplicate contracts and pending submissions. The second step requests other information about the contract that is needed to decode it.\n\nThe third section of the guide provides advanced options for detecting and indexing multiple contract addresses under the same submission. The section explains two strategies for detecting other contracts for decoding, including bytecode match and factory instances. The section also provides a warning to only use these options if you know what you're doing and are extremely familiar with the project's architecture and deployment hierarchy.\n\nThe fourth section of the guide focuses on tracking submissions. The section explains how to view submissions and their processing status at any time by navigating to My Creations > Contracts.\n\nThe fifth section of the guide provides answers to frequently asked questions. The section provides answers to questions such as how to submit contract information manually, how to submit a Proxy contract, how to re-submit a contract, and how to submit Diamond Proxy contracts. The section also provides a warning that Dune rejects duplicative, incorrect, or low-quality submissions.\n\nOverall, the guide provides a detailed explanation of how to submit contracts for decoding on the Dune platform. The guide is well-structured and easy to follow, with examples and images provided where appropriate.\n## Questions: \n 1. What is the process for submitting a new contract for decoding?\n- Contracts can be submitted for decoding through the new contract form, the My Creations > Contracts Tab, or within the dataset explorer in the Query editor's sidebar. The contract submission form consists of two steps: blockchain and address, and contract details.\n\n2. How does Dune index multiple contract addresses under the same submission?\n- Dune can automatically detect and index multiple contract addresses under the same submission by using bytecode match or factory instances. If users want Dune to index more than one contract, they can toggle on Advanced options and select \"Yes\" to the first question, \"Are there several instances of this contract?\"\n\n3. How do I re-submit a contract?\n- If users attempt to submit a contract that already exists, Dune will first present a warning note and ask users to confirm if they want to proceed. Then, at the bottom of the Details page, Dune will ask users to explain why they're resubmitting the contract so Dune can assess whether it's worth overriding the contract's data. If Dune believes the risk of accepting a re-submission is higher than the added value, Dune will reject the resubmission.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\decoding-contracts.md"}}],["29",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\index.md)\n\nThe App Overview technical guide provides an introduction to the dune.com app and its features. The guide is intended to help users understand how the app works and how to leverage its interface to make magic with blockchain data. \n\nThe guide is divided into five sections, each of which is focused on a specific feature of the app. The Queries section provides guides and explanations for data explorer and query creation questions. The Visualizations section provides guides and explanations for visualization creation, formatting, and embedding questions. The Dashboards section is a collection of example dashboard how-to's and use cases to generate inspiration from. The Decoding section explains the process for submitting a contract for decoding on EVM chains. Finally, the Teams section features allow organizations to form a combined profile for wizards to contribute and work together under.\n\nThe guide is written in a friendly and approachable tone, with emojis and exclamation points used to add personality and enthusiasm. The guide also includes links to other resources, such as the Getting Started guide, to help users get up to speed quickly. \n\nFor example, the Queries section provides a link to a guide on data explorer and query creation questions. This guide includes step-by-step instructions on how to create a query, as well as explanations of key concepts and terminology. The guide also includes screenshots to help users visualize the process. \n\nOverall, the App Overview technical guide is a useful resource for users who are new to the dune.com app or who want to learn more about its features. It provides clear explanations and practical examples to help users get the most out of the app.\n## Questions: \n 1. What blockchain data does the dune.com app work with?\n- The app works with blockchain data, but the specific blockchain(s) it supports is not mentioned in the technical guide.\n\n2. Can the app interface with SQL databases?\n- There is no mention of SQL databases in the technical guide, so it is unclear if the app can interface with them.\n\n3. Are there any limitations or restrictions on the types of queries or visualizations that can be created with the app?\n- The technical guide does not mention any limitations or restrictions on query or visualization creation, so it is unclear if there are any.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\index.md"}}],["30",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\data-explorer.md)\n\nThe app technical guide provides a detailed explanation of how to use the Data Explorer feature of the Dune Docs project. The Data Explorer is a tool that allows users to search for blockchain and other data to use in their queries. The guide explains how to use the Data Explorer to find the data you need by selecting the database you want to search in and entering keywords, protocol names, contract names, or event names into the search bar. \n\nThe guide also provides information on advanced searching in Dune V2 and V1. It explains that Dune V2 has a different data structure than V1, and that with V2, users can incorporate data from multiple chains in one SQL query. The guide provides examples of how to search for data within specific datasets and how to limit searches to specific categories for better speed. \n\nThe guide also explains the use of icons and labels in the Data Explorer, which provide information on which blockchain a Spell, Protocol contract set, or individual contract belongs to, whether a piece of data/dataset is a Spell, Decoded Contract, or Community Dataset, and what type a piece of data is. The guide provides a link to descriptions of what all the icons and labels mean. \n\nOverall, the guide provides a comprehensive overview of how to use the Data Explorer feature of the Dune Docs project, including advanced searching techniques and the use of icons and labels. It provides clear examples and instructions for users to follow, making it easy to understand and use the Data Explorer effectively.\n## Questions: \n 1. What databases can be searched using the Data Explorer?\n   \n   The Data Explorer allows searching for blockchain and other data, but a blockchain SQL analyst might want to know specifically which databases are available for searching. The app technical guide mentions that the user can select which database to search from a dropdown list, but it does not provide information on the specific databases available.\n\n2. How does the search function work in Dune V2 compared to V1?\n   \n   The app technical guide provides detailed information on how the search function works in Dune V2 and V1, including how to search for specific schemas, events, calls, and contracts. A blockchain SQL analyst might want to know the differences between the search functions in V2 and V1 to determine which version to use for their queries.\n\n3. What are the different categories of datasets available in Dune V2?\n   \n   The app technical guide mentions that there are four different categories of datasets available in Dune V2, but it does not provide information on what those categories are. A blockchain SQL analyst might want to know the categories to determine which dataset to search for their queries.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\data-explorer.md"}}],["31",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\explorer-labels.md)\n\n# Data Explorer Labels\n\nThis technical guide covers the labels used in the Data Explorer of the Dune Docs project. The guide provides a detailed explanation of the different labels used in the project, including blockchain icons, dataset icons, dataset labels, and data type labels.\n\nThe blockchain icons section explains the different blockchain icons that can be found in some data sets. Each icon represents a specific blockchain, including Ethereum, Gnosis Chain, Polygon, Optimism, BNB Chain, Solana, Arbitrum, Avalanche C-Chain, Ethereum Goerli Testnet, and Fantom. The icons can represent raw data, decoded projects, or spells.\n\nThe dataset icons section explains the different icons that represent data tables, decoded projects, spells, and community data sets. The data table icon can represent raw data, spells, or smart contract events or functions. The decoded project icon represents a protocol or protocol version, such as \"opensea\" or \"aave_v2\". The spell icon represents a spell set, such as cow_protocol containing \"batches\" and \"solvers\" spells. The community data icon represents a community data set.\n\nThe dataset labels section explains the different labels that can be used to identify a specific data set. The labels include project, sector, event, and function. The project label represents a spell set for a specific project, such as \"aave\". The sector label represents a spell set for a sector, such as \"dex\". The event label represents a smart contract event dataset, and the function label represents a smart contract function dataset.\n\nThe data type labels section explains the different labels used to represent data types. The labels include string, long, integer, double, boolean, date, timestamp, decimal, and array. The guide provides a link to the full Spark SQL data types documentation and the official PostgreSQL data types for V1 data.\n\nOverall, this technical guide provides a comprehensive explanation of the different labels used in the Data Explorer of the Dune Docs project. It helps users understand the meaning of each label and how to identify specific data sets. The guide also provides links to additional resources for more information on data types.\n## Questions: \n 1. What is the purpose of the Data Explorer in relation to blockchain data?\n- The Data Explorer is used to explore and analyze blockchain data from various blockchains, including Ethereum, Gnosis Chain, Polygon, Optimism, BNB Chain, Solana, Arbitrum, Avalanche C-Chain, Ethereum Goerli Testnet, and Fantom.\n\n2. What types of data sets are available in the Data Explorer?\n- The Data Explorer includes data sets such as Raw Data, Decoded Project, Spell, smart contract Event, smart contract Function, and Community Data Set.\n\n3. What are the available data types in the Data Explorer?\n- The available data types in the Data Explorer include string, long, integer, double, boolean, date, timestamp, decimal, and array. More information on these data types can be found in the Spark SQL data types documentation and the PostgreSQL data types documentation.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\explorer-labels.md"}}],["32",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\index.md)\n\n# Queries\n\nThis section of the app technical guide for Dune Docs covers the Query Editor feature of the app. The Query Editor allows users to input SQL code and run it to search for blockchain and other data. The guide is broken down into several sub-sections, each covering a different aspect of the Query Editor:\n\n- **The Data Explorer**: This sub-section covers the Data Explorer feature of the Query Editor. The Data Explorer allows users to search for blockchain and other data to use in their queries. The guide provides more information on how to use this feature effectively.\n\n- **The Query Window**: This sub-section covers the Query Window feature of the Query Editor. The Query Window is where users input their SQL code and run it. The guide provides more information on how to use this feature effectively.\n\n- **Query Results**: This sub-section covers the Query Results feature of the Query Editor. After running a query, users can view the data returned in the Query Results section. The guide provides more information on how to interpret and use this data effectively.\n\n- **Parameters**: This sub-section covers the Parameters feature of the Query Editor. Parameters allow users to implement variables in certain parts of their query code. The guide provides more information on how to use this feature effectively.\n\n- **Query Tips**: This sub-section provides a collection of tips to help users master query creation with Dune. The tips cover a range of topics, from basic SQL syntax to more advanced query optimization techniques.\n\nOverall, this section of the app technical guide provides a comprehensive overview of the Query Editor feature of Dune Docs. It covers all the major aspects of the feature and provides tips and best practices for using it effectively. For example, the guide might provide an example of how to use Parameters to create a more flexible and reusable query.\n## Questions: \n 1. What type of blockchain data can be searched for using Dune's Data Explorer?\n- The app technical guide does not provide specific information on what type of blockchain data can be searched for using Dune's Data Explorer.\n\n2. Can Dune's Query Editor be used with any SQL database or is it specifically designed for blockchain data?\n- The app technical guide does not provide information on whether Dune's Query Editor is specifically designed for blockchain data or if it can be used with any SQL database.\n\n3. Are there any limitations or restrictions on the use of variables in Query code using Dune's Parameters feature?\n- The app technical guide does not provide information on any limitations or restrictions on the use of variables in Query code using Dune's Parameters feature.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\index.md"}}],["33",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\parameters.md)\n\n# Parameters\n\nThis technical guide covers the use of parameters in the Dune app. Parameters are a feature that allows users to implement variables in certain parts of their Query code. This variable can be changed from dashboards, making it possible to create an interactive dashboard. \n\nThe guide explains how parameters work, how to use them, and provides an example Query and several example dashboards. Parameters are defined in the Query code as `{{parametername}}` and will appear below the Query and in any dashboards in which a Query Visualization with parameters is used in. \n\nThe guide explains how to add a parameter to a Query by writing `{{parametername}}` or using the button below the Query. Users can edit the properties of single parameters by clicking on the gear wheel next to the parameter in the Query editor. This allows users to set a default value, define a list of possible parameters, or change the type of the parameter. \n\nThe guide provides an example Query that returns the running total of Gas Paid in USD. The Query Author has chosen to include a parameter for `wallet address`, `start date`, and `end date`. The guide also provides several example dashboards that use parameters. These dashboards allow users to find interesting stats on Ethereum wallets, drill down into the single pools of Barnbridge's Smart Yield Product, find out how many people are participating in Yearn Vaults, and find out how their investment in $KLIMA is doing. \n\nIn summary, parameters allow users to make a certain part of their SQL query dynamic and thereby offer them to make Queries and dashboards interactive. That way, users can easily display detailed data on their dashboard since it allows the viewer to customize the dashboard for their needs. Parameters are like filters, but the possibilities of using this feature go beyond that.\n## Questions: \n 1. What is the syntax for defining parameters in the Query code?\n   \n   Parameters are defined in the Query code as `{{parametername}}`.\n\n2. How can parameters be shared between different Queries in a dashboard?\n   \n   Parameters in a Dashboard can be shared between different Queries, just make sure to use the same name, type and default value between all of them.\n\n3. What is the purpose of using parameters in a Query or dashboard?\n   \n   Parameters allow you to make a certain part of your SQL query dynamic and thereby offer you to make Queries and dashboards interactive. That way you can easily display detailed data on your dashboard since it allows the viewer to customize the dashboard for his needs.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\parameters.md"}}],["34",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\query-results.md)\n\nThe Query Results section of the Dune Docs app is the focus of this technical guide. The guide provides a detailed explanation of how to view and manipulate data returned by a query. The guide starts by explaining how to run a query and view the results in a table format. It also warns that queries run on the currently selected database in the Data Explorer dropdown. The guide then explains the elements above the results table, including the \"Query Results\" tab, the \"New Visualization\" button, and the \"Run\" button. \n\nThe guide also explains how to save a query, including how to make it private if the user is a Dune Premium user. After saving a query, the guide explains how to use the \"Star,\" \"Embed,\" and \"Fork\" buttons. The guide also explains how to re-run a query and how to cancel a running query. \n\nThe guide then explains how to format the results table, including how to change the title, alignment, format, and visibility of columns. The guide also explains how to color positive and negative values in a column. The guide provides a table that shows the different number formats that can be used to format column values. \n\nFinally, the guide explains how to create visualizations from query results. It instructs users to click the \"New Visualization\" button and provides a link to the Visualizations documentation. \n\nOverall, this technical guide provides a comprehensive explanation of how to use the Query Results section of the Dune Docs app. It covers everything from running a query to formatting the results table to creating visualizations. The guide is well-organized and easy to follow, making it a valuable resource for users of the app.\n## Questions: \n 1. What type of database does this app use for running queries?\n- The app technical guide does not provide information on the type of database used for running queries.\n\n2. Can users customize the formatting of the query results table?\n- Yes, users can customize the formatting and appearance of the query results table using the options provided below the table.\n\n3. Is there a limit to the number of visualizations that can be created from query results?\n- The app technical guide does not provide information on whether there is a limit to the number of visualizations that can be created from query results.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\query-results.md"}}],["35",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\query-window.md)\n\nThis app technical guide covers the Query Window feature of the Dune app. The Query Window is where users can input SQL code and run it. The guide provides an overview of the Query Window and its features, including Autocomplete, Run Selection, and Shortcuts.\n\nThe Autocomplete feature can be enabled or disabled using the gear wheel in the top right corner of the Query editor. It brings up PostgreSQL keywords, tables, and aliases that have already been included in the Query. The guide provides an example of how to turn on Autocomplete and how it works in the Query editor.\n\nThe Run Selection feature allows users to save time while testing and debugging Queries by running just a part of the Query. Users can highlight a part of the Query, and the Run button will turn into a Run Selection button. The guide provides an example of how to use the Run Selection feature and what happens when a syntactically complete and correct piece of SQL is not highlighted.\n\nThe guide also provides a list of Shortcuts to make crafting Queries faster. These shortcuts include executing the Query, commenting out selected code, bringing up a list of keywords, undoing and redoing changes, and searching for and replacing keywords. The guide notes that these shortcuts work on US/UK keyboards and may vary based on the language setting on the user's machine.\n\nOverall, this guide provides a comprehensive overview of the Query Window feature and its various functions. It is a useful resource for users who are new to the Dune app or who want to learn more about its features.\n## Questions: \n 1. What is the purpose of the Dune app and how does it relate to blockchain technology?\n   Answer: The app technical guide does not provide information on the purpose of the Dune app or its relation to blockchain technology. \n\n2. Does the Query window support SQL syntax for a specific type of database or is it database-agnostic?\n   Answer: The Query window supports PostgreSQL keywords, but the app technical guide does not provide information on whether it is specific to PostgreSQL or if it is database-agnostic.\n\n3. Are there any security features in place to prevent unauthorized access to the Query window or the SQL code entered into it?\n   Answer: The app technical guide does not provide information on any security features in place to prevent unauthorized access to the Query window or the SQL code entered into it.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\query-window.md"}}],["36",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\app\\queries)\n\nThe `.autodoc\\docs\\json\\docs\\app\\queries` folder contains a series of technical guides that focus on the Query Editor feature of the Dune Docs app. These guides provide detailed explanations and examples on how to effectively use the Query Editor and its various components, such as the Data Explorer, Query Window, Query Results, and Parameters.\n\nFor instance, the `data-explorer.md` guide offers a comprehensive overview of the Data Explorer feature, including advanced searching techniques and the use of icons and labels. This guide would be useful for users who want to search for specific blockchain data and incorporate it into their queries.\n\nThe `explorer-labels.md` guide covers the different labels used in the Data Explorer, such as blockchain icons, dataset icons, dataset labels, and data type labels. This guide helps users understand the meaning of each label and how to identify specific data sets, making it easier to navigate the Data Explorer.\n\nThe `index.md` guide provides an overview of the Query Editor feature, covering aspects like the Data Explorer, Query Window, Query Results, Parameters, and Query Tips. This guide serves as a starting point for users who want to learn more about the Query Editor and its various components.\n\nThe `parameters.md` guide focuses on the use of parameters in the Dune app, allowing users to implement variables in their query code and create interactive dashboards. This guide would be helpful for users who want to create more flexible and reusable queries.\n\nThe `query-results.md` guide explains how to view and manipulate data returned by a query, including how to format the results table and create visualizations. This guide is valuable for users who want to interpret and use the data effectively.\n\nThe `query-window.md` guide covers the Query Window feature and its functions, such as Autocomplete, Run Selection, and Shortcuts. This guide is useful for users who are new to the Dune app or want to learn more about its features.\n\nLastly, the `tips.md` guide provides users with tips and tricks to help them become more proficient in querying data using Dune. This guide covers various aspects, such as using Spells, formatting Ethereum addresses, quoting column and table names, removing decimals, and more.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\app\\queries` folder provide a comprehensive understanding of the Query Editor feature and its various components, making it easier for users to effectively use the Dune Docs app for their data analysis needs.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\summary.md"}}],["37",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\queries\\tips.md)\n\nThe Query Tips technical guide provides users with tips and tricks to help them become more proficient in querying data using Dune. The guide is divided into several sections, each of which focuses on a specific feature of the Dune app. \n\nThe first section of the guide is titled \"Use Spells\" and explains how users can use the well-organized data found in Spells to perform great analysis. Spells are tables that are cleaned and contain data/metadata that make them very straightforward to query. \n\nThe second section of the guide is titled \"V1 Inline Ethereum Addresses Formatting\" and explains how Ethereum addresses are stored as PostgreSQL byte arrays, which are encoded with the `\\x` prefix. This section provides users with an example of how to use an inline address to filter for a given token. \n\nThe third section of the guide is titled \"Quote Column and Table Names in camelCase\" and explains how column and table names are mostly taken directly from smart contract Application Binary Interfaces (ABIs), with no modification. This section provides users with an example of how to reference column and table names in PostgreSQL. \n\nThe fourth section of the guide is titled \"Remove Decimals\" and explains how to transmute ERC-20 tokens into a more human-friendly form by using the `erc20.tokens` table and dividing the token's `transfer_value` by 10. This section provides users with examples of how to perform this operation in both PostgreSQL and Spark SQL. \n\nThe fifth section of the guide is titled \"Get time with `date_trunc`\" and explains how to use the `date_trunc` function to get the time from decoded event tables. This section provides users with an example of how to use `date_trunc` to get the week from an event table. \n\nThe sixth section of the guide is titled \"How to get USD price\" and explains how to get the USD price of on-chain activity by joining the smart contract event with the `prices.usd` on the `minute` for a given `asset`. This section provides users with an example of how to perform this operation in PostgreSQL. \n\nThe seventh section of the guide is titled \"Token symbols\" and explains how to group results by token address using the token symbol instead. This section provides users with examples of how to perform this operation in both PostgreSQL and Spark SQL. \n\nThe eighth section of the guide is titled \"Filter Queries and Dashboards with Parameters\" and explains how to use parameters to turn a Query or Dashboard into an app for blockchain data. This section provides users with an example of how to add a parameter to a Query and how to use the parameter in a WHERE clause. \n\nOverall, the Query Tips technical guide provides users with a comprehensive overview of how to use Dune to query data effectively.\n## Questions: \n 1. What is the purpose of the app and what kind of data does it analyze?\n- The app is called Dune Docs and it provides Query related tips to help users become more powerful in analyzing data. It analyzes blockchain data.\n\n2. What is the difference between Dune V1 and other versions of the app?\n- Dune V1 engine has features that are not available in other versions of the app, such as V1 Inline Ethereum Addresses Formatting and Quote Column and Table Names in camelCase.\n\n3. How can parameters be used to filter queries and dashboards in the app?\n- Parameters can be added to the SQL editor on the Query editor page by clicking `Add parameter` in the bottom right corner. The name of the parameter is put inside double curly brackets, and if it is used in the WHERE clause, it needs to be enclosed in single quotes.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\queries\\tips.md"}}],["38",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\app)\n\nThe `.autodoc\\docs\\json\\docs\\app` folder contains technical guides that focus on various aspects of the Dune Docs app, such as decoding contracts, creating queries, and visualizing data. These guides are essential for users who want to effectively use the Dune Docs app for their data analysis needs.\n\nFor instance, the `decoding-contracts.md` guide provides a comprehensive overview of submitting contracts for decoding on the Dune platform. It covers different methods of submitting contracts, advanced options for detecting and indexing multiple contract addresses, and tracking submissions. This guide is useful for users who want to decode smart contracts into human-readable tables for each event and function defined in the contract's ABI.\n\nThe `index.md` guide serves as an introduction to the Dune app and its features, such as Queries, Visualizations, Dashboards, Decoding, and Teams. This guide is a starting point for users who want to learn more about the app and how to leverage its interface to analyze and visualize blockchain data.\n\nThe `teams.md` guide covers the Teams feature of the Dune app, which allows users to collaborate on shared content. It explains the benefits of creating a Team, different user roles, and how to get started with Teams. This guide is useful for users who want to collaborate with others on shared content and showcase all of a Team's work in one place.\n\nThe subfolders in this folder provide more in-depth guides on specific features of the Dune app. For example, the `dashboards` subfolder contains guides on creating and using various types of dashboards, such as Project Dashboards, Sector Dashboards, and Ecosystem Dashboards. These guides are essential for users who want to analyze and visualize blockchain data using custom dashboards.\n\nThe `queries` subfolder contains guides that focus on the Query Editor feature and its various components, such as the Data Explorer, Query Window, Query Results, and Parameters. These guides provide detailed explanations and examples on how to effectively use the Query Editor to create and manipulate queries.\n\nThe `visualizations` subfolder contains guides on creating and customizing various types of visualizations, such as charts, graphs, tables, and counters. These guides are essential for users who want to analyze and present their data effectively through visually appealing and informative representations.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\app` folder provide a comprehensive understanding of the Dune Docs app and its various features, making it easier for users to effectively use the app for their data analysis needs. The examples provided in these guides demonstrate the usefulness of the app in providing real-time data and insights into various aspects of the blockchain ecosystem.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\summary.md"}}],["39",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\teams.md)\n\n# Teams\n\nThis technical guide covers the Teams feature of the Dune app. Teams are shared workspaces for Wizards to collaborate within. The guide explains the benefits of creating a Team, such as collaborating on the same content, having a separate workspace for each Team, and showcasing all of a Team's work in one place. It also explains the different user roles available for Team members, such as viewers, editors, and admins.\n\nThe guide provides step-by-step instructions for getting started with Teams, including creating a Team, adding users, and transferring content to a Team. It also explains how to find a Team's content using the My Creations feature and provides a FAQ section that addresses common questions about Teams.\n\nFor example, to create a Team, users need to head over to Settings > Teams and add a bit of sparkle to their Team's profile. They can then invite other Dune Wizards to join their Team in the People section of their Team's Settings page and assign them one of the available roles. Team Queries and Dashboards are created the same way they are for individual accounts, and users can pick their Team as the Owner when prompted to save them for the first time.\n\nOverall, this technical guide provides a comprehensive overview of the Teams feature of the Dune app and is a useful resource for users who want to collaborate with others on shared content.\n## Questions: \n 1. What is the underlying technology used for storing and managing the data in Dune Teams?\n- The app technical guide does not provide information on the underlying technology used for storing and managing the data in Dune Teams.\n\n2. Can Dune Teams be integrated with blockchain-based platforms?\n- The app technical guide does not provide information on whether Dune Teams can be integrated with blockchain-based platforms.\n\n3. How does Dune Teams ensure data privacy and security?\n- The app technical guide does not provide information on how Dune Teams ensures data privacy and security.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\teams.md"}}],["40",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\visualizations\\charts-graphs.md)\n\n# Charts & Graphs\n\nThis technical guide covers how to create different types of graphs and charts using Dune. The guide explains how to create bar charts, area charts, scatter charts, line charts, pie charts, and mixed graphs. It also explains how to configure each visualization option, including chart options, result data, x-axis options, y-axis options, series options, and pie options.\n\nThe guide provides examples of each type of graph and explains how to edit each graph type. For instance, the guide explains how to enable or disable the legend for the chart, stack the chart values on top of each other based on the x-axis values, normalize the chart to display percentage values of the chosen data table, and display the individual datapoints inside of the graph.\n\nThe guide also explains how to pick the data points that are to be displayed, how to influence how your x-axis data gets displayed, and how to influence how your y-axis data gets displayed. Additionally, the guide explains how to finalize your graph by renaming the \"series,\" changing the chart type, changing the colors, and changing the order of the series.\n\nFinally, the guide explains how to format tick and label formats for numeric values and axis labels in your graphs. It provides a table that shows how to format tick and label formats for different starting values. \n\nOverall, this technical guide provides a comprehensive overview of how to create different types of graphs and charts using Dune. It is a useful resource for anyone who wants to create visualizations of their data.\n## Questions: \n 1. What types of data sources does Dune Docs support for creating charts and graphs?\n- The app technical guide does not provide information on the types of data sources supported by Dune Docs for creating charts and graphs.\n\n2. Can Dune Docs create charts and graphs for real-time data?\n- The app technical guide does not provide information on whether Dune Docs can create charts and graphs for real-time data.\n\n3. Does Dune Docs support customization of chart and graph colors beyond the browser native color selector?\n- The app technical guide does not provide information on whether Dune Docs supports customization of chart and graph colors beyond the browser native color selector.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\visualizations\\charts-graphs.md"}}],["41",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\visualizations\\embeds.md)\n\n# Embeds\n\nThis technical guide explains how to use the Embeds feature in the Dune Docs project. Embeds allow users to share live Dune charts across different web platforms. The guide starts by explaining how to generate an embed link by clicking on any query title and selecting the embed function in the top right corner. The guide also clarifies that the embed button works as a standalone link and as a way to embed live graphs into websites/apps. If a query has no visualizations, the link will be to the query results table. If there are multiple visualizations, the link will be for whichever visualization the user has selected when they clicked the Embed button.\n\nThe guide then goes on to explain how to use Embeds on different platforms such as Twitter, Discord, web pages, and Mirror.xyz. For Twitter, users can simply paste their embed link, and Twitter will render and update Dune visualizations automatically. For Discord, users can drop the embed link in the chat, and the corresponding visualization will be displayed. The guide also explains how to add live visualizations to any web page using an `iframe` and provides a code snippet example. For Mirror.xyz, users can easily embed Dune visualizations into articles by generating an embed link and postfixing it with `?display=iframe`.\n\nThe guide also highlights some known issues with Embeds, stating that they do not work in a couple of popular web platforms such as Substack, Medium, and GitBook. Finally, the guide explains how to use parameterized embeds, which work with parameterized queries. However, it is a bit tricky to get them to work, and users need to manually prefix the parameter link with the parameters. The guide provides an example of how to do this.\n\nOverall, this technical guide provides a comprehensive explanation of how to use the Embeds feature in the Dune Docs project. It covers different platforms and provides examples and code snippets to help users understand how to use Embeds effectively.\n## Questions: \n 1. What is the purpose of Dune Docs and how does it relate to blockchain technology?\n    \n    Answer: The app technical guide does not provide information on the purpose of Dune Docs or its relation to blockchain technology, so a blockchain SQL analyst might have this question.\n\n2. Can Dune embeds be used with other data visualization tools besides Dune charts?\n    \n    Answer: The app technical guide does not provide information on whether Dune embeds can be used with other data visualization tools, so a blockchain SQL analyst might have this question.\n\n3. Are there any security concerns with using Dune embeds on web pages or other platforms?\n    \n    Answer: The app technical guide does not provide information on any security concerns with using Dune embeds, so a blockchain SQL analyst might have this question.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\visualizations\\embeds.md"}}],["42",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\visualizations\\index.md)\n\n# Visualizations\n\nThis technical guide is focused on the app feature of creating visualizations in the Dune project. The purpose of this guide is to provide information on how to create various types of visualizations using Dune.\n\nThe guide is divided into two main sections:\n\n## Charts & Graphs\n\nThis section explains and provides examples on how to create popular visualizations using Dune. It covers various types of charts and graphs such as line charts, bar charts, scatter plots, and pie charts. The section also provides information on how to customize the visualizations by changing colors, labels, and legends.\n\nExample: If a user wants to create a line chart to display the trend of sales over time, they can refer to this section to learn how to create the chart and customize it to their needs.\n\n## Other Visualizations\n\nThis section covers a few more unique visualizations that can be created using Dune. It includes examples such as heat maps, word clouds, and network graphs. The section provides information on how to create these visualizations and customize them.\n\nExample: If a user wants to create a network graph to display the relationships between different entities, they can refer to this section to learn how to create the graph and customize it to their needs.\n\nOverall, this technical guide provides a comprehensive overview of how to create various types of visualizations using Dune. It is a useful resource for users who want to create visualizations to analyze and present their data.\n## Questions: \n 1. What data sources does Dune Docs support for creating visualizations?\n- The app technical guide does not provide information on the data sources supported by Dune Docs for creating visualizations.\n\n2. Are there any limitations or restrictions on the types of visualizations that can be created using Dune Docs?\n- The app technical guide does not mention any limitations or restrictions on the types of visualizations that can be created using Dune Docs.\n\n3. Is there any information on how to integrate Dune Docs with blockchain data stored in a SQL database?\n- The app technical guide does not provide any information on how to integrate Dune Docs with blockchain data stored in a SQL database.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\visualizations\\index.md"}}],["43",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/app\\visualizations\\other-visualizations.md)\n\nThis app technical guide covers non-graph visualizations that can be created using Dune. The guide is divided into two sections: Tables and Counters. \n\nThe Tables section explains how to create tables to display data. The default visualization for query results is a table, and users can create additional tables using the \"New visualization\" button and drop-down menu. The guide provides instructions on how to configure tables, including options for the table title and each column. Users can adjust the text alignment, numerical format, and visibility of each column. For numerical columns, users can choose between a normal display or a progress bar display, and can color positive and negative values. \n\nThe Counters section explains how to create counters, which are useful for displaying \"on a glance\" stats. Users can define which column and row of the underlying data table they want to display, and can adjust the formatting of the numerical data. Users can add a prefix or suffix to the counter value, and can choose how many decimal places to display. Additionally, users can add a label beneath the counter value. \n\nThe guide provides several examples of each type of visualization, including screenshots of the configuration options. Overall, this guide is a useful resource for users who want to create non-graph visualizations using Dune.\n## Questions: \n 1. What kind of data sources does Dune Docs support for creating visualizations?\n- The app technical guide does not provide information on the data sources supported by Dune Docs for creating visualizations.\n\n2. Can Dune Docs create visualizations for blockchain data stored in SQL databases?\n- The app technical guide does not provide information on whether Dune Docs can create visualizations for blockchain data stored in SQL databases.\n\n3. What kind of numerical formats can be used for data displayed in Counters and Tables?\n- The app technical guide provides information on the numerical formats that can be used for data displayed in Counters and Tables, including the ability to adjust the number of decimal places and add prefixes and suffixes to the data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\visualizations\\other-visualizations.md"}}],["44",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\app\\visualizations)\n\nThe `.autodoc\\docs\\json\\docs\\app\\visualizations` folder contains technical guides that focus on creating and customizing various types of visualizations using the Dune project. These guides are essential for users who want to analyze and present their data effectively through charts, graphs, and other visual representations.\n\nThe **charts-graphs.md** guide provides a comprehensive overview of creating different types of graphs and charts, such as bar charts, area charts, scatter charts, line charts, pie charts, and mixed graphs. It explains how to configure each visualization option and provides examples for each graph type. This guide is useful for users who want to create visually appealing and informative graphs to represent their data.\n\nThe **embeds.md** guide explains how to use the Embeds feature in the Dune Docs project, which allows users to share live Dune charts across different web platforms. It covers how to generate an embed link and use Embeds on various platforms like Twitter, Discord, web pages, and Mirror.xyz. This guide is beneficial for users who want to share their visualizations with a wider audience or embed them into websites and apps.\n\nThe **index.md** guide serves as an introduction to the visualizations feature in the Dune project. It provides an overview of the different types of visualizations that can be created using Dune, such as line charts, bar charts, scatter plots, pie charts, heat maps, word clouds, and network graphs. This guide is a starting point for users who want to explore the various visualization options available in Dune.\n\nThe **other-visualizations.md** guide covers non-graph visualizations, such as tables and counters. It explains how to create and configure tables to display data and how to create counters for displaying \"on a glance\" stats. This guide is useful for users who want to create non-graph visualizations to complement their data analysis.\n\nOverall, the guides in the `visualizations` folder provide a detailed and comprehensive understanding of creating various types of visualizations using the Dune project. These guides are essential for users who want to effectively analyze and present their data through visually appealing and informative representations.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\app\\visualizations\\summary.md"}}],["45",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\arbitrages.md)\n\n# Arbitrages\n\nThis section of the app technical guide covers the `flashbots.arbitrages` table, which contains records with additional information about each arbitrage trade. The table includes various columns such as `block_number`, `account_address`, `created_at`, `end_amount`, `error`, `id`, `profit_amount`, `profit_token_address`, `protocols`, `start_amount`, `transaction_hash`, and `timestamp`. Each column is described in detail in the table.\n\nThe purpose of this section is to provide information on how to query the `flashbots.arbitrages` table and understand the data contained within it. The guide includes a query example that can be found at [Total Arb Protocols](https://dune.com/queries/626076/1167481), which demonstrates how to use the table to retrieve information on arbitrage trades.\n\nOverall, this section of the app technical guide is useful for developers who are working with the `flashbots.arbitrages` table and need to understand its structure and how to query it effectively.\n## Questions: \n 1. What is the purpose of the `flashbots.arbitrages` table in the Dune Docs app?\n- The `flashbots.arbitrages` table contains records with additional information about each arbitrage trade.\n\n2. What type of data is stored in the `profit_amount` column?\n- The `profit_amount` column stores the profit amount after the arbitrage.\n\n3. Is there a link to query examples for the `flashbots.arbitrages` table?\n- Yes, query examples for the `flashbots.arbitrages` table can be found at [Total Arb Protocols](https://dune.com/queries/626076/1167481).","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\arbitrages.md"}}],["46",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\index.md)\n\n# Flashbots\n\nThis section of the app technical guide covers the Flashbots project, which is a research and development organization aimed at ensuring that MEV (Miner Extractable Value) incentives do not become opaque and undemocratic. MEV refers to the profit that miners can make by reordering, censoring, or including transactions in a block. \n\nThe guide notes that mev-inspect-py, which is Flashbots' open-source engine for generating MEV data, powers dashboards such as mev-explore and Dune's Flashbots integration. The guide encourages researchers and developers to report any bugs they find or implement new features to improve the engine. \n\nThe guide provides links to the Flashbots documentation and Discord channel for more information and updates on their data and mev-inspect. \n\nExample: If a developer is working on integrating Flashbots into their project, they can consult the Flashbots documentation to understand how to use mev-inspect-py to generate MEV data and how to integrate it into their project. They can also join the Flashbots Discord channel to ask questions and get updates on any new features or bug fixes.\n## Questions: \n 1. What is the purpose of Flashbots and how does it relate to blockchain technology?\n- Flashbots is a research and development organization that aims to prevent MEV incentives from becoming opaque and undemocratic in blockchain technology.\n\n2. What is mev-inspect-py and how is it used in the app?\n- mev-inspect-py is an open source engine used to generate MEV data and is used to power dashboards such as mev-explore and Dune's Flashbots integration.\n\n3. How can researchers and developers contribute to the improvement of the app?\n- Researchers and developers can report and help correct any found bugs or implement new features by consulting the documentation and joining the Flashbots discord for more information and updates on their data and mev-inspect.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\index.md"}}],["47",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\liquidations.md)\n\n# Liquidations\n\nThis section of the app technical guide covers the `flashbots.liquidations` table, which contains details related to executed liquidations. Liquidation is a Miner Extractable Value (MEV) strategy. MEV refers to the value that miners can extract from the blockchain by reordering, censoring, or including transactions in blocks. \n\nThe table contains the following columns:\n\n- `created_at`: Time of the record's creation.\n- `transaction_hash`: Transaction hash.\n- `trace_address`: Trace pattern related to the position of the transaction in the chain of all transactions related to the MEV trade.\n- `debt_token_address`: Underlying token address of the debt to pay.\n- `received_amount`: Amount received from the liquidation.\n- `protocol`: Protocol name.\n- `liquidated_user`: Address of the liquidated user.\n- `liquidator_user`: Address of the liquidator user.\n- `received_token_address`: Address of the received asset.\n- `block_number`: Block number.\n- `debt_purchase_amount`: Amount of purchased debt.\n- `timestamp`: Timestamp of the latest update of the file.\n\nThe guide provides a query example for the `flashbots.liquidations` table. The query is called \"Liquidations by Protocol\" and can be found at [https://dune.com/queries/625715/1166880](https://dune.com/queries/625715/1166880). \n\nThis section of the app technical guide is relevant to the `app` folder of the project, as it provides information on the `flashbots.liquidations` table, which is likely used in the app's interface to display liquidation data to users.\n## Questions: \n 1. What is the purpose of the liquidations table in the context of blockchain and how is it related to MEV (Miner Extractable Value)? \n- The liquidations table contains details related to executed liquidations, which is another MEV strategy. It shows the underlying token address of the debt to pay, amount received from the liquidation, and other relevant information.\n\n2. Are there any specific protocols or blockchain networks that this app technical guide is designed for? \n- The app technical guide does not specify any particular protocols or blockchain networks. However, it does provide a query example for liquidations by protocol using Dune Analytics.\n\n3. How frequently is the liquidations table updated and what triggers the updates? \n- The app technical guide states that the timestamp column shows the latest update of the file, but it does not provide information on how frequently the table is updated or what triggers the updates.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\liquidations.md"}}],["48",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\mev_summary.md)\n\n# `mev_summary` Table\n\nThe `mev_summary` table is a part of the Dune Docs project and contains a summary of all the classified transactions. This table is located in the `app` folder of the project. The purpose of this table is to provide a summary of all the transactions that have been classified. \n\nThe table contains several columns such as `block_timestamp`, `block_number`, `base_fee_per_gas`, `coinbase_transfer`, `error`, `gas_price`, `gas_price_with_coinbase_transfer`, `gas_used`, `gross_profit_usd`, `miner_address`, `miner_payment_usd`, `protocol`, `protocols`, `transaction_hash`, `type`, and `timestamp`. Each column has a specific type and description. \n\nFor example, the `block_timestamp` column is of type `timestamp` and contains the block timestamp. The `block_number` column is of type `bigint` and contains the block number. The `type` column is of type `string` and contains the type of the MEV (e.g. arbitrage). \n\nQuery examples for this table can be found on the Dune website. One such example is the \"Miner Revenue from Liquidations and Arbitrages\" query, which can be found at [https://dune.com/queries/625974/1167301](https://dune.com/queries/625974/1167301). \n\nOverall, the `mev_summary` table is an important part of the Dune Docs project as it provides a summary of all the classified transactions. This information can be used to analyze and understand the MEV ecosystem.\n## Questions: \n 1. What is the purpose of the `mev_summary` table in the context of blockchain and SQL analysis?\n- The `mev_summary` table contains a summary of all classified transactions, which can be useful for analyzing miner revenue and profit in the context of MEV (miner-extractable value) strategies.\n\n2. Can this table be joined with other tables in the dune docs database, and if so, which ones?\n- It is unclear from the provided technical guide whether this table can be joined with other tables in the dune docs database. Further exploration of the database schema and documentation may be necessary to determine this.\n\n3. Are there any limitations or caveats to be aware of when using this table for analysis?\n- The technical guide does not provide information on any limitations or caveats to be aware of when using this table for analysis. It may be necessary to consult additional documentation or conduct further testing to identify any potential issues.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\mev_summary.md"}}],["49",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\sandwiched-swaps.md)\n\n# Sandwiched Swaps\n\nThis section of the app technical guide covers the `flashbots.sandwiched_swaps` table, which contains additional data about one or more swaps that were sandwiched with a corresponding sandwich in the database. The table includes columns such as `created_at`, `block_number`, `sandwich_id`, `trace_address`, `transaction_hash`, and `timestamp`.\n\nThe `created_at` column indicates the time of the record's creation, while the `block_number` column shows the block number of the swap. The `sandwich_id` column contains the internal ID of the sandwiched swap, and the `trace_address` column shows the trace pattern related to the position of the swap in the chain of all swaps related to the arbitrage trade. The `transaction_hash` column contains the transaction hash, and the `timestamp` column shows the timestamp of the latest update of the file.\n\nQuery examples for this table can be found in the file located at `dune docs/app/query/sandwiched_swaps.sql`. These examples demonstrate how to retrieve data from the `flashbots.sandwiched_swaps` table using SQL queries.\n\nOverall, this section of the app technical guide provides information on how to work with the `flashbots.sandwiched_swaps` table in the Dune Docs app. It covers the purpose of the table and the columns it contains, as well as providing examples of how to query the table.\n## Questions: \n 1. What is the purpose of the sandwiched_swaps table in the context of blockchain and SQL analysis?\n- A blockchain SQL analyst might want to know how the sandwiched_swaps table fits into the overall data analysis process and what insights it can provide about swaps and arbitrage trades.\n\n2. Are there any limitations or potential issues with the data in the sandwiched_swaps table?\n- A blockchain SQL analyst might want to know if there are any data quality issues or limitations that could affect the accuracy of their analysis.\n\n3. How frequently is the sandwiched_swaps table updated and what is the source of the data?\n- A blockchain SQL analyst might want to know how often they can expect new data to be added to the table and where that data is coming from in order to better understand the timeliness and reliability of the information.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\sandwiched-swaps.md"}}],["50",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\flashbots\\sandwiches.md)\n\n# Sandwiches Table\n\nThe `sandwiches` table is a part of the Dune Docs project and contains detailed information about executed sandwiches. The table has ten columns, each with a specific purpose. \n\n- `created_at`: This column stores the time of the record's creation.\n- `block_number`: This column stores the block number.\n- `backrun_swap_trace_address`: This column stores the address of the swap in the backrun transaction.\n- `backrun_swap_transaction_hash`: This column stores the transaction hash of the backrun transaction of the specified sandwich.\n- `frontrun_swap_trace_address`: This column stores the address of the swap in the frontrun transaction.\n- `frontrun_swap_transaction_hash`: This column stores the transaction hash of the frontrun transaction of the specified sandwich.\n- `id`: This column stores the internal ID of the sandwich.\n- `profit_amount`: This column stores the profit amount after the arbitrage.\n- `profit_token_address`: This column stores the address of the profit asset.\n- `sandwicher_address`: This column stores the address of the sandwicher.\n- `timestamp`: This column stores the timestamp of the latest update of the file.\n\nThis table is useful for analyzing the performance of executed sandwiches and identifying any issues that may arise during the execution process. For example, if a sandwicher consistently experiences low profits, they may need to adjust their strategy or look for new opportunities. \n\nHere is an example of how to query the `sandwiches` table:\n\n```\nSELECT *\nFROM sandwiches\nWHERE sandwicher_address = '0x123abc'\n```\n\nThis query will return all sandwiches executed by the sandwicher with the address `0x123abc`.\n## Questions: \n 1. What is the purpose of the \"sandwiches\" table in the Dune Docs app?\n- The \"sandwiches\" table contains detailed information about executed sandwiches, including block number, transaction hashes, profit amount, and addresses of the sandwicher and profit asset.\n\n2. How is the data in the \"sandwiches\" table updated?\n- The \"timestamp\" column indicates the latest update of the file, but it is unclear how the data in the table is updated or if it is updated automatically.\n\n3. Is there any connection between the Dune Docs app and blockchain technology?\n- The table includes columns for block number and transaction hashes, suggesting that the app may be connected to a blockchain network. However, without further information it is unclear what type of blockchain or how it is being used.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\sandwiches.md"}}],["51",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\community\\flashbots)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\community\\flashbots` folder contains documentation for the Flashbots project, which focuses on Miner Extractable Value (MEV) and its impact on the Ethereum ecosystem. The folder includes guides for various data tables related to MEV strategies, such as arbitrages, liquidations, and sandwiched swaps. These guides are essential for developers and analysts working with Flashbots data and aim to provide a better understanding of the structure and usage of these tables.\n\nFor instance, the `arbitrages.md` guide covers the `flashbots.arbitrages` table, which contains information about arbitrage trades. It explains the purpose of the table, its columns, and provides a query example to retrieve information on arbitrage trades. This guide is useful for developers who need to understand the structure of the table and how to query it effectively.\n\nSimilarly, the `liquidations.md` guide focuses on the `flashbots.liquidations` table, which contains details related to executed liquidations. It provides a query example called \"Liquidations by Protocol\" that demonstrates how to use the table to analyze liquidation data.\n\nThe `mev_summary.md` guide covers the `mev_summary` table, which provides a summary of all classified transactions. This table is crucial for analyzing and understanding the MEV ecosystem. The guide includes a query example called \"Miner Revenue from Liquidations and Arbitrages\" that demonstrates how to use the table to analyze miner revenue.\n\nThe `sandwiched-swaps.md` guide explains the `flashbots.sandwiched_swaps` table, which contains data about sandwiched swaps. It provides query examples for retrieving data from the table using SQL queries. This guide is helpful for developers working with sandwiched swap data in the Dune Docs app.\n\nLastly, the `sandwiches.md` guide covers the `sandwiches` table, which contains detailed information about executed sandwiches. It provides an example of how to query the table to retrieve all sandwiches executed by a specific sandwicher.\n\nOverall, the guides in this folder are essential for developers and analysts working with Flashbots data and aim to provide a better understanding of the structure and usage of the various data tables related to MEV strategies. By following these guides, users can effectively analyze and understand the impact of MEV on the Ethereum ecosystem.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\flashbots\\summary.md"}}],["52",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\index.md)\n\n# Community\n\nThis section of the Dune Docs project contains data that has been submitted and hosted on Dune by third-party data providers. The purpose of this section is to provide off-chain data or augmented on-chain data that may be needed in addition to blockchain data. \n\nThe section is only available on V2 Engine. The guide notes that the infrastructure for this endeavor is still being built, and therefore, the support for more datasets is not available at the moment. \n\nThe section contains two datasets, Flashbots and Reservoir, which are listed as cards in a grid format. The purpose of these datasets is not explained in this guide, but they are linked to their respective index pages where more information about them can be found. \n\nThe guide is short and straightforward, providing a brief overview of the Community section and its purpose. It also notes that the section is only available on V2 Engine and that more datasets will be added in the future. \n\nExample:\n\nIf a user needs off-chain data or augmented on-chain data in addition to blockchain data, they can visit the Community section of the Dune Docs project. They will find two datasets, Flashbots and Reservoir, which they can explore further by clicking on the links to their respective index pages. However, they should note that the section is only available on V2 Engine and that more datasets will be added in the future.\n## Questions: \n 1. What is the V2 Engine mentioned in the note at the beginning of the technical guide?\n- The V2 Engine is required to access the Community section of Dune Docs.\n\n2. What kind of off-chain or augmented on-chain data is provided by the selected organizations mentioned in the guide?\n- The guide does not provide specific information on the type of data provided by the selected organizations.\n\n3. Is there any timeline or plan for when Dune Docs will be able to support more datasets for the Community section?\n- The guide does not provide any information on a timeline or plan for supporting more datasets in the Community section.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\index.md"}}],["53",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\ask-events.md)\n\n# Ask Events\n\nThis section of the app technical guide covers the `reservoir.ask_events` table, which contains records with information about each ask change. The table includes columns such as `id`, `kind`, `contract`, `token_id`, `order_id`, `maker`, `price`, `quantity_remaining`, `valid_from`, `valid_until`, `source`, `tx_hash`, `tx_timestamp`, and `created_at`. \n\nThe `id` column is an internal event ID, while the `kind` column specifies the type of event (e.g. new-order, expiry, sale, cancel, balance-change, approval-change, bootstrap, revalidation, reprice). The `contract` column contains the contract address, and the `token_id` column contains the ID of the token in the collection. The `order_id` column is the associated ask ID, and the `maker` column contains the associated ask maker wallet address. The `price` column contains the associated ask price in native currency, and the `quantity_remaining` column contains the associated ask tokens remaining. The `valid_from` and `valid_until` columns contain the associated ask validity start and expiration, respectively. The `source` column specifies the source of the order (e.g. opensea.io), while the `tx_hash` and `tx_timestamp` columns contain the associated transaction hash and timestamp, respectively. Finally, the `created_at` column contains the timestamp the event was recorded.\n\nThis section also includes links to query examples for the `reservoir.ask_events` table, which can be found at [https://dune.com/queries/1302858/2232178](https://dune.com/queries/1302858/2232178) and [https://dune.com/queries/1302863/2232189](https://dune.com/queries/1302863/2232189).\n\nOverall, this section of the app technical guide provides a detailed overview of the `reservoir.ask_events` table and its various columns, as well as links to query examples for further exploration. It is relevant to the data tables section of the project app.\n## Questions: \n 1. What is the purpose of the `reservoir.ask_events` table in the context of blockchain and SQL analysis?\n- The `reservoir.ask_events` table contains records with information about each ask change, which could be useful for analyzing the behavior of buyers and sellers in a blockchain marketplace.\n\n2. Are there any limitations or constraints on the data that can be queried from this table?\n- The app technical guide does not provide information on any limitations or constraints on the data that can be queried from this table.\n\n3. Are there any other tables or data sources that are related to the `reservoir.ask_events` table and could be used for more comprehensive analysis?\n- The app technical guide does not provide information on any other related tables or data sources, but a blockchain SQL analyst may want to explore other tables or data sources to gain a more comprehensive understanding of the marketplace behavior.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\ask-events.md"}}],["54",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\asks.md)\n\n# Reservoir.asks Table\n\nThe `reservoir.asks` table is a part of the Dune Docs project and contains records with information about each listing. The table has various columns such as `id`, `kind`, `status`, `contract`, `token_id`, `maker`, `taker`, `price`, `start_price`, `end_price`, `currency_address`, `currency_symbol`, `currency_price`, `dynamic`, `quantity`, `quantity_filled`, `quantity_remaining`, `valid_from`, `valid_until`, `nonce`, `source`, `fee_bps`, `expiration`, `raw_data`, `created_at`, and `updated_at`. Each column has a specific data type and description.\n\nThe purpose of this table is to provide information about each listing, including the listing's status, price, quantity, and other relevant details. The table can be queried using various query examples, which are provided in the documentation. \n\nFor example, to query all active listings, one can use the following SQL query:\n\n```\nSELECT * FROM reservoir.asks WHERE status = 'active';\n```\n\nThis will return all records from the `reservoir.asks` table where the `status` column is set to 'active'.\n\nOverall, the `reservoir.asks` table is an essential part of the Dune Docs project, providing valuable information about each listing. The documentation provides a detailed description of each column in the table, along with query examples to help users retrieve the data they need.\n## Questions: \n 1. What is the purpose of the `reservoir.asks` table in the Dune Docs app?\n- The `reservoir.asks` table contains records with information about each listing in the app.\n\n2. What type of data is stored in the `price` column of the `reservoir.asks` table?\n- The `price` column in the `reservoir.asks` table stores the current price in native currency.\n\n3. Is there any information in the `reservoir.asks` table about the buyer of a listing?\n- No, there is no information in the `reservoir.asks` table about the buyer of a listing. The table only contains information about the maker and taker wallet addresses.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\asks.md"}}],["55",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\attribute-keys.md)\n\n# Attribute Keys\n\nThis section of the app technical guide covers the `reservoir.attribute_keys` table, which contains records with information about each attribute key. The table has seven columns, including `id`, `collection_id`, `key`, `kind`, `rank`, `created_at`, and `updated_at`. \n\n- `id`: This column contains the internal attribute key id.\n- `collection_id`: This column contains the associated collection id.\n- `key`: This column contains the name of the attribute.\n- `kind`: This column contains the value type, which can be string, number, date, or range.\n- `rank`: This column contains the sort order.\n- `created_at`: This column contains the timestamp the attribute key was created.\n- `updated_at`: This column contains the timestamp the attribute key was updated.\n\nThe purpose of this section is to provide developers with an understanding of the structure and content of the `reservoir.attribute_keys` table. It also includes a link to query examples that can be used to retrieve data from the table.\n\nFor example, if a developer wants to retrieve all the attribute keys associated with a specific collection, they can use the following query:\n\n```\nSELECT *\nFROM reservoir.attribute_keys\nWHERE collection_id = 'collection_id_value';\n```\n\nOverall, this section of the app technical guide is essential for developers who are working with the `reservoir.attribute_keys` table and need to understand its structure and contents.\n## Questions: \n 1. What is the purpose of the `reservoir.attribute_keys` table in the context of the Dune Docs project?\n- The `reservoir.attribute_keys` table contains information about each attribute key in the project, including its name, value type, and sort order.\n\n2. How does the `reservoir.attribute_keys` table relate to blockchain technology?\n- It is unclear from the provided information how the `reservoir.attribute_keys` table specifically relates to blockchain technology.\n\n3. Are there any security considerations or best practices that should be followed when working with the `reservoir.attribute_keys` table?\n- It is unclear from the provided information whether there are any security considerations or best practices that should be followed when working with the `reservoir.attribute_keys` table.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\attribute-keys.md"}}],["56",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\attributes.md)\n\n# Dune Docs App Technical Guide: Attributes\n\n## Reservoir Attributes\n\nThis section of the guide covers the `reservoir.attributes` table, which contains records with information about each attribute. The table includes columns such as `id`, `value`, `token_count`, `on_sale_count`, `floor_sell_value`, `sell_updated_at`, `collection_id`, `kind`, `key`, `created_at`, and `updated_at`. \n\nThe `id` column represents the internal attribute ID, while the `attribute_key_id` column represents the internal attribute key ID. The `value` column contains the attribute value, and the `token_count` column represents the amount of tokens that have the attribute. The `on_sale_count` column represents the amount of tokens that have the attribute and are on sale. The `floor_sell_value` column represents the current floor ask price, and the `sell_updated_at` column represents the timestamp the floor sale was last updated. The `collection_id` column represents the associated collection ID, and the `kind` column represents the value type (string, number, date, range). The `key` column represents the associated key name, and the `created_at` and `updated_at` columns represent the timestamps the attribute was created and updated, respectively.\n\nThis section also provides query examples that can be found at `https://dune.com/queries/1302927/2232298` and `https://dune.com/queries/1302966/2232361`.\n\nOverall, this section of the guide is useful for developers working on the Dune Docs app who need to understand the structure and contents of the `reservoir.attributes` table. It provides a clear overview of the table's columns and their meanings, as well as examples of queries that can be used to retrieve data from the table.\n## Questions: \n 1. What is the purpose of the `reservoir.attributes` table in the context of blockchain? \n- The `reservoir.attributes` table contains information about each attribute, including the associated collection ID and the amount of tokens that have the attribute. \n\n2. How are the `floor_sell_value` and `sell_updated_at` columns relevant to blockchain analysis? \n- The `floor_sell_value` column contains the current floor ask price, which could be useful for analyzing token sales and market trends. The `sell_updated_at` column provides a timestamp for when the floor sale was last updated, which could also be relevant for market analysis. \n\n3. Are there any limitations or considerations to keep in mind when using the query examples provided in the technical guide? \n- The technical guide does not provide any information on limitations or considerations for the query examples, so it may be necessary to test and validate the queries before relying on them for analysis.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\attributes.md"}}],["57",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\bid-events.md)\n\n# Bid Events\n\nThis section of the app technical guide covers the `reservoir.bid_events` table, which contains records with information about each bid change. The table includes various columns such as `id`, `kind`, `status`, `contract`, `token_set_id`, `order_id`, `maker`, `price`, `value`, `quantity_remaining`, `valid_from`, `valid_until`, `source`, `tx_hash`, `tx_timestamp`, and `created_at`. \n\nThe `id` column represents the internal event ID, while the `kind` column represents the type of event, such as `new-order`, `expiry`, `sale`, `cancel`, `balance-change`, `approval-change`, `bootstrap`, `revalidation`, and `reprice`. The `status` column represents the status of the event, which can be either `active` or `expired`. The `contract` column represents the contract address, while the `token_set_id` column represents the ID of the token set. The `order_id` column represents the associated bid ID, while the `maker` column represents the associated bid maker wallet address. The `price` column represents the associated bid price in native currency, while the `value` column represents the associated bid value in native currency. The `quantity_remaining` column represents the associated bid tokens remaining, while the `valid_from` column represents the associated bid validity start. The `valid_until` column represents the associated bid validity expiration, while the `source` column represents the source of the order, such as `opensea.io`. The `tx_hash` column represents the associated transaction hash, while the `tx_timestamp` column represents the associated transaction timestamp. Finally, the `created_at` column represents the timestamp the event was recorded.\n\nThis section also includes a link to query examples, which are currently TBD. The query examples will likely demonstrate how to retrieve specific information from the `reservoir.bid_events` table, such as bids of a certain type or bids associated with a specific contract or token set. Overall, this section of the app technical guide provides a detailed overview of the `reservoir.bid_events` table and its various columns, which will be useful for developers working on the bidding functionality of the Dune Docs app.\n## Questions: \n 1. What is the purpose of the dune docs project and how does it relate to blockchain technology?\n- The app technical guide provided does not give any information about the purpose of the dune docs project or its relation to blockchain technology.\n\n2. How is the data in the bid events table being stored and accessed?\n- The app technical guide does not provide information on how the data in the bid events table is being stored and accessed.\n\n3. Are there any security measures in place to protect the bid events data?\n- The app technical guide does not mention any security measures in place to protect the bid events data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\bid-events.md"}}],["58",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\bids.md)\n\n# Dune Docs App Technical Guide: Bids\n\n## Reservoir.bids\n\nThis section of the guide covers the `reservoir.bids` table, which contains records with information about each bid. The table includes columns such as `id`, `kind`, `status`, `contract`, `maker`, `taker`, `price`, `value`, `currency_address`, `currency_symbol`, `currency_price`, `quantity`, `quantity_filled`, `quantity_remaining`, `valid_from`, `valid_until`, `nonce`, `source`, `fee_bps`, `expiration`, `raw_data`, `created_at`, and `updated_at`. \n\nThe purpose of this section is to provide a detailed description of each column in the `reservoir.bids` table, including the column name, type, and description. For example, the `id` column is a string that represents the internal order id, while the `kind` column is a string that represents the protocol name (e.g. seaport). \n\nAdditionally, this section provides a link to query examples for the `reservoir.bids` table, which can be found at [TBD](TBD). \n\nOverall, this section of the guide is useful for developers who are working with the `reservoir.bids` table and need to understand the purpose and structure of each column. \n\nExample: If a developer needs to retrieve the `maker` and `price` columns from the `reservoir.bids` table, they can use the following SQL query: \n\n```\nSELECT maker, price\nFROM reservoir.bids;\n```\n## Questions: \n 1. What is the purpose of the dune docs app and how does it relate to blockchain technology?\n- The app technical guide only provides information about a specific table called \"reservoir.bids\" and does not give an overview of the entire app. Therefore, a blockchain SQL analyst might have questions about the overall purpose of the app and how it utilizes blockchain technology.\n\n2. How is the data in the \"reservoir.bids\" table being collected and stored?\n- The app technical guide does not provide information on how the data is being collected and stored, which might be important for a blockchain SQL analyst to understand in order to properly analyze the data.\n\n3. Are there any security measures in place to protect the data in the \"reservoir.bids\" table?\n- The app technical guide does not mention any security measures, such as encryption or access controls, which might be a concern for a blockchain SQL analyst working with sensitive data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\bids.md"}}],["59",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\collection-floor-ask-events.md)\n\n# Collection Floor Ask Events\n\nThis section of the app technical guide covers the `reservoir.collection_floor_ask_events` table, which contains records with information about each collection floor ask change. The table has several columns, including `id`, `kind`, `collection_id`, `contract`, `token_id`, `order_id`, `maker`, `price`, `previous_price`, `valid_until`, `source`, `tx_hash`, `tx_timestamp`, and `created_at`. \n\nThe `kind` column specifies the type of event, which can be `new-order`, `expiry`, `sale`, `cancel`, `balance-change`, `approval-change`, `bootstrap`, `revalidation`, or `reprice`. The `collection_id` column contains the ID of the collection, while the `contract` column contains the address of the contract. The `token_id` column contains the ID of the token in the collection, and the `order_id` column contains the ID of the associated ask. The `maker` column contains the wallet address of the associated ask maker, and the `price` column contains the associated ask price in native currency. The `previous_price` column contains the previous floor ask price in native currency, and the `valid_until` column contains the expiration time of the associated ask. The `source` column specifies the source of the order, such as `opensea.io`. The `tx_hash` column contains the associated transaction hash, and the `tx_timestamp` column contains the associated transaction timestamp. The `created_at` column contains the timestamp when the event was recorded.\n\nThe guide also provides two query examples that can be used to retrieve information from the `reservoir.collection_floor_ask_events` table. The first query example can be found at [https://dune.com/queries/1302799/2232083](https://dune.com/queries/1302799/2232083), while the second query example can be found at [https://dune.com/queries/1302841/2232151](https://dune.com/queries/1302841/2232151).\n\nOverall, this section of the app technical guide provides a detailed explanation of the `reservoir.collection_floor_ask_events` table and its columns, as well as query examples that can be used to retrieve information from the table.\n## Questions: \n 1. What is the purpose of the `reservoir.collection_floor_ask_events` table in the context of blockchain and SQL analysis?\n- A blockchain SQL analyst might want to know how this table fits into the overall data schema and what insights it can provide about collection floor ask changes in a blockchain ecosystem.\n\n2. Are there any limitations or constraints to consider when querying this table?\n- A blockchain SQL analyst might want to know if there are any specific query requirements or limitations, such as query speed or data volume, that could impact their analysis.\n\n3. How frequently is this table updated and what is the data retention policy?\n- A blockchain SQL analyst might want to know how frequently new records are added to this table and how long the data is retained, in order to understand the freshness and reliability of the data for their analysis.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\collection-floor-ask-events.md"}}],["60",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\collection-top-bid-events.md)\n\n# Collection Top Bid Events\n\nThis section of the app technical guide covers the `reservoir.collection_top_bid_events` table. This table contains records with information about each collection top bid change. The table has several columns, including `id`, `kind`, `collection_id`, `contract`, `token_id`, `order_id`, `maker`, `price`, `previous_price`, `valid_until`, `source`, `tx_hash`, `tx_timestamp`, and `created_at`. \n\nThe `id` column contains the internal event ID, while the `kind` column specifies the type of event, such as `new-order`, `expiry`, `sale`, `cancel`, `balance-change`, `approval-change`, `bootstrap`, `revalidation`, or `reprice`. The `collection_id` column contains the ID of the collection, and the `contract` column contains the contract address. The `token_id` column contains the ID of the token in the collection, and the `order_id` column contains the associated bid ID. The `maker` column contains the associated bid maker wallet address, and the `price` column contains the associated bid price in native currency. The `previous_price` column contains the previous top bid price in native currency, and the `valid_until` column contains the associated bid validity expiration. The `source` column contains the source of the order, such as `opensea.io`. The `tx_hash` column contains the associated transaction hash, and the `tx_timestamp` column contains the associated transaction timestamp. Finally, the `created_at` column contains the timestamp the event was recorded.\n\nThis section also provides a link to query examples, which are currently TBD. \n\nOverall, this section of the app technical guide provides a detailed overview of the `reservoir.collection_top_bid_events` table and its various columns. It is useful for developers who need to work with this table and understand the information it contains.\n## Questions: \n 1. What is the purpose of the \"reservoir.collection_top_bid_events\" table in the context of blockchain and SQL? \n- The table contains records with information about each collection top bid change, which could be useful for analyzing bidding behavior and trends within a collection.\n\n2. Are there any limitations or constraints on the data types used in the table columns? \n- The table lists the data types for each column, but it does not specify any limitations or constraints on those data types. A blockchain SQL analyst may need to investigate further to determine if there are any restrictions on the data that can be stored in the table.\n\n3. Is there any additional documentation or context available for the \"kind\" column, which lists different event types? \n- The table provides a list of possible values for the \"kind\" column, but it does not explain what each of those event types represents. A blockchain SQL analyst may need to consult other documentation or resources to gain a better understanding of the different event types and their significance.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\collection-top-bid-events.md"}}],["61",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\collections.md)\n\n# Collections\n\nThis section of the app technical guide covers the `reservoir.collections` table, which contains records with information about each NFT collection. The table includes columns such as `id`, `slug`, `name`, `description`, `token_count`, `contract`, `day1_rank`, `day7_rank`, `day30_rank`, `all_time_rank`, `day1_volume`, `day7_volume`, `day30_volume`, `all_time_volume`, `day1_volume_change`, `day7_volume_change`, `day30_volume_change`, `floor_ask_value`, `day1_floor_sale_value`, `day7_floor_sale_value`, `day30_floor_sale_value`, `day1_floor_sale_change`, `day7_floor_sale_change`, `day30_floor_sale_change`, `created_at`, and `updated_at`. \n\nThe purpose of this guide is to provide developers with an understanding of the structure and contents of the `reservoir.collections` table, as well as examples of queries that can be used to retrieve data from the table. The guide includes a detailed description of each column in the table, including the data type and a brief explanation of its purpose. \n\nThe query examples provided in the guide demonstrate how to retrieve specific data from the `reservoir.collections` table using Dune's query language. For example, the first query example retrieves the `id`, `name`, `description`, and `contract` columns for all records in the table. The second query example retrieves the `id`, `name`, `day1_rank`, `day7_rank`, and `day30_rank` columns for all records in the table. \n\nOverall, this section of the app technical guide is essential for developers who need to work with NFT collections in the Dune app. It provides a clear understanding of the structure and contents of the `reservoir.collections` table, as well as examples of queries that can be used to retrieve data from the table.\n## Questions: \n 1. What is the purpose of the dune docs app and how does it relate to blockchain technology?\n   \n   Answer: The app technical guide for dune docs does not provide information on the purpose of the app or its relation to blockchain technology. Further documentation or context would be needed to answer this question.\n\n2. What is the significance of the \"contract\" column in the \"reservoir.collections\" table?\n   \n   Answer: The \"contract\" column in the \"reservoir.collections\" table contains the contract address for each NFT collection. This information could be useful for a blockchain SQL analyst who is interested in tracking NFT collections on a specific blockchain network.\n\n3. How are the \"day1_rank\", \"day7_rank\", \"day30_rank\", and \"all_time_rank\" columns calculated in the \"reservoir.collections\" table?\n   \n   Answer: The app technical guide for dune docs does not provide information on how the \"day1_rank\", \"day7_rank\", \"day30_rank\", and \"all_time_rank\" columns are calculated in the \"reservoir.collections\" table. Further documentation or context would be needed to answer this question.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\collections.md"}}],["62",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\index.md)\n\nThe Reservoir section of the app technical guide covers the Reservoir feature of the Dune Docs project. Reservoir is an open-source, on-chain NFT order aggregation tool that enables the next generation of NFT products and liquidity sources. The guide provides links to the Reservoir dashboard, documentation, and Discord channel for further information and support.\n\nThe Reservoir section of the app technical guide is divided into three subsections: Dashboard, Docs, and Discord. The Dashboard subsection provides a link to the Reservoir dashboard, which is a web-based interface for managing and monitoring Reservoir orders. The Docs subsection provides a link to the Reservoir documentation, which contains detailed information on how to use Reservoir, including installation instructions, API documentation, and examples. The Discord subsection provides a link to the Reservoir Discord channel, which is a community forum for discussing Reservoir and getting help from other users.\n\nOverall, the Reservoir section of the app technical guide is a useful resource for anyone looking to use Reservoir in their NFT project. The guide provides links to all the necessary resources for getting started with Reservoir, including the dashboard, documentation, and community forum. By following the instructions in the guide and using the resources provided, users can easily integrate Reservoir into their NFT project and take advantage of its powerful features.\n## Questions: \n 1. What is the purpose of Reservoir in the context of blockchain technology?\n- Reservoir is enabling the next generation of NFT products and liquidity sources through open-source, on-chain NFT order aggregation.\n\n2. What are the available resources for developers to learn about Reservoir?\n- Developers can access the Reservoir dashboard, documentation, and Discord channel for learning about the app.\n\n3. Is Reservoir built on a blockchain or using SQL technology?\n- The app technical guide does not provide information on whether Reservoir is built on a blockchain or using SQL technology.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\index.md"}}],["63",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\sales.md)\n\n# Sales\n\nThis section of the app technical guide covers the `reservoir.sales` table, which contains records with information about each sale. The table includes various columns such as `id`, `contract`, `token_id`, `order_id`, `order_kind`, `order_side`, `order_source`, `from`, `to`, `price`, `usd_price`, `currency_address`, `currency_symbol`, `currency_price`, `amount`, `fill_source`, `aggregator_source`, `wash_trading_score`, `is_primary`, `tx_hash`, `tx_log_index`, `tx_batch_index`, `tx_timestamp`, `created_at`, and `updated_at`. Each column is described in detail, including its data type and a brief description of its purpose.\n\nThe guide also provides two query examples that can be used to retrieve data from the `reservoir.sales` table. These queries can be accessed via the links provided in the guide.\n\nOverall, this section of the app technical guide is useful for developers who need to work with sales data in the Dune Docs project. It provides a clear understanding of the structure and contents of the `reservoir.sales` table, as well as examples of how to query the data.\n## Questions: \n 1. What is the purpose of the `reservoir.sales` table in the context of blockchain technology? \n- The `reservoir.sales` table contains records with information about each sale, likely related to transactions on a blockchain.\n\n2. How is the `usd_price` column calculated and what currency is it based on? \n- The `usd_price` column represents the sale price in USD, but it is unclear how this value is calculated or what currency exchange rate is used.\n\n3. What is the significance of the `is_primary` column and how does it relate to blockchain technology? \n- The `is_primary` column indicates whether the sale is a paid mint, but it is unclear how this relates to blockchain technology or what a paid mint refers to in this context.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\sales.md"}}],["64",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\community\\reservoir)\n\nThe Reservoir section of the app technical guide focuses on the data tables related to the Reservoir feature of the Dune Docs project. Reservoir is an open-source, on-chain NFT order aggregation tool that enables the next generation of NFT products and liquidity sources. The guide provides detailed explanations of various tables, their columns, and their purposes, as well as query examples for retrieving specific information from these tables.\n\nFor instance, the `reservoir.sales` table contains records with information about each sale, including columns such as `id`, `contract`, `token_id`, `order_id`, and more. The guide provides a clear understanding of the structure and contents of this table, as well as examples of how to query the data. This information is useful for developers who need to work with sales data in the Dune Docs project.\n\nAnother example is the `reservoir.tokens` table, which contains records with information about each NFT token. The guide provides a detailed overview of the table and its columns, such as `id`, `contract`, `token_id`, `name`, `description`, and more. The guide also provides query examples for retrieving information from the table, such as the floor ask value for a particular token.\n\nThe Reservoir section of the app technical guide is essential for developers who need to work with NFT collections, sales, and attributes in the Dune app. It provides a clear understanding of the structure and contents of the various data tables related to the Reservoir feature, as well as examples of queries that can be used to retrieve data from these tables. By following the instructions in the guide and using the resources provided, developers can easily integrate Reservoir into their NFT project and take advantage of its powerful features.\n\nOverall, the Reservoir section of the app technical guide is a valuable resource for anyone looking to use Reservoir in their NFT project. The guide provides links to all the necessary resources for getting started with Reservoir, including the dashboard, documentation, and community forum. By following the instructions in the guide and using the resources provided, users can easily integrate Reservoir into their NFT project and take advantage of its powerful features.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\summary.md"}}],["65",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\token-attributes.md)\n\n# Token Attributes\n\nThis section of the app technical guide covers the `reservoir.token_attributes` table, which contains records with information about each NFT token attribute. The table has several columns, including `id`, `contract`, `token_id`, `attribute_id`, `collection_id`, `key`, `value`, `created_at`, and `updated_at`. \n\nThe `id` column is an internal token attribute ID, while the `contract` column contains the contract address. The `token_id` column contains the ID of the token in the collection, and the `attribute_id` column is an internal attribute ID. The `collection_id` column contains the internal collection ID, while the `key` column contains the attribute name. The `value` column contains the attribute value, and the `created_at` and `updated_at` columns contain timestamps for when the token attribute was created and updated, respectively.\n\nThe guide provides a query example for this table, which can be found at [https://dune.com/queries/1302940/2232326](https://dune.com/queries/1302940/2232326). This query can be used to retrieve information from the `reservoir.token_attributes` table.\n\nOverall, this section of the app technical guide provides information about the `reservoir.token_attributes` table and its columns. It is useful for developers who are working on the app's NFT token attributes functionality.\n## Questions: \n 1. What is the purpose of the dune docs app and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of the dune docs app or its relation to blockchain technology.\n\n2. Can this app be used to query token attributes on any blockchain platform or is it specific to a certain blockchain?\n- The app technical guide does not provide information on whether this app can be used to query token attributes on any blockchain platform or if it is specific to a certain blockchain.\n\n3. Are there any limitations or restrictions on the types of token attributes that can be queried using this app?\n- The app technical guide does not provide information on any limitations or restrictions on the types of token attributes that can be queried using this app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\token-attributes.md"}}],["66",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\token-floor-ask-events.md)\n\n# Token Floor Ask Events\n\nThis section of the app technical guide covers the `reservoir.token_floor_ask_events` table, which contains records with information about each NFT token floor ask change. The table includes columns such as `id`, `kind`, `contract`, `token_id`, `order_id`, `maker`, `price`, `previous_price`, `nonce`, `valid_from`, `valid_until`, `source`, `tx_hash`, `tx_timestamp`, and `created_at`.\n\nThe `id` column represents the internal token attribute id, while the `kind` column represents the event type, such as `new-order`, `expiry`, `sale`, `cancel`, `balance-change`, `approval-change`, `bootstrap`, `revalidation`, or `reprice`. The `contract` column contains the contract address, and the `token_id` column contains the id of the token in the collection. The `order_id` column represents the associated Ask id, and the `maker` column represents the associated Ask maker wallet address. The `price` column contains the associated ask price in native currency, while the `previous_price` column contains the previous ask price in native currency. The `nonce` column represents the order nonce of the maker, and the `valid_from` and `valid_until` columns represent the associated ask validity start and expiration, respectively. The `source` column contains the source of the order, such as `opensea.io`, while the `tx_hash` column contains the associated transaction hash, and the `tx_timestamp` column contains the associated transaction timestamp. Finally, the `created_at` column represents the timestamp the event was recorded.\n\nThis section also includes two query examples that can be found at the specified URLs. These queries can be used to retrieve information from the `reservoir.token_floor_ask_events` table.\n\nOverall, this section of the app technical guide provides a detailed explanation of the `reservoir.token_floor_ask_events` table and its columns, as well as query examples that can be used to retrieve information from the table.\n## Questions: \n 1. What is the purpose of this table in the context of a blockchain application?\n- This table contains records of NFT token floor ask changes, which could be useful for analyzing market trends and pricing behavior.\n\n2. Are there any limitations or constraints on the data stored in this table?\n- The technical guide does not mention any specific limitations or constraints on the data stored in this table, but it may be important to check the underlying database schema for any such restrictions.\n\n3. How frequently is this table updated and what triggers those updates?\n- The technical guide does not provide information on the frequency or triggers for updates to this table, which could be important for understanding the timeliness and accuracy of the data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\token-floor-ask-events.md"}}],["67",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\community\\reservoir\\tokens.md)\n\n# Tokens\n\nThis section of the app technical guide covers the `reservoir.tokens` table, which contains records with information about each NFT token. The table includes columns such as `id`, `contract`, `token_id`, `name`, `description`, `collection_id`, `owner`, `floor_ask_id`, `floor_ask_value`, `floor_ask_maker`, `floor_ask_valid_from`, `floor_ask_valid_to`, `floor_ask_source`, `last_sale_value`, `last_sale_timestamp`, `created_at`, and `updated_at`. \n\nThe `id` column represents the internal token id, while the `contract` column contains the contract address. The `token_id` column represents the id of the token in the collection, and the `name` and `description` columns contain the name and description of the NFT. The `collection_id` column represents the associated collection id, and the `owner` column contains the wallet address of the owner. \n\nThe `floor_ask_id`, `floor_ask_value`, `floor_ask_maker`, `floor_ask_valid_from`, `floor_ask_valid_to`, and `floor_ask_source` columns represent information about the floor ask, such as the id, value, maker wallet address, listing start and end times, and source. The `last_sale_value` and `last_sale_timestamp` columns represent the associated transaction timestamp. Finally, the `created_at` and `updated_at` columns contain timestamps for when the token was created and updated, respectively.\n\nThe guide also provides query examples for the `reservoir.tokens` table, which can be found at the links provided. These examples can be used to retrieve specific information from the table, such as the floor ask value for a particular token.\n\nOverall, this section of the app technical guide provides a detailed overview of the `reservoir.tokens` table and its columns, as well as query examples for retrieving information from the table.\n## Questions: \n 1. What is the purpose of the dune docs app and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of the dune docs app or its relation to blockchain technology.\n\n2. Can the reservoir.tokens table be used to track the ownership and transaction history of NFTs on a blockchain?\n- Yes, the reservoir.tokens table contains information about each NFT token, including the owner wallet address and associated transaction timestamps.\n\n3. Are there any limitations or restrictions on the types of NFTs that can be tracked using the reservoir.tokens table?\n- The app technical guide does not provide information on any limitations or restrictions on the types of NFTs that can be tracked using the reservoir.tokens table.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\reservoir\\tokens.md"}}],["68",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\community)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\community` folder contains documentation for the Community section of the Dune Docs project, which focuses on providing off-chain data or augmented on-chain data submitted by third-party data providers. This section is essential for developers and analysts who need additional data beyond blockchain data for their projects. Currently, the Community section is only available on V2 Engine, and more datasets will be added in the future.\n\nThe folder contains two subfolders, `flashbots` and `reservoir`, which provide documentation for the Flashbots and Reservoir datasets, respectively. The Flashbots project deals with Miner Extractable Value (MEV) and its impact on the Ethereum ecosystem. The `flashbots` folder contains guides for various data tables related to MEV strategies, such as arbitrages, liquidations, and sandwiched swaps. These guides help developers and analysts understand the structure and usage of these tables, enabling them to analyze and understand the impact of MEV on the Ethereum ecosystem effectively.\n\nFor example, the `arbitrages.md` guide in the `flashbots` folder covers the `flashbots.arbitrages` table, which contains information about arbitrage trades. Developers can use this guide to understand the table structure and query it effectively.\n\nThe Reservoir dataset focuses on the Reservoir feature of the Dune Docs project, an open-source, on-chain NFT order aggregation tool. The `reservoir` folder provides detailed explanations of various tables, their columns, and their purposes, as well as query examples for retrieving specific information from these tables. This documentation is essential for developers working with NFT collections, sales, and attributes in the Dune app.\n\nFor instance, the `reservoir.sales` table guide provides a clear understanding of the table structure and contents, as well as examples of how to query the data. Developers can use this guide to work with sales data in the Dune Docs project effectively.\n\nIn summary, the `.autodoc\\docs\\json\\docs\\data tables\\community` folder provides essential documentation for developers and analysts who need additional off-chain or augmented on-chain data for their projects. By following the guides in this folder, users can effectively work with the Flashbots and Reservoir datasets, analyze their data, and integrate them into their projects.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\community\\summary.md"}}],["69",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\decoded\\call-tables.md)\n\n# Call Tables\n\nThis technical guide covers how Dune parses all message calls and transactions made to smart contracts in their own tables. The guide explains that smart contracts generally have functions that can be called by either an externally owned account (EOA) or other smart contracts. The tables are named according to the project name, contract name, and function name. \n\nThe guide provides examples of how Dune records transactions in the tables, such as when a Uniswap v3 pool gets created via the Uniswap v3 factory function `createPool`. The guide also explains that for a contract where multiple instances exist, Dune will decode all calls to all instances of this smart contract into one table. \n\nThe guide addresses common misconceptions, such as the fact that web3.js, web3.py, and all other methods of locally calling a `pure`, `read`, or `constant` function do not broadcast or publish anything on the blockchain and are therefore not recorded in Dune. However, if one of these functions is invoked by another smart contract in the context of a transaction, this will be broadcast on the chain and therefore accessible in Dune. \n\nThe guide concludes with further reading resources, including links to articles on the difference between a transaction and a call, Soliditylang.org documentation, and how calldata is encoded. \n\nOverall, this technical guide provides a high-level overview of how Dune records transactions in tables and how to access this data. It is useful for developers who want to understand how Dune works and how to use it to analyze smart contract transactions.\n## Questions: \n 1. What tables are created for smart contract calls and transactions on Dune?\n- On Dune, tables are created for all message calls and transactions made to smart contracts, and they are named according to the contract name and function name.\n\n2. How does Dune handle multiple instances of a smart contract?\n- For a contract with multiple instances, Dune decodes all calls to all instances into one table.\n\n3. What is a common misconception about accessing state data on Dune?\n- Local calls to `pure`, `read`, or `constant` functions using web3.js or web3.py are not recorded on Dune, but if these functions are invoked by another smart contract in the context of a transaction, the message call will be recorded.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\decoded\\call-tables.md"}}],["70",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\decoded\\event-logs.md)\n\nThe Event Logs technical guide explains how smart contracts emit event logs when certain predefined actions are completed. The structure of these logs is predefined by the smart contract developer, and the content is dynamically created during the transaction. The guide highlights the usefulness of logs for monitoring, alerting, and keeping track of what happens inside a smart contract. Logs are also useful for data analysis since they present data that can be analyzed post factum. \n\nThe guide provides a schema for decoding all event logs for smart contracts into tables named accordingly. The schema is different for the V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). The guide uses the Uniswap V3 factory as an example and explains how to look at the event logs of a transaction in Etherscan. The guide also provides the table name where the event will be stored in Dune. \n\nThe guide explains that if there are multiple instances of a contract, all event logs across all instances of the smart contract will be collected in one table. The guide provides an example of how all Uniswap V3 pool swap events on Ethereum are stored in a table. The column `contract_address` indicates which smart contract emitted the event. \n\nThe guide concludes by providing further reading resources on understanding event logs on the Ethereum blockchain. Overall, the guide provides a detailed explanation of event logs and how they are used in the Dune Docs project.\n## Questions: \n 1. What is the format of the tables that will be created for decoding event logs in Dune Docs?\n   \n   The tables for decoding event logs in Dune Docs will be named according to the schema `[projectname_blockchain].[contractName]_evt_[eventName]` for V2 Engine (Spark SQL) and `[projectname].\"[contractName]_evt_[eventName]\"` for V1 Engine (PosgreSQL).\n\n2. How can a blockchain SQL analyst access the event logs of a transaction in Etherscan?\n   \n   A blockchain SQL analyst can access the event logs of a transaction in Etherscan by opening the logs tab of the transaction.\n\n3. How are event logs stored in Dune Docs when there are multiple instances of a contract?\n   \n   When there are multiple instances of a contract, all event logs across all instances of the smart contract are collected in one table, with the `contract_address` column indicating which smart contract emitted the event.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\decoded\\event-logs.md"}}],["71",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\decoded\\index.md)\n\nThe Decoded Tables guide covers the process of decoding smart contract activity into human-readable tables using the ABI (Application Binary Interface) for smart contracts and the interface standard for standardized token smart contracts (ERC20, ERC721, etc.). The guide explains how Dune creates tables for each event and function defined in the smart contract's ABI, and how every event, message call, or transaction made to that contract is decoded and inserted as a row into these tables.\n\nThe guide provides examples of table naming conventions for both V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). It also explains how to identify specific smart contracts using the `contract_address` column and how to check if contracts are already decoded by querying the `[blockchain].contracts` tables.\n\nThe guide includes a section on understanding decoded data, which emphasizes the importance of analyzing events and transactions, and provides tips on how to make sense of the data. It also discusses which tables to use, suggesting that events are generally the easiest and most accessible way to analyze blockchain data, but in some cases, it might be necessary to use transaction and message calls (found in call tables).\n\nFinally, the guide provides example queries to explore decoded contracts, such as seeing all projects with decoded data, and checking for multiple instances of a contract.\n## Questions: \n 1. **How can I check if a specific contract has already been decoded in the Dune database?**\n\n   You can check if a contract has been decoded by querying the `[blockchain].contracts` tables through the Dune database or by using the provided dashboard links for the V2 Engine (Spark SQL) and V1 Engine (PosgreSQL) in the app technical guide.\n\n2. **How long does it take to initially decode a smart contract once it has been submitted?**\n\n   It usually takes about 24 hours to initially decode a smart contract. You can check the status of your contract's decoding process using the \"Is my Contract decoded yet?\" dashboard link provided in the app technical guide.\n\n3. **What is the difference between event tables and call tables in the decoded data?**\n\n   Event tables contain data related to events emitted by smart contracts, while call tables contain data related to transactions and message calls made between smart contracts. In most cases, analyzing events is easier and more accessible, but in some cases, you might need to use call tables for additional information or when events are not emitted.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\decoded\\index.md"}}],["72",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\decoded)\n\nThe Decoded Data Tables folder in the Dune Docs project focuses on providing technical guides for understanding and working with decoded smart contract activity in human-readable tables. These guides are essential for developers and analysts who want to analyze and monitor smart contract transactions and events on the Ethereum blockchain using Dune.\n\nThe folder contains three main guides:\n\n1. **Call Tables**: This guide explains how Dune parses all message calls and transactions made to smart contracts into tables named according to the project name, contract name, and function name. It provides examples of how Dune records transactions, such as when a Uniswap v3 pool gets created via the Uniswap v3 factory function `createPool`. The guide clarifies common misconceptions and highlights that only transactions broadcasted on the blockchain are recorded in Dune. This guide is useful for developers who want to understand how Dune works and how to use it to analyze smart contract transactions.\n\n2. **Event Logs**: This guide focuses on how smart contracts emit event logs when certain predefined actions are completed. It explains the schema for decoding all event logs for smart contracts into tables and provides examples using the Uniswap V3 factory. The guide also covers how event logs across multiple instances of a smart contract are collected in one table. This guide is essential for developers and analysts who want to monitor, alert, and keep track of what happens inside a smart contract, as well as analyze the data post factum.\n\n3. **Decoded Tables**: This guide covers the process of decoding smart contract activity into human-readable tables using the ABI and the interface standard for standardized token smart contracts. It explains how Dune creates tables for each event and function defined in the smart contract's ABI and provides examples of table naming conventions. The guide also includes a section on understanding decoded data and provides example queries to explore decoded contracts. This guide is crucial for analysts who want to make sense of the data and decide which tables to use for their analysis.\n\nOverall, the Decoded Data Tables folder in the Dune Docs project provides comprehensive guides for understanding and working with decoded smart contract activity in human-readable tables. These guides are essential for developers and analysts who want to analyze and monitor smart contract transactions and events on the Ethereum blockchain using Dune.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\decoded\\summary.md"}}],["73",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\index.md)\n\n# Tables and Chains Overview\n\nThis technical guide provides an overview of the tables and chains available in the Dune Analytics platform. The guide is divided into two main sections: the four kinds of tables and available chains. \n\nThe first section explains the process of ingesting data from node providers to create raw tables, which are then decoded using contract ABIs to provide easier to work with decoded tables. The abstracted tables are then created to standardize and aggregate the data from all other tables, giving users the easiest to work with spell tables. The community providers like Reservoir and Flashbots are also explained, which can be thought of as spell level abstractions. \n\nThe second section provides a list of available chains that can be queried in Dune Analytics. Each chain is explained in detail, including Ethereum, Gnosis Chain, Polygon POS, Optimism, BNB Chain, Arbitrum, Avalanche (C-Chain), Ethereum's Goerli Testnet, Fantom, Solana, and Bitcoin. \n\nThe guide also includes links to relevant documentation for each chain, such as Ethereum.org for Ethereum, and the Binance Smart Chain documentation for BNB Chain. Additionally, the guide provides a brief history of Ethereum and its updates, as well as a deep dive into Optimism's Layer 2 Optimistic Rollup network. \n\nThe guide also includes a suggestion to look in spellbook and community datasets first, and then if users can't find what they want, they can try decoded and raw tables. \n\nOverall, this technical guide provides a comprehensive overview of the tables and chains available in Dune Analytics, making it easier for users to navigate and query the platform. \n\nExample: \n\nIf a user wants to query data from the Ethereum Mainnet, they can read the section on Ethereum, which explains the history of Ethereum, its updates, and provides a link to Ethereum.org for further documentation. The guide also explains that querying on Dune works exactly the same as querying on Ethereum Mainnet.\n## Questions: \n 1. What kind of data is included in the raw and decoded tables for each chain?\n- The raw tables contain unedited, raw, and encoded blockchain data, while the decoded tables provide decoded calls and events made to smart contracts.\n\n2. How does querying data from Gnosis Chain (xDai) differ from querying data from Ethereum Mainnet?\n- Gnosis Chain follows all standards and upgrades of Ethereum Mainnet, so querying on Dune works exactly the same.\n\n3. What is the difference between Solana and EVM chains in terms of data?\n- Solana is a non-EVM blockchain that employs a \"proof of history\" mechanism, so its data is quite different from EVM chains.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\index.md"}}],["74",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\bitcoin\\blocks.md)\n\n# Blocks\n\nThis section of the app technical guide covers the `bitcoin.blocks` feature of the project. It provides a detailed description of the columns in the `bitcoin.blocks` table, which contains information about each block in the Bitcoin blockchain. \n\nEach column name is listed along with its corresponding data type and a description of what the column represents. For example, the `time` column represents the time at which the block was mined, while the `height` column represents the block number. \n\nThe guide also includes information about the various rewards associated with mining a block, such as the `mint_reward` and `total_reward`. Additionally, it provides details about the size of the block, the number of transactions it contains, and the difficulty of mining the block. \n\nOverall, this section of the guide is useful for developers who are working with Bitcoin data and need to understand the structure of the `bitcoin.blocks` table. \n\nExample: If a developer wants to retrieve information about the size of a particular block, they can query the `size` column in the `bitcoin.blocks` table.\n## Questions: \n 1. What is the purpose of the `bitcoin.blocks` table in the Dune Docs app? \n- The `bitcoin.blocks` table in the Dune Docs app contains information about Bitcoin blocks, including their time, height, hash, transaction count, size, and various rewards.\n\n2. How does the app handle updates to the `bitcoin.blocks` table? \n- The app technical guide does not provide information on how updates to the `bitcoin.blocks` table are handled.\n\n3. Can the app be used to analyze blocks from other cryptocurrencies besides Bitcoin? \n- The app technical guide does not provide information on whether the app can be used to analyze blocks from other cryptocurrencies besides Bitcoin.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\blocks.md"}}],["75",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\bitcoin\\index.md)\n\n# App Technical Guide: Bitcoin\n\nThis guide provides information on how to work with Bitcoin data in the Dune Docs project. As a non-EVM chain, Bitcoin's raw data looks different from other chains, and this guide aims to help users understand and work with this data.\n\nThe guide starts with a brief introduction to Bitcoin and provides a link to a full written guide on getting started. This is useful for users who are new to Bitcoin and want to learn more about it.\n\nThe main section of the guide is \"Data Available,\" which lists the different types of Bitcoin data that are available in the Dune Docs project. These include blocks, transactions, outputs, and inputs. Each of these data types has its own page, which provides more detailed information on how to work with that specific type of data.\n\nFor example, the \"Blocks\" page provides information on how to access and analyze Bitcoin block data, while the \"Transactions\" page provides information on how to work with Bitcoin transaction data. The \"Outputs\" and \"Inputs\" pages provide information on how to work with Bitcoin output and input data, respectively.\n\nOverall, this guide is a useful resource for anyone who wants to work with Bitcoin data in the Dune Docs project. It provides an overview of the different types of data available and links to more detailed information on each type.\n## Questions: \n 1. What type of data is available for analysis in this app?\n- The app provides data on blocks, transactions, outputs, and inputs for Bitcoin.\n\n2. Is this app compatible with Ethereum Virtual Machine (EVM) chains?\n- No, this app is specifically designed for non-EVM chains like Bitcoin.\n\n3. Are there any additional resources available for getting started with analyzing Bitcoin data?\n- Yes, the app provides a link to a full written guide on getting started with analyzing Bitcoin data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\index.md"}}],["76",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\bitcoin\\inputs.md)\n\nThe Inputs section of the app technical guide for the Dune Docs project provides a detailed description of the `bitcoin.inputs` table. This table contains information related to the inputs of Bitcoin transactions, including block time, block date, block height, index, transaction ID, spent block height, spent transaction ID, spent output number, value, address, type, coinbase, script ASM, script HEX, script description, script signature ASM, script signature HEX, sequence, and witness data. \n\nThe guide provides a table that lists each column name, data type, and a brief description of what the column represents. For example, the `block_time` column represents the time at which the block containing the input was mined, while the `value` column represents the number of Satoshis attached to the input. \n\nThe guide also provides additional information about certain columns, such as the `sequence` column, which is intended to allow unconfirmed time-locked transactions to be updated before being finalized. The guide notes that this column is not currently used except to disable locktime in a transaction. \n\nOverall, this section of the app technical guide provides developers with a comprehensive understanding of the `bitcoin.inputs` table and the information it contains. By providing detailed descriptions of each column, developers can more easily work with this data and integrate it into their applications.\n## Questions: \n 1. What is the purpose of this app and how does it relate to blockchain technology?\n- The app is not clearly described in this technical guide, so a blockchain SQL analyst might want to know more about its intended use and how it interacts with blockchain data.\n\n2. Are there any limitations or known issues with the data being collected in the `bitcoin.inputs` table?\n- The technical guide does not provide information on data quality or potential issues with the input data, so an analyst might want to investigate this further before using the data for analysis.\n\n3. Is there any additional documentation or support available for using this app and its associated data tables?\n- The technical guide only provides information on the `bitcoin.inputs` table, so an analyst might want to know if there are other tables or resources available for understanding the app and its data.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\inputs.md"}}],["77",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\bitcoin\\outputs.md)\n\nThe app technical guide provides documentation for the `dune docs` project, specifically focusing on the `Outputs` feature of the app. The guide contains a table with detailed information on the `bitcoin.outputs` data table, which includes column names, data types, and descriptions of each column. \n\nThe `block_time` column provides the timestamp of the block, while the `block_date` column provides the date of the block. The `block_height` column provides the block number, and the `block_hash` column provides the hash of the block. The `tx_id` column provides the hash of the transaction that the output is from, and the `index` column provides the 0-indexed number of the output within the transaction. \n\nThe `value` column provides the number of Satoshis attached to the output, while the `script_asm` column provides a symbolic representation of the bitcoin's script language op-codes. The `script_hex` column provides a hexadecimal representation of the bitcoin's script language op-codes. The `address` column provides the address that owns the output, and the `type` column provides the address type of the output. \n\nThis guide is useful for developers who are working on the `Outputs` feature of the `dune docs` app. It provides a clear understanding of the data table and its columns, which can be used to build queries and analyze data. For example, a developer could use this guide to understand how to retrieve the block time and date of a specific output, or how to identify the address type of an output. \n\nOverall, the app technical guide provides a comprehensive overview of the `Outputs` feature of the `dune docs` app, making it easier for developers to work with the data and build new features.\n## Questions: \n 1. What data source does this app technical guide pull from to generate the `bitcoin.outputs` table?\n- This information is not provided in the app technical guide and would require further investigation or documentation.\n\n2. Can this app technical guide be used to analyze outputs from other cryptocurrencies besides Bitcoin?\n- No, this app technical guide is specifically for analyzing Bitcoin outputs and does not provide information on other cryptocurrencies.\n\n3. Is there any information provided in this app technical guide about the inputs that correspond to each output in the `bitcoin.outputs` table?\n- No, this app technical guide only provides information on the outputs themselves and does not include any information on the corresponding inputs.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\outputs.md"}}],["78",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\raw\\bitcoin)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\raw\\bitcoin` folder contains a comprehensive app technical guide for working with Bitcoin data in the Dune Docs project. The guide is divided into several sections, each focusing on a specific aspect of Bitcoin data, such as blocks, transactions, inputs, and outputs.\n\nThe `blocks.md` file provides a detailed description of the `bitcoin.blocks` table, which contains information about each block in the Bitcoin blockchain. This section is useful for developers who need to understand the structure of the `bitcoin.blocks` table and retrieve information about specific blocks, such as their size or the number of transactions they contain.\n\nThe `index.md` file serves as an introduction to the app technical guide, providing an overview of the different types of Bitcoin data available in the Dune Docs project. This file is a useful starting point for users who are new to Bitcoin and want to learn more about the data types and how to work with them.\n\nThe `inputs.md` file focuses on the `bitcoin.inputs` table, which contains information related to the inputs of Bitcoin transactions. This section is valuable for developers who need to understand the structure of the `bitcoin.inputs` table and work with input data, such as the value of an input or the block time of the block containing the input.\n\nThe `outputs.md` file provides a detailed guide on the `bitcoin.outputs` data table, which includes information about the outputs of Bitcoin transactions. This section is helpful for developers working with output data, such as retrieving the block time and date of a specific output or identifying the address type of an output.\n\nFinally, the `transactions.md` file offers a comprehensive overview of the `bitcoin.transactions` feature, including the various columns and structures that make up the transaction table. This guide is a valuable resource for developers working with transaction data, such as analyzing transaction fees or working with nested hierarchical data in the input and output columns.\n\nOverall, the app technical guide in this folder is an essential resource for developers and analysts working with Bitcoin data in the Dune Docs project. It provides a clear understanding of the different data types and structures, making it easier to build queries, analyze data, and integrate the information into various applications.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\summary.md"}}],["79",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\bitcoin\\transactions.md)\n\nThe Transactions section of the Dune Docs project provides a detailed guide on the `bitcoin.transactions` feature. This guide covers the various columns that make up the transaction table, including their data types and descriptions. The table columns include block time, block date, block height, block hash, index, ID, input value, output value, fee, input count, output count, size, virtual size, is coinbase, coinbase, input, output, lock time, and hex. \n\nThe guide also provides definitions for the various structures within the input and output columns. The input structure includes fields such as value, height, tx_id, output_number, coinbase, sequence, witness_data, script_signature, and script_pub_key. The output structure includes fields such as index, value, and script_pub_key. \n\nThe guide explains that the STRUCT data type allows for representing nested hierarchical data and has key-value pairs. It is similar to a dictionary in Python and can be used to group fields together to make them more accessible. The guide also provides examples of how to work with these columns using syntax such as `input[1].witness_data[2]` or `input[3].script_pub_key.address`. \n\nOverall, this guide provides a comprehensive overview of the `bitcoin.transactions` feature, including the various columns and structures that make up the transaction table. It is a valuable resource for developers working with this feature in the Dune Docs project.\n## Questions: \n 1. What is the source of the data in the `bitcoin.transactions` table?\n- The app technical guide does not provide information on the source of the data in the `bitcoin.transactions` table.\n\n2. Can the `input` and `output` fields be joined to other tables in the database?\n- The app technical guide does not provide information on whether the `input` and `output` fields can be joined to other tables in the database.\n\n3. Is there any information on the frequency of updates to the data in the `bitcoin.transactions` table?\n- The app technical guide does not provide information on the frequency of updates to the data in the `bitcoin.transactions` table.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\bitcoin\\transactions.md"}}],["80",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\blocks.md)\n\n# Blocks\n\nThis section of the app technical guide covers the concept of blocks in blockchains and rollups. A block is a collection of transactions that incrementally alter the state of an EVM system. Transactions within a block can only be executed one after the other, not in parallel. \n\nThe guide provides tables that are useful for identifying block activity and transaction changes over time. These tables are divided into two sections: V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). Each table contains information about different chains, such as Ethereum Mainnet, Gnosis Chain, Polygon, Optimism, BNB Chain, Arbitrum, and Avalanche C-Chain. The tables also provide notes on what information is not included in each chain. \n\nThe guide also includes a section on column data, which provides a description of each column in the tables. The columns include `time`, `number`, `hash`, `parent hash`, `gas_limit`, `gas_used`, `miner`, `difficulty`, `total_difficulty`, `nonce`, `size`, and `base_fee_per_gas`. Each column has a data type and a description of what it represents. \n\nThe guide provides an example of the column data in the form of a video. The video shows how to use the tables to identify block activity and transaction changes over time. \n\nOverall, this section of the app technical guide provides a comprehensive overview of blocks in blockchains and rollups. It also provides useful tables and column data that can be used to analyze block activity and transaction changes over time.\n## Questions: \n 1. What is the purpose of the Dune Docs app in relation to blockchain SQL analysis?\n- The app technical guide provides information on tables and column data that can be used for identifying block activity and transaction changes over time in various chains.\n\n2. What is the difference between the V2 Engine (Spark SQL) and V1 Engine (PosgreSQL) tables?\n- The V2 Engine tables contain more chains and additional columns such as `miner`, `nonce`, and `base_fee_per_gas`, while the V1 Engine tables have fewer chains and do not contain `nonce` or `base_fee_per_gas`.\n\n3. How can the Dune Docs app be used to analyze blockchains and rollups?\n- The app provides tables and column data that can be queried using Spark SQL or PostgreSQL to analyze block activity and transaction changes over time in various chains.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\blocks.md"}}],["81",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\event-logs.md)\n\n# Event Logs\n\nThis technical guide covers the `Event Logs` tables in the Dune Docs project. These tables store all logs data that gets generated by smart contracts. The purpose of this guide is to provide an understanding of how event logs work and how they can be useful for querying contracts that are not yet decoded or are not able to be decoded since the code of the smart contract is not public.\n\nThe guide explains that logs are an elegant way to store tiny amounts of data on EVM blockchains for a small amount of gas. Specifically, event logs are useful to let other people know something has happened without them having to query contracts individually. The guide also provides a link to an article for more information on this topic.\n\nThe guide then provides two tables that show the different chains and tables that are available in the Dune Docs project. The first table shows the V2 Engine (Spark SQL) and the second table shows the V1 Engine (PosgreSQL). Each table lists the chain, table, and any notes that may be relevant.\n\nFinally, the guide provides a detailed description of the column data that is available in the Event Logs tables. The description includes the column name, data type, and a brief explanation of what the column represents. An example is also provided to help users understand how the data is structured.\n\nOverall, this technical guide provides a comprehensive overview of the Event Logs tables in the Dune Docs project. It explains how event logs work, how they can be useful, and provides detailed information on the available data.\n## Questions: \n 1. What is the purpose of the Event Logs tables in this app and how are they useful for blockchain analysis?\n   \n   The Event Logs tables store all logs data generated by smart contracts and are useful for querying contracts that are not yet decoded or are not able to be decoded since the code of the smart contract is not public. They are also useful for letting other people know something has happened without them having to query contracts individually.\n\n2. What engines are used for this app and what are the differences between them?\n   \n   The app uses two engines: V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). The main difference between them is the type of SQL used: Spark SQL for V2 and PostgreSQL for V1.\n\n3. What kind of data is stored in the Event Logs tables and what are some examples of the columns?\n   \n   The Event Logs tables store data such as the contract address, keccak256 hash of a flattened event declaration string, indexed topics of the event, unindexed data containing further information on the event, transaction hash, block hash, block number, block time, and index position of the log and transaction in the block. An example of the columns can be found in the table under the \"Column Data\" section of the app technical guide.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\event-logs.md"}}],["82",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\index.md)\n\n# Raw Tables\n\nThe Raw Tables section of the Dune Docs project provides raw, unfiltered, and unedited data for querying transactions, blocks, event logs, or traces across the blockchains that Dune supports. This section is useful for obtaining meta information about the blockchain, a transaction, traces, or certain events. However, queries written using raw data tables can be difficult to understand and audit due to the nature of the encoded data commonly found in these tables. Additionally, raw data tables have a large number of rows, which can make querying slow. Therefore, it is often better to submit contracts for decoding and work with decoded data.\n\nThe EVM Raw Table Data section focuses on Ethereum Virtual Machine (EVM), which powers all chains in Dune except Solana and Bitcoin. This section includes the following subtopics:\n\n- Blocks: Blocks are the building blocks of blockchains and rollups.\n- Event Logs: Event Logs are data generated by smart contracts.\n- Traces: Traces contain information about the execution of smaller atomic actions generated by transactions.\n- Transactions: Transactions are cryptographically signed instructions from accounts.\n\nEach subtopic provides detailed information on how to query the specific data type. For example, the Blocks subtopic explains how to query block data, including block number, timestamp, and miner address. The Event Logs subtopic explains how to query event logs, including the event name, contract address, and event parameters.\n\nOverall, the Raw Tables section of the Dune Docs project provides a comprehensive guide for querying raw data tables and understanding the encoded data commonly found in these tables. It also provides guidance on when it is better to work with decoded data and how to query specific data types within the EVM Raw Table Data section.\n## Questions: \n 1. What types of blockchain data can be queried using raw tables in Dune Docs?\n- Raw tables in Dune Docs allow for querying of any transaction, block, event log, or trace across the blockchains that Dune supports.\n\n2. What are some challenges associated with querying raw data tables?\n- Queries written using raw data tables can be difficult to understand and audit due to the encoded data commonly found in these tables. Additionally, raw data tables have a large number of rows and can be slow to query.\n\n3. Which blockchains in Dune Docs are powered by the Ethereum Virtual Machine (EVM)?\n- All chains in Dune Docs except for Solana and Bitcoin are powered by the Ethereum Virtual Machine (EVM).","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\index.md"}}],["83",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\account-activity.md)\n\n# Account Activity\n\nThis technical guide covers the `Solana.account_activity` table, which contains information from the transactions table focused on account usage. Each row contains all information about an account's usage in a transaction. The purpose of this guide is to provide a detailed description of the columns in the `Solana.account_activity` table and their corresponding data types.\n\nThe table contains the following columns:\n\n- `block_slot`: a `bigint` representing the slot of the block this transaction was in.\n- `block_hash`: a `string` representing the hash of the block this transaction was in.\n- `block_time`: a `timestamp` representing the timestamp that this account usage occurred.\n- `block_date`: a `date` representing the date this account usage occurred.\n- `address`: a `string` representing the address of the account, also referred to as public key.\n- `tx_index`: an `int` representing the index of this transaction in the block.\n- `tx_id`: a `string` representing the ID of the transaction in which this account usage occurred.\n- `tx_success`: a `boolean` representing whether the transaction succeeded and was committed.\n- `signed`: a `boolean` representing whether this account signed this transaction.\n- `writeable`: a `boolean` representing whether this account was granted read-write access in this transaction.\n- `pre_balance`: a `bigint` representing the balance of this account before the transaction was processed.\n- `pre_token_balance`: a `decimal` representing the token balance before the transaction was processed.\n- `post_balance`: a `bigint` representing the balance of this account after the transaction was processed.\n- `post_token_balance`: a `decimal` representing the token balance after the transaction was processed.\n- `balance_change`: a `bigint` representing the balance change that occurred as part of the transaction.\n- `token_balance_change`: a `decimal` representing the balance change that occurred as part of the transaction.\n- `token_mint_address`: a `string` representing the address the associated token address is minting from (i.e. the actual token address).\n- `token_owner_address`: a `string` representing the address that owns this token address.\n\nThis guide provides a clear understanding of the `Solana.account_activity` table and its columns. For example, if a developer wants to retrieve information about an account's usage in a transaction, they can use this table to get all the necessary information.\n## Questions: \n 1. What blockchain platform is this app technical guide for?\n- The app technical guide is for the Solana blockchain platform.\n\n2. What specific account information is included in the table?\n- The table contains information about an account's usage in a transaction, including its address, pre- and post-transaction balances, and token balances.\n\n3. What is the purpose of the token\\_mint\\_address and token\\_owner\\_address columns?\n- The token\\_mint\\_address column indicates the address from which the associated token is being minted, while the token\\_owner\\_address column indicates the address that owns the token address.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\account-activity.md"}}],["84",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\blocks.md)\n\n# Blocks\n\nThis section of the app technical guide focuses on the `Solana.blocks` table, which contains block data within Solana's blockchain. The purpose of this table is to identify block activity and transaction changes over time. The table includes several columns such as `hash`, `height`, `slot`, `time`, `date`, `parent_slot`, `previous_block___hash`, `total_transactions`, `successful_transactions`, and `failed_transactions`. Each column is described in detail, including the data type and a brief explanation of what it represents.\n\nFor example, the `hash` column is a string that represents the hash of the block, base-58 encoded. The `height` column is a bigint that represents the number of blocks beneath this block. The `time` column is a timestamp that represents the estimated time this block was produced. The `total_transactions` column is a bigint that represents the total number of transactions in this block, while the `successful_transactions` and `failed_transactions` columns represent the number of successful and failed transactions in this block, respectively.\n\nThe guide also includes a video that provides an overview of the `Solana.blocks` table. Additionally, there are two Solana Query examples provided: `Solana blocks over time` and `Transactions per day`. These examples demonstrate how to use the `Solana.blocks` table to analyze block activity and transaction changes over time.\n\nOverall, this section of the app technical guide provides a comprehensive overview of the `Solana.blocks` table and its columns. It also includes examples of how to use the table to analyze block activity and transaction changes over time.\n## Questions: \n 1. What is the purpose of the Solana.blocks table in the Dune Docs app?\n- The Solana.blocks table contains block data within Solana's blockchain and can be used to identify block activity and transaction changes over time.\n\n2. What data types are used in the Solana.blocks table?\n- The Solana.blocks table uses data types such as string, bigint, timestamp, and date.\n\n3. Are there any sample queries available for analyzing Solana.blocks data in the Dune Docs app?\n- Yes, there are sample queries available for analyzing Solana.blocks data in the Dune Docs app, such as Solana blocks over time and Transactions per day.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\blocks.md"}}],["85",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\index.md)\n\n# Solana Technical Guide\n\nThis technical guide provides information on Solana's raw data and how it differs from other chains. It also provides details on the data available in the app and the changelog of the app.\n\n## Data Available\n\nThis section provides a list of the data available in the app. It includes the following:\n\n- Account Activity: This table contains information from the transactions table focused on account usage.\n- Blocks: Blocks are the building blocks of blockchains and rollups.\n- Rewards: This table contains data about rewards paid out on Solana.\n- Transactions: Transactions are cryptographically signed instructions from accounts.\n- Vote Transactions: This table contains the full set of vote transactions that are submitted by validators to vote on a block.\n\n## Changelog\n\nThis section provides a list of changes made to the app. It includes the following:\n\n### 2022-03-25\n\nThe `solana.account_activity` table has been updated to a new version. The new version of the table contains additional information around token activity. The following columns were added to the table:\n\n- `pre_token_balances`: The token balance before the transaction was processed.\n- `post_token_balances`: The token balance after the transaction was processed.\n- `token_balance_changes`: The balance change that occurred as part of the transaction.\n\n### 2022-03-18\n\nThe `solana.account_activity` table has been released. It contains all of the information about an account‚Äôs usage in a transaction. The table is optimized to run with ‚ÄòWHERE address = ‚Ä¶‚Äô queries.\n\n### 2022-03-01\n\nThe `solana.transactions` table has been upgraded to a new version. The new version of the table uses cleaner array structs to make it easier to extract useful information. The vote transactions have also been split into their own table `solana.vote_transactions`, so queries using `solana.transactions` will have better performance. \n\nThis section also provides information on what the changes mean for existing queries using `solana.transactions`. It includes the following:\n\n- You won't need to check if a transaction is a vote transaction.\n- The `error_index` and `error_message` columns have been removed and merged into the `error` column.\n- Structs containing indexes to `account_keys` now include the account address directly.\n- The `pre_token_balances` and `post_token_balances` columns have changed.\n- The `instructions` column has changed.\n- The `inner_instructions` column is removed, and inner instructions have been moved into the `instructions` column.\n\nOverall, this technical guide provides a comprehensive overview of Solana's raw data and the data available in the app. It also provides information on the changes made to the app and what they mean for existing queries.\n## Questions: \n 1. What is Solana and how does it differ from other chains?\n- Solana is a non-EVM chain and its raw data looks different from other chains.\n\n2. What data is available in this app and what information does it provide?\n- The app provides information on account activity, blocks, rewards, transactions, and vote transactions.\n\n3. What changes were made to the `solana.transactions` table and how might it affect existing queries?\n- The `solana.transactions` table has been upgraded to a new version, with cleaner array structs and better performance for queries. However, some existing queries may break due to changes in column names and structures.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\index.md"}}],["86",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\rewards.md)\n\n# Rewards\n\nThis section of the app technical guide covers the `Solana.rewards` table, which contains data about rewards paid out on Solana. Each row in the table corresponds to one reward, and one block may contain zero or more rewards. The table has several columns, including `block_slot`, which indicates the block's slot index in the ledger, `block_hash`, which is the hash of the block, `block_time`, which is the estimated time the block was produced, and `block_date`, which is the date of the event. Other columns include `commission`, which indicates the vote account commission when the reward was credited (only present for voting and staking rewards), `lamports`, which is the number of reward lamports credited or debited by the account, `pre_balance`, which is the account balance in lamports before the reward was applied, `post_balance`, which is the account balance in lamports after the reward was applied, `recipient`, which is the public key of the account that received the reward, and `reward_type`, which indicates the type of reward (e.g., \"fee\", \"rent\", \"voting\", \"staking\").\n\nAn example query for this table is provided in the guide, which can be found at [Solana rewards fee per day](https://dune.xyz/queries/391421/747012). This query likely retrieves data from the `Solana.rewards` table to calculate the daily rewards paid out on Solana.\n\nOverall, this section of the app technical guide provides information on the `Solana.rewards` table and its columns, which is useful for developers working on the rewards feature of the app.\n## Questions: \n 1. What is the purpose of the Solana.rewards table?\n    \n    The Solana.rewards table contains data about rewards paid out on Solana, with each row corresponding to one reward.\n\n2. What information does the commission column provide and when is it present?\n    \n    The commission column provides the vote account commission when the reward was credited, and it is only present for voting and staking rewards.\n\n3. What are the different types of rewards listed in the reward_type column?\n    \n    The different types of rewards listed in the reward_type column are \"fee\", \"rent\", \"voting\", and \"staking\".","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\rewards.md"}}],["87",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\raw\\solana)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\raw\\solana` folder contains a comprehensive technical guide for various Solana data tables, which are essential for developers and analysts working with Solana blockchain data. These guides provide detailed information on the structure, columns, and data types of the tables, as well as examples of how to use them in queries and analysis.\n\nFor instance, the `account-activity.md` guide focuses on the `Solana.account_activity` table, which contains information about account usage in transactions. This guide is particularly useful for developers who want to retrieve information about an account's usage in a transaction, as it provides a clear understanding of the table and its columns.\n\nSimilarly, the `blocks.md` guide covers the `Solana.blocks` table, which contains block data within Solana's blockchain. This guide is essential for analyzing block activity and transaction changes over time. It also includes examples of Solana Query, such as `Solana blocks over time` and `Transactions per day`, demonstrating how to use the `Solana.blocks` table effectively.\n\nThe `rewards.md` guide focuses on the `Solana.rewards` table, which contains data about rewards paid out on Solana. This guide is useful for developers working on the rewards feature of the app, as it provides information on the table's columns and an example query for calculating daily rewards paid out on Solana.\n\nThe `transactions.md` guide provides a comprehensive overview of the `Solana.transactions` table and the structs used to represent nested hierarchical data. This guide is crucial for developers working with transaction data within Solana's blockchain, as it includes detailed descriptions of each column and struct, as well as query examples that demonstrate how to use the data in the table.\n\nLastly, the `vote-transactions.md` guide covers the `Solana.vote_transactions` table, which contains the full set of vote transactions submitted by validators to vote on a block. This guide is a valuable resource for developers working with Solana transactions and understanding the data contained in this table.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\data tables\\raw\\solana` folder provide a thorough understanding of various Solana data tables and their usage in queries and analysis. These guides are essential for developers and analysts working with Solana blockchain data and contribute significantly to the larger project feature of data tables.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\summary.md"}}],["88",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\transactions.md)\n\n# Transactions\n\nThe Transactions section of the Dune Docs project focuses on the Solana.transactions table, which contains transaction data within Solana's blockchain. This table provides relevant data related to account, protocol, and program activity. The guide provides a detailed description of each column in the table, including the column name, column type, and description. \n\nThe guide also includes query examples that demonstrate how to use the Solana.transactions table to extract data. For example, the guide provides a query that shows the number of Solana instructions by day for DEXes. \n\nThe guide also includes several struct definitions that allow for representing nested hierarchical data and have key-value pairs. These structs can be used to group fields together to make them more accessible. The guide provides a detailed description of each struct, including the field name, data type, and description. \n\nThe token_balance struct, for example, includes the account key of the account that the token balance is provided for, the public key of the token's mint, and the derived amount from the token balance's raw amount and the number of decimals. \n\nThe instructions struct includes an ordered list of accounts to pass to the program, program input data in a base-58 string, and the account key of the program that executed this instruction. \n\nThe inner_instructions struct includes an ordered list of accounts to pass to the program, program input data in a base-58 string, and the account key of the program that executed this instruction. \n\nFinally, the error struct includes the instruction number that failed and the error message. \n\nOverall, the Transactions section of the Dune Docs project provides a comprehensive guide to the Solana.transactions table and the structs used to represent nested hierarchical data. The guide includes detailed descriptions of each column and struct, as well as query examples that demonstrate how to use the data in the table.\n## Questions: \n 1. What data is available in the Solana.transactions table?\n- The Solana.transactions table contains transaction data within Solana's blockchain, including relevant data related to account, protocol, and program activity.\n\n2. What is the purpose of the STRUCT data type in this app?\n- The STRUCT data type allows for representing nested hierarchical data and has key-value pairs, similar to a dictionary in Python. It can be used to group fields together to make them more accessible.\n\n3. Are there any examples of how to extract data from the token_balance field?\n- Yes, there is an example query provided in the app technical guide that shows how to extract the number of Solana instructions by day for DEXes using the token_balance field.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\transactions.md"}}],["89",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\solana\\vote-transactions.md)\n\n# Vote Transactions\n\nThis section of the app technical guide covers the `Solana.vote_transactions` table, which contains the full set of vote transactions that are submitted by validators to vote on a block. This table can be joined with the non-vote transactions table to get a full breakdown of all transactions. The schema of this table is the same as the main transactions table.\n\nThe guide provides a detailed description of each column in the `Solana.vote_transactions` table, including the column name, column type, and description. Some of the key columns include:\n\n- `block_slot`: This column contains the block's slot index in the ledger.\n- `block_time`: This column contains the estimated time the block was produced.\n- `fee`: This column contains the fee charged for the transaction.\n- `success`: This column indicates whether the transaction was valid and committed.\n- `instructions`: This column contains the instructions to execute in order.\n- `signatures`: This column contains a list of base-58 encoded signatures applied to the transaction.\n\nThe guide also provides an example query that demonstrates how to use the `Solana.vote_transactions` table. The query shows how to retrieve Solana transactions from the past 30 days using Dune Analytics.\n\nOverall, this section of the app technical guide provides a comprehensive overview of the `Solana.vote_transactions` table and its columns. It is a useful resource for developers who are working with Solana transactions and need to understand the data contained in this table.\n## Questions: \n 1. What is the purpose of the dune docs app and how does it relate to blockchain technology?\n- The app technical guide provided does not give information on the overall purpose of the dune docs app, so a blockchain SQL analyst may want to know more about how the app relates to blockchain technology and what specific features it offers for blockchain analysis.\n\n2. How does the Solana.vote_transactions table differ from other transaction tables in the app?\n- The app technical guide provides information on the Solana.vote_transactions table, but it does not explain how it differs from other transaction tables in the app. A blockchain SQL analyst may want to know this information in order to better understand how to use the table for analysis.\n\n3. Are there any limitations or known issues with the app's data collection or analysis capabilities?\n- The app technical guide does not provide any information on limitations or known issues with the app's data collection or analysis capabilities. A blockchain SQL analyst may want to know this information in order to assess the reliability and accuracy of the data provided by the app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\solana\\vote-transactions.md"}}],["90",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\raw)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\raw` folder contains a comprehensive app technical guide for working with raw data tables in the Dune Docs project. These guides provide detailed information on the structure, columns, and data types of the tables, as well as examples of how to use them in queries and analysis. The project feature this folder is focused on is the `data tables`.\n\nFor instance, the `blocks.md` guide covers the concept of blocks in blockchains and rollups, providing useful tables and column data that can be used to analyze block activity and transaction changes over time. This guide might be useful for analysts who want to track the growth of a specific blockchain or identify patterns in block activity.\n\nSimilarly, the `event-logs.md` guide focuses on the `Event Logs` tables, which store all logs data generated by smart contracts. This guide is particularly useful for developers who need to query contracts that are not yet decoded or are not able to be decoded since the code of the smart contract is not public.\n\nThe `traces.md` guide provides a comprehensive overview of the Traces feature, which contains information about the execution of smaller atomic actions generated by transactions. This guide might be useful for analysts who want to understand the gas usage of specific transactions or identify the creation of new smart contracts.\n\nLastly, the `transactions.md` guide offers a detailed explanation of transactions in the Ethereum network, including tables and column data. This guide is crucial for developers working with transaction data, as it includes detailed descriptions of each column and examples of how to use the data in the table.\n\nIn addition to the main folder, there are two subfolders: `bitcoin` and `solana`. The `bitcoin` subfolder contains a comprehensive app technical guide for working with Bitcoin data, covering aspects such as blocks, transactions, inputs, and outputs. The `solana` subfolder provides a thorough understanding of various Solana data tables and their usage in queries and analysis.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\data tables\\raw` folder provide a detailed understanding of various raw data tables and their usage in queries and analysis. These guides are essential for developers and analysts working with blockchain data and contribute significantly to the larger project feature of data tables.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\summary.md"}}],["91",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\traces.md)\n\n# Traces\n\nThis technical guide covers the Traces feature of the Dune Docs project. Traces tables contain information about the execution of smaller atomic actions generated by transactions. Transactions can trigger smaller atomic actions that modify the internal state of an Ethereum Virtual Machine. Information about the execution of these actions is logged and can be found stored as an EVM execution trace, or just a trace. \n\nThe guide provides information on the tables and column data of the Traces feature. The tables are divided into two engines: V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). Each table contains information about the traces of different chains, such as Ethereum Mainnet, Gnosis Chain, Polygon, Optimism, BNB Chain, Arbitrum, and Avalanche C-Chain. The column data provides a detailed description of each column in the tables. \n\nThe guide also explains the gas used in `.traces`. The `gas_used` column in the `.traces` tables is a bit hard to understand, so the guide provides pointers on how to understand it. For example, the `gas_used` of a trace will always include the gas consumed by the trace and all its subtraces. \n\nFinally, the guide provides information on creation traces. One type of trace, `create`, is used to create a smart contract then transfer ether to it. The guide provides tables and column data for creation traces. \n\nOverall, this technical guide provides a comprehensive overview of the Traces feature of the Dune Docs project. \n\nExample queries are also provided in the guide. For instance, there is an example query that shows how to arrive at the \"true\" `gas_used` value. Another example query shows how to create a smart contract then transfer ether to it. \n\nNote that this guide is not a part of the Dune Docs project.\n## Questions: \n 1. What is the purpose of the `traces` tables in the different chains listed in the guide?\n- The `traces` tables contain information about the execution of smaller atomic actions generated by transactions in different chains.\n\n2. What is the difference between the `gas` and `gas_used` columns in the `.traces` tables?\n- The `gas` column represents the gas provided with the message call, while the `gas_used` column represents the gas consumed by the transaction in `wei`.\n\n3. What is the purpose of the `creation_traces` tables in the different chains listed in the guide?\n- The `creation_traces` tables contain information about the creation of smart contracts and the transfer of ether to them.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\traces.md"}}],["92",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\raw\\transactions.md)\n\n# Transactions\n\nThis section of the app technical guide covers transactions in the Ethereum network. Transactions are cryptographically signed instructions from accounts that initiate a transaction to update the state of the Ethereum network. Transactions always originate from externally owned accounts, and a smart contract cannot initiate a transaction. Transactions need to be broadcast to the whole network, and any node can broadcast a request for a transaction to be executed on the EVM. After this happens, a miner will execute the transaction and propagate the resulting state change to the rest of the network. \n\nThe section also provides a link to the official Ethereum documentation for more information on transactions.\n\n## Tables\n\nThis section provides a table that lists the different chains and tables that contain transaction data. The tables are divided into two engines: V2 Engine (Spark SQL) and V1 Engine (PosgreSQL). The table lists the chains, tables, and notes for each table. For example, the Ethereum Mainnet chain has a table named `ethereum.transactions`, and the Gnosis Chain has a table named `gnosis.transactions`.\n\n## Column Data\n\nThis section provides a table that lists the different columns and their data types for the transaction data. The table also provides a description of each column. For example, the `block_time` column is of type `_timestamptz_` and represents the time when the block was mined that includes this transaction. The `value` column is of type `_numeric_` and represents the amount of `[chain_gas_token]` sent in this transaction in `wei`. Note that ERC20 tokens do not show up here. \n\nThe section also provides an example of the column data in the form of an embedded video. \n\nOverall, this section of the app technical guide provides a comprehensive overview of transactions in the Ethereum network, including tables and column data.\n## Questions: \n 1. What is the purpose of the Transactions table in this app and what data does it contain?\n   \n   The Transactions table contains information about transactions on various blockchain networks, including Ethereum Mainnet, Gnosis Chain, Polygon, Optimism, BNB Chain, Arbitrum, and Avalanche C-Chain. It includes data such as the block time, block number, value, gas limit, gas price, gas used, max fee per gas, max priority fee per gas, priority fee per gas, nonce, index, success, from address, to address, block hash, data, hash, type, access list, effective gas price, gas used for L1, L1 gas used, L1 gas price, L1 fee, L1 fee scalar, L1 block number, L1 timestamp, and L1 tx origin.\n   \n2. Does this app support EIP1559 and how is it reflected in the Transactions table?\n   \n   The app supports EIP1559 on some networks, but not on others. The Transactions table includes columns for max fee per gas, max priority fee per gas, and priority fee per gas, which are introduced by EIP1559. However, for networks where EIP1559 is not supported, these columns do not contain data and the type column is always set to Legacy.\n   \n3. How is gas measured in this app and is it consistent across all networks?\n   \n   Gas is measured in wei for most networks, but for Arbitrum it is measured in ArbGas and for Avalanche C-Chain it is measured in nanoavax. Therefore, gas measurement is not consistent across all networks in this app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\raw\\transactions.md"}}],["93",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\1-do-some-prerequisites and-set-up-Spellbook-dbt.md)\n\nThis app technical guide provides a step-by-step guide on how to set up Spellbook dbt on a local computer. The guide is divided into two main sections: prerequisites and setting up Spellbook dbt. The prerequisites section outlines the software and tools required to set up Spellbook dbt, including VSCode, Python 3.9, pip, pipenv, and git and GitHub. The section also provides links to resources for installing these tools and troubleshooting any issues that may arise.\n\nThe second section of the guide focuses on setting up Spellbook dbt. It provides instructions on how to clone the Spellbook repository, install the necessary packages, and initialize dbt. The guide also includes a sample configuration file with prompts that users can enter to configure dbt. The section concludes with instructions on how to create a new branch and push it to a remote GitHub repository.\n\nThe guide includes screenshots and a video tutorial to help users visualize the steps involved in setting up Spellbook dbt. The guide is intended for users who are new to Spellbook dbt and provides a comprehensive overview of the steps involved in setting up the tool. Overall, the guide is well-organized and easy to follow, making it an excellent resource for users who are new to Spellbook dbt.\n## Questions: \n 1. What is the purpose of Spellbook and how does it relate to blockchain technology?\n   - The app technical guide does not provide information on the purpose of Spellbook or its relation to blockchain technology.\n2. Are there any specific database management systems that Spellbook dbt is compatible with?\n   - The app technical guide mentions that during the setup process, users will be prompted to choose a database management system, with Databricks being one of the options.\n3. Are there any security considerations that need to be taken into account when setting up Spellbook?\n   - The app technical guide does not provide information on any security considerations that need to be taken into account when setting up Spellbook.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\1-do-some-prerequisites and-set-up-Spellbook-dbt.md"}}],["94",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\2-decide-on-a-Spell-to-cast.md)\n\nThis app technical guide covers the process of deciding on a Spell to cast in the Dune app. The guide provides three ways to decide on a Spell, including having an idea of what abstract data is needed, looking at Spellbook bounties in Dework, or asking for suggestions in the #spellbook Discord channel. The guide then provides an example of creating a migration Spell for translating the Keep3r network view_job_log abstraction from Dune's v1 database into a V2 Spell.\n\nThe guide also includes a note that Dune V1 Abstractions have been moved to a new repository, which needs to be cloned to access the code for migrating a V1 Abstraction to a Spell. The guide provides the full path to the view_job_log.sql file, which is needed to set up the file structure for the Spell's SQL schema and source files.\n\nOverall, this guide provides a step-by-step process for deciding on a Spell to cast and creating a migration Spell in the Dune app. It also includes helpful links and examples to guide users through the process.\n## Questions: \n 1. What is the purpose of the Dune Docs app and how does it relate to blockchain technology? \n   - The app technical guide does not provide information on the purpose of the Dune Docs app or its relation to blockchain technology.\n2. How does the migration Spell mentioned in the guide interact with blockchain data? \n   - The app technical guide does not provide information on how the migration Spell interacts with blockchain data.\n3. Are there any security considerations or best practices that should be followed when creating Spells in Dune? \n   - The app technical guide does not provide information on security considerations or best practices for creating Spells in Dune.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\2-decide-on-a-Spell-to-cast.md"}}],["95",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\3-set-up-your-file-structure-for-SQL-schema-and-source-files.md)\n\nThis technical guide provides instructions on how to set up the file structure for SQL, schema, and source files in the Dune Docs project. The guide explains that all Spells are stored in the `/spellbook/models` directory by project name and blockchain network. The folder names are all lowercase, and words are separated by underscores. The guide provides an example of the folder structure for the Keep3r network, where the folder is `/spellbook/models/keep3r_network/ethereum`. \n\nThe guide explains that if the project folder exists but a Spell is being created for a new blockchain, a folder for the new blockchain should be created. The guide then explains that three files need to be created: a `.sql` file for the Spell's logic, a `_schema.yml` file to define the Spell's purpose and add generic tests, descriptions, metadata, etc., and a `_sources.yml` file with any project-specific table dependencies. The guide provides an example of the file structure for a Spell folder. \n\nThe guide also explains the naming convention for Spell files. Schema files are named `[project_name]_[blockchain]_schema.yml`, sources files are named `[project_name]_[blockchain]_sources.yml`, and SQL files for Spells are named `[project_name]_[blockchain]_[spell_name].sql`. \n\nThe guide then provides an example of a specific v1 migration example where three additional `.sql` files are needed for a Spell called `keep3r_network_ethereum_view_job_log.sql`. The guide explains that these files are needed because the original `view_job_log.sql` V1 Abstraction has two `FROM` statements that reference two other files that are also abstractions that need to be converted into Spells. The guide also explains that a recursive check needs to be done to see if those abstractions depend on any other abstractions that have yet to be migrated to Spells. \n\nOverall, this technical guide provides a clear and detailed explanation of how to set up the file structure for Spells in the Dune Docs project. It provides examples and naming conventions for the different types of files needed for Spells and explains how to handle dependencies between Spells.\n## Questions: \n 1. What is the purpose of the app and how does it relate to blockchain technology?\n   Answer: The app technical guide is focused on setting up a file structure for SQL, schema, and source files for a project that involves blockchain networks. A blockchain SQL analyst might want to know more about the specific use case of the project and how it utilizes blockchain technology.\n\n2. What are the naming conventions for the files and folders in the app?\n   Answer: The app technical guide provides specific naming conventions for the files and folders used in the project. A blockchain SQL analyst might want to know more about these conventions to ensure consistency and organization in their work.\n\n3. How does the app handle dependencies between different files and abstractions?\n   Answer: The app technical guide explains how to identify and handle dependencies between different files and abstractions in the project. A blockchain SQL analyst might want to know more about this process to ensure that all necessary files and abstractions are properly migrated to Spells.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\3-set-up-your-file-structure-for-SQL-schema-and-source-files.md"}}],["96",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\4-identify-and-define-sources.md)\n\nThis app technical guide covers the process of identifying and defining sources in the Dune Docs project. The guide provides instructions on how to complete the `_sources.yml` file, which is used to specify the sources of data for the project. The file is formatted using YAML syntax, and it contains information about the version of the engine used, the name and description of the source, and the tables associated with the source.\n\nThe guide explains how to identify the sources that need to be named by searching for `FROM` statements in the V1 abstractions that are being migrated. The tables mentioned in these statements that are not abstractions are the ones that need to be included in the `_sources.yml` file. The guide provides an example of how to create a `keep3r_network_ethereum_sources.yml` file, which includes a description of the Keep3r Network, a marketplace for posting and accepting jobs to help run decentralized infrastructure. The file lists the tables associated with the source, such as `Keep3r_evt_LiquidityAddition` and `Keep3r_evt_KeeperWork`.\n\nOverall, this guide is essential for developers working on the Dune Docs project, as it provides clear instructions on how to identify and define sources of data. By following the steps outlined in the guide, developers can ensure that the project is properly structured and that the data is accurately represented.\n## Questions: \n 1. What is the purpose of the `_sources.yml` file in the Dune Docs project?\n    \n    The `_sources.yml` file in the Dune Docs project is used to identify and define sources for the project's data.\n\n2. How are the sources formatted in the `_sources.yml` file?\n    \n    The sources in the `_sources.yml` file are formatted with a name, a one-line description, and a list of tables.\n\n3. How can a blockchain SQL analyst determine which sources to name in the `_sources.yml` file?\n    \n    A blockchain SQL analyst can determine which sources to name in the `_sources.yml` file by searching for `FROM` statements in the V1 abstractions being migrated and looking for all tables mentioned that are not abstractions.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\4-identify-and-define-sources.md"}}],["97",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\6-write-your-spell-as-SELECT-statement.md)\n\nThis technical guide is focused on the app feature of the Dune Docs project. The guide provides a step-by-step process for writing a Spell as a SELECT statement. The guide starts by explaining that the endpoint is `_view_job_log.sql`, but the lowest-level dependency is `_view_job_migrations.sql`. The guide then explains that the process of migrating from V1 abstraction to V2 Spell starts by copying the contents of the V1 file to the `keep3r_network_ethereum_view_job_migrations.sql` file. The guide then explains how to modify the syntax from V1 abstraction style to V2 Spell style. \n\nThe guide also explains how to replace hard-coded references with JINJA templating. The guide clarifies that sources are data that have been added by the Dune team, while models are the `SELECT` statements defined in the `.sql` files stored inside the `spellbook/models` directory. The guide provides examples of how to format references to sources and models using JINJA templating. \n\nThe guide emphasizes the importance of testing each SQL file individually and fixing any errors before adding JINJA templating. The guide also provides tips on how to fix errors, including googling the error message or asking for help in the community Discord channel. \n\nOverall, this technical guide provides a detailed explanation of how to write a Spell as a SELECT statement and how to replace hard-coded references with JINJA templating. The guide is well-organized and easy to follow, making it a useful resource for developers working on the Dune Docs app.\n## Questions: \n 1. What is the purpose of the dune docs app?\n- The app technical guide does not provide information on the purpose of the dune docs app.\n\n2. What programming languages or technologies are used in this app?\n- The app technical guide mentions the use of SQL, PostgreSQL, Spark SQL, and JINJA templating.\n\n3. What is the process for migrating from V1 abstraction to V2 Spell style?\n- The app technical guide provides a detailed process for migrating from V1 abstraction to V2 Spell style, which involves modifying the syntax to Spark SQL, replacing hard-coded references with JINJA templating, and testing the SQL code in dune.com.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\6-write-your-spell-as-SELECT-statement.md"}}],["98",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\7-configure-alias-and-materialization-strategy.md)\n\nThis technical guide covers the configuration of aliases and materialization strategies in the dune docs project. The guide explains how to configure aliases for Spells, which are SQL files that contain logic for data transformation, and how to specify the materialization strategy for each Spell. The guide also provides an overview of the four materialization strategies available in dbt, which are table, ephemeral, view, and incremental. \n\nThe `view` materialization strategy is the default in Spellbook, and it is used to store SQL logic without additional data. The `incremental` materialization strategy, on the other hand, allows dbt to insert or update records in a table according to the defined logic. The guide provides an example of how to create an incremental Spell by specifying the partition column, materialization type, and incremental strategy. \n\nTo configure aliases and materialization, the guide explains how to add configuration to the top of each SQL file. The configuration includes an alias for the Spell file that appears in the dune.com UI, as well as how the file is stored and categorized in the UI. The guide provides an example of how to configure aliases for a `view` materialization strategy. \n\nFinally, the guide explains how to add new models to the `dbt_project.yml` file in the Spellbook root folder. The models section specifies the project name, schema, and materialization strategy for the project as a whole, as well as the specific blockchain(s) that the Spells are created for. \n\nOverall, this guide provides a comprehensive overview of how to configure aliases and materialization strategies in the dune docs project. It is a useful resource for developers who are working on the app, API, data tables, or query features of the project.\n## Questions: \n 1. What are the available materialization strategies in dbt and which ones does Spellbook use?\n   \n   Answer: There are 4 materialization strategies in dbt: `table`, `ephemeral`, `view`, and `incremental`. Spellbook uses `view` and `incremental`.\n   \n2. How can an `incremental` Spell be created and what are the benefits of using it?\n\n   Answer: An `incremental` Spell can be created by including specific configuration statements in the Config section of the SQL file. The benefits of using it are faster run times, though the data won't be as fresh as `view` Spells.\n   \n3. How can aliases and materialization be configured for a Spell and where should this configuration be added?\n\n   Answer: Aliases and materialization can be configured for a Spell by adding configuration statements to the top of each SQL file. This configuration assumes a `view` materialization strategy. It should be added to the top of each SQL file.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\7-configure-alias-and-materialization-strategy.md"}}],["99",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\8-make-a-pull-request-get-merged-become-an-archwizard.md)\n\nThis section of the app technical guide covers the process of submitting a pull request to the official Spellbook in the Dune Docs project. The guide provides step-by-step instructions on how to commit local changes to a GitHub fork of the Spellbook and then submit a pull request. \n\nThe guide also includes a screenshot of the \"Open pull request\" button on the GitHub page and advises users to give their pull request an appropriate message. It also notes that comments from the team may be received and that improvements may need to be made before the pull request is approved. \n\nThe purpose of this guide is to help users contribute to the Spellbook and become Dune Archwizards. It is relevant to the app folder of the project as it pertains to the process of submitting changes to the app's codebase. \n\nAn example of how this guide could be useful is if a user has made changes to the Spellbook and wants to contribute those changes to the official version. By following the steps outlined in the guide, the user can ensure that their changes are properly submitted and reviewed by the team before being merged into the official Spellbook.\n## Questions: \n 1. What is the purpose of the Spellbook and how does it relate to blockchain technology?\n   \n   The app technical guide does not provide information on the purpose of the Spellbook or its relation to blockchain technology.\n\n2. Are there any specific coding languages or frameworks required to contribute to the Spellbook?\n\n   The app technical guide does not provide information on any specific coding languages or frameworks required to contribute to the Spellbook.\n\n3. Is there a review process for pull requests and who is responsible for reviewing them?\n\n   The app technical guide mentions that there is a review process for pull requests and that the Team provides comments for improvements, but it does not provide information on who is responsible for reviewing the pull requests.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\8-make-a-pull-request-get-merged-become-an-archwizard.md"}}],["100",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\Adding A Spell\\index.md)\n\nThis technical guide is titled \"How to Cast a Spell\" and is focused on the Spellbook feature of the Dune Docs project. The guide explains what Spellbook is, why it is used, and how to use it. Spellbook is an open-source dbt repository that allows users to create and maintain high-level blockchain data tables using SQL and Jinja templating. It enables the community to build towards a standardized way to transform data into meaningful abstraction layers. \n\nThe guide explains that blockchain data is packaged in blocks, which is one form of data we call \"Raw\" in Dune. Spellbook lets users create abstracted data sets, like dex.trades and nft.trades, which aggregate and organize raw data from multiple sources to make it much easier to query. The guide provides examples of how to use Spellbook to analyze blockchain data and how it can save time and effort.\n\nThe guide also provides an overview of the nft.trades Spell, which allows users to see industry-wide stats like total volume by # of txs and $USD, 24-hr volume, 24-hour and 7-day growth, market share by marketplace, volume by marketplace, and transaction count by marketplace. The guide explains how Spellbook can be used to make data more transparent, accessible, and meaningful together.\n\nThe guide provides 8 steps to casting a Spell, which includes doing some prerequisites and setting up Spellbook dbt, deciding on a Spell to cast, setting up the file structure for SQL, schema, and source files, identifying and defining sources, defining expectations with schema and tests, writing the Spell as a SELECT statement, configuring alias and materialization strategy, and making a pull request, getting merged, and becoming an Archwizard. \n\nOverall, this technical guide provides a comprehensive overview of Spellbook and how to use it to analyze blockchain data. It is a useful resource for anyone looking to work with blockchain data and wants to learn how to use Spellbook to make the process easier and more efficient.\n## Questions: \n 1. What is Spellbook and how does it relate to blockchain data analytics?\n   \n   Spellbook is an open-source dbt repository that allows for the creation and maintenance of high-level blockchain data tables using SQL and Jinja templating. It enables the community to build towards a standardized way to transform data into meaningful abstraction layers, making it much easier to query and analyze blockchain data.\n\n2. How does the nft.trades Spell work and what insights can it provide for blockchain data analysts?\n   \n   The nft.trades Spell allows for the querying of industry-wide stats such as total volume by number of transactions and USD, 24-hour volume, 24-hour and 7-day growth, market share by marketplace, volume by marketplace, and transaction count by marketplace. It provides insights into the performance of NFT marketplaces and can be used to create dashboards and visualizations for analysis.\n\n3. What are the steps to casting a Spell and how can it benefit the web3 data community?\n   \n   The 8 steps to casting a Spell include prerequisites and setting up Spellbook dbt, deciding on a Spell to cast, setting up file structure for SQL, schema, and source files, identifying and defining sources, defining expectations with schema and tests, writing the Spell as a SELECT statement, configuring alias and materialization strategy, and making a pull request to become an Archwizard. Casting a Spell can benefit the web3 data community by allowing for the creation of standardized abstraction layers and making blockchain data more transparent, accessible, and meaningful for analysis.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\index.md"}}],["101",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\spellbook\\contributing\\Adding A Spell)\n\nThe \"Adding A Spell\" folder in the Dune Docs project is focused on guiding users through the process of creating and contributing a new Spell to the Spellbook feature. The Spellbook is an open-source dbt repository that allows users to create and maintain high-level blockchain data tables using SQL and Jinja templating. It enables the community to build towards a standardized way to transform data into meaningful abstraction layers.\n\nThe guide in this folder covers various aspects of creating a new Spell, including setting up prerequisites and the Spellbook dbt environment, deciding on a Spell to cast, setting up the file structure for SQL, schema, and source files, identifying and defining sources, defining expectations with schema and tests, writing the Spell as a SELECT statement, configuring alias and materialization strategy, and making a pull request to contribute the Spell to the official Spellbook.\n\nThis guide is particularly useful for developers and analysts who want to contribute to the Dune Docs project by creating new Spells or migrating existing V1 abstractions to V2 Spells. By following the steps outlined in the guide, users can ensure that their Spells are properly structured, tested, and submitted for review by the Dune Docs team.\n\nFor example, a user might want to create a new Spell that aggregates data from multiple sources to analyze the performance of a specific decentralized finance (DeFi) protocol. By following the guide, the user can set up the necessary environment, create the required files, write the SQL logic, and submit their Spell for review and potential inclusion in the official Spellbook.\n\nOverall, the \"Adding A Spell\" folder provides a comprehensive and detailed guide for users who want to contribute to the Dune Docs project by creating and submitting new Spells. The guide is well-organized and easy to follow, making it an excellent resource for users who are new to the Spellbook feature or the Dune Docs project as a whole.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\Adding A Spell\\summary.md"}}],["102",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\examples\\daily-aggregation.md)\n\n# Daily Aggregation\n\nThis technical guide covers the Daily Aggregation feature of the Dune Docs project. The Daily Aggregation feature sums all transfers for the day. The table is materialized as an incrementally loaded table updated every 15 minutes because the next step includes a slower `window` function to capture a rolling sum.\n\nThe guide explains the novel components that make this Spell incremental. The `<div data-gb-custom-block data-tag=\"if\"> </div>` JINJA block allows the addition of an arbitrary filter when running in ‚Äúincremental‚Äù mode. Incremental mode is default, and a full refresh is denoted by a command-line argument to completely recreate the table. The block is used to filter for all data timestamped in the last two days. The model runs every fifteen minutes, but a look back of 2 days is allowed to account for data arriving late from the blockchain.\n\nThe guide also explains the use of ‚Äúrefs‚Äù in this spellset. A ref, like `{{ ref('tokens_ethereum_erc20') }}` is a reference to another model in the DBT project. The ref references the name of the file itself. That means, duplicate file names are not allowed.\n\nThe guide provides an example of the `transfers_ethereum_erc20_agg_day.sql` file, which contains the SQL code for the Daily Aggregation feature. The file uses the `config` function to set the alias, materialized, file format, incremental strategy, and unique key. The SQL code selects the blockchain, date truncated to the day, wallet address, token address, symbol, sum of the amount_raw, sum of the amount_raw divided by power(10, t.decimals), and unique_transfer_id. The file also uses the `left join` function to join the `transfers_ethereum_erc20` and `tokens_ethereum_erc20` tables. The `where` function is used to filter the data timestamped in the last two days. The `group by` function is used to group the data by date truncated to the day, wallet address, token address, t.symbol, and unique_tx_id.\n\nThe guide also provides an example of the `transfers_ethereum_schema.yml` file, which contains the schema for the Daily Aggregation feature. The file includes the name, meta, config, and columns of the table. The columns include blockchain, hour, wallet_address, token_address, symbol, amount_raw, amount, and amount_usd.\n\nIn summary, the Daily Aggregation feature of the Dune Docs project is an incrementally loaded table updated every 15 minutes that sums all transfers for the day. The feature uses a JINJA block to add an arbitrary filter when running in ‚Äúincremental‚Äù mode and refs to reference another model in the DBT project. The `transfers_ethereum_erc20_agg_day.sql` file contains the SQL code for the feature, while the `transfers_ethereum_schema.yml` file contains the schema for the feature.\n## Questions: \n 1. What is the purpose of the \"incremental\" mode and how does it work?\n    \n    The \"incremental\" mode is used to update the table every 15 minutes with new data. It is the default mode and allows for a look back of 2 days to account for late data from the blockchain. A full refresh is denoted by a command line arg to completely recreate the table.\n    \n2. How does the app handle duplicates in the table and what is the unique key used for deduplication?\n    \n    The app uses a \"merge\" incremental strategy to handle duplicates in the table. The unique key used for deduplication is the `'unique_transfer_id'` which is created by coalescing several transfer features together.\n    \n3. What is a \"ref\" in this app and how is it used?\n    \n    A \"ref\" is a reference to another model in the DBT project. It references the name of the file itself and is used to avoid duplicate file names. In this app, it is used to reference the transfers and tokens models in the Ethereum ERC20 project.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\daily-aggregation.md"}}],["103",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\examples\\final-day-balance.md)\n\n# Final Daily Balance\n\nThis technical guide is focused on the `app` folder of the Dune Docs project. The guide explains the final daily Ethereum ERC20 token balances spell. The spell is expanded to cover all days, not just the days with transfer activity. The guide also explains how price data is added, known rebase tokens are removed, and any tokens that resulted in large negative balances are removed.\n\nThe `balances_ethereum_erc20_day.sql` file contains the SQL code for the spell. The code uses the `transfers_ethereum_erc20_rolling_day` table to derive the `balances_ethereum_erc20_noncompliant` table. The `balances_ethereum_erc20_noncompliant` table looks for unique token addresses with larger negative balances, which indicate the contract may not be compliant with ERC20. The `tokens_ethereum_rebase` table is a static list of known rebase tokens that are managed.\n\nThe SQL code in `balances_ethereum_erc20_day.sql` calculates the daily token balances of ERC20 Ethereum tokens per wallet and contract address pair. The code uses the `prices` table to calculate the amount in USD. The code also removes rebase tokens from balances and likely non-compliant tokens due to negative balances.\n\nThe `transfers_ethereum_schema.yml` file contains the schema for the `balances_ethereum_erc20_day` table. The table has columns for the blockchain, day, wallet address, token address, amount raw, amount, amount USD, and symbol.\n\nOverall, this technical guide provides a detailed explanation of the final daily Ethereum ERC20 token balances spell and how it works. It also explains the tables used and how they are derived. The guide is useful for developers who want to understand how the spell works and how to use it in their projects.\n## Questions: \n 1. What is the purpose of the `transfers_ethereum_erc20_rolling_day` table and how is it used in the `balances_ethereum_erc20_day` query?\n   \n   The blockchain SQL analyst might want to know more about the `transfers_ethereum_erc20_rolling_day` table and how it is used in the `balances_ethereum_erc20_day` query to understand how daily token balances are calculated.\n\n2. How are rebase tokens identified and removed from the final daily Ethereum ERC20 token balances spell?\n   \n   The blockchain SQL analyst might want to know more about how rebase tokens are identified and removed from the final daily Ethereum ERC20 token balances spell to understand how the spell handles these types of tokens.\n\n3. What is the significance of the `balances_ethereum_erc20_noncompliant` table and how is it derived?\n   \n   The blockchain SQL analyst might want to know more about the `balances_ethereum_erc20_noncompliant` table and how it is derived to understand how the spell identifies non-compliant ERC20 tokens.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\final-day-balance.md"}}],["104",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\examples\\index.md)\n\nThis app technical guide covers the Spellbook Examples for the Dune Docs project. The Spellbook Examples are a series of modular spells that demonstrate how to track daily balances for ERC-20 tokens that follow a contract standard set by the Ethereum Foundation. The guide begins by introducing ERC-20 tokens and the need to identify transfers to track daily balances. The main base Dune table used for this purpose is `erc20_ethereum.evt_Transfer`, which can be found via the data explorer.\n\nThe guide then goes on to describe the modular spells that make up the Spellbook Examples. The first spell is the Reformatted transfers spell, which reformats the data from the `evt_Transfer` table to make it easier to work with. The second spell is the Daily aggregation of transfers spell, which aggregates the transfers on a daily basis. The third spell is the Rolling sum of daily transfers spell, which calculates the rolling sum of daily transfers. The final spell is the Final daily balances for Ethereum ERC20 tokens spell, which calculates the final daily balances for the ERC-20 tokens.\n\nEach spell is described in detail, with examples and screenshots where appropriate. The guide is focused on the app folder of the project and provides a high-level overview of the purpose of each spell and how it applies to the app. Overall, this guide serves as a useful resource for developers looking to track daily balances for ERC-20 tokens using the Dune Docs app.\n## Questions: \n 1. What is the purpose of the Dune table `erc20_ethereum.evt_Transfer` and how does it relate to blockchain data analysis? \n   - The Dune table `erc20_ethereum.evt_Transfer` is used to track daily balances of ERC-20 tokens and is a key component in analyzing blockchain data related to token transfers.\n2. How does the Spellbook Examples module break down the analysis of ERC-20 tokens? \n   - The Spellbook Examples module breaks down the analysis of ERC-20 tokens into a series of modular spells, including reformatted transfers, daily aggregation, rolling sum, and final daily balances.\n3. Is this app technical guide specific to Ethereum or can it be applied to other blockchain platforms? \n   - The app technical guide specifically references ERC-20 tokens and the Ethereum Foundation, so a blockchain SQL analyst may wonder if the techniques and tools described can be applied to other blockchain platforms and token standards.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\index.md"}}],["105",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\examples\\reformatted.md)\n\nThe app technical guide is focused on the Reformatted Transfers feature of the Dune Docs project. The guide explains how the base table records the transfer amount to and from an account, and how it is munged into a union of sent transactions and received transactions to make it easier to sum up transfers. The guide also explains how WETH requires special handling, and how `zeroex_ethereum.weth9_evt_deposit` is added as a source to the model. \n\nThe guide further explains that the model is defined in a YAML file, where things like the description, tests, and metadata are defined. The guide also highlights that the JINJA config block defines that the alias for this view is `erc20`, and without this alias, the table name would default to the file name. The schema name for this view is defined in the `dbt_project.yml` file in the root of the Spellbook project. \n\nThe guide provides examples of the SQL code for the `transfers_ethereum_erc20` model, the YAML file for the model, and the `dbt_project.yml` file. The SQL code shows how the sent transfers, received transfers, deposited WETH, and withdrawn WETH are selected and unioned to create the `transfers_ethereum_erc20` model. The YAML file shows the metadata, description, and columns for the `transfers_ethereum_erc20` model. The `dbt_project.yml` file shows the schema and materialized view for the `transfers` and `ethereum` models. \n\nOverall, the app technical guide provides a detailed explanation of the Reformatted Transfers feature of the Dune Docs project, including how it works, how it is defined, and how it is implemented. The guide is useful for developers who want to understand how the feature works and how to use it in their own projects.\n## Questions: \n 1. What is the purpose of the `unique_tx_id` field in the SQL query?\n   \n   The `unique_tx_id` field is used to identify unique transactions and avoid duplicates in the table.\n\n2. How are contributors tracked in the YAML file?\n   \n   Contributors are tracked in the YAML file using the `contributors` field, where they can add their handle when writing or editing a spell.\n\n3. How is the schema name for this view defined in the project?\n   \n   The schema name for this view is defined in the `dbt_project.yml` file in the root of the Spellbook project, where schemas are defined by the directory structure.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\reformatted.md"}}],["106",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\examples\\rolling-sum.md)\n\n# Rolling Sum of Daily Transfers\n\nThis section of the app technical guide covers the rolling sum of daily transfers feature of the Dune Docs project. The purpose of this feature is to apply a rolling sum window function to each daily transfer sum. The query for this feature is provided in the `transfers_ethereum_erc20_rolling_day.sql` file. The query selects the blockchain, day, wallet address, token address, symbol, last updated timestamp, recency index, and the sum of the raw amount and amount of the ERC20 token held. \n\nThe `transfers_ethereum_schema.yml` file contains the schema for the `transfers_ethereum_erc20_rolling_hour` table. This table includes columns for the blockchain, hour, wallet address, token address, symbol, amount raw, amount, amount in USD, updated at timestamp, and recency index. \n\nThe purpose of these files is to provide the necessary code and schema for the rolling sum of daily transfers feature. The `transfers_ethereum_erc20_rolling_day.sql` file provides the query for the feature, while the `transfers_ethereum_schema.yml` file provides the schema for the table that stores the results of the query. \n\nOverall, this section of the app technical guide provides developers with the necessary information to implement the rolling sum of daily transfers feature in the Dune Docs project.\n## Questions: \n 1. What is the purpose of the Rolling Sum of Daily Transfers query in the context of blockchain SQL analysis?\n- The Rolling Sum of Daily Transfers query is used to apply a rolling sum window function to each daily transfer sum in order to calculate the amount of ERC20 tokens held by each wallet/contract pair.\n\n2. How does the Rolling Sum of Daily Transfers query handle missing data?\n- The Rolling Sum of Daily Transfers query fills in all the missing days and does a few more clean up steps in order to ensure accurate calculations.\n\n3. What information is included in the transfers_ethereum_erc20_rolling_hour schema?\n- The transfers_ethereum_erc20_rolling_hour schema includes information such as the blockchain, hour, wallet address, token address, ERC20 token symbol, rolling sum of raw amount of ERC20 token held, rolling sum of amount of ERC20 token held in USD, UTC timestamp when table was last updated, and recency index.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\rolling-sum.md"}}],["107",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\spellbook\\contributing\\examples)\n\nThis section of the app technical guide focuses on the Spellbook Examples for the Dune Docs project, specifically covering the daily aggregation of transfers, final daily balances, reformatted transfers, and rolling sum of daily transfers features. These modular spells demonstrate how to track daily balances for ERC-20 tokens that follow a contract standard set by the Ethereum Foundation. The guide is particularly useful for developers looking to track daily balances for ERC-20 tokens using the Dune Docs app.\n\nThe **Daily Aggregation** feature sums all transfers for the day and is incrementally loaded every 15 minutes. The guide explains the use of JINJA blocks and refs in this spellset, as well as providing examples of the `transfers_ethereum_erc20_agg_day.sql` file and the `transfers_ethereum_schema.yml` file.\n\nThe **Final Daily Balance** feature calculates the final daily Ethereum ERC20 token balances per wallet and contract address pair. The guide explains how price data is added, known rebase tokens are removed, and any tokens that resulted in large negative balances are removed. Examples of the `balances_ethereum_erc20_day.sql` file and the `transfers_ethereum_schema.yml` file are provided.\n\nThe **Reformatted Transfers** feature reformats the data from the `evt_Transfer` table to make it easier to work with. The guide explains how WETH requires special handling and how `zeroex_ethereum.weth9_evt_deposit` is added as a source to the model. Examples of the SQL code for the `transfers_ethereum_erc20` model, the YAML file for the model, and the `dbt_project.yml` file are provided.\n\nThe **Rolling Sum of Daily Transfers** feature applies a rolling sum window function to each daily transfer sum. The guide provides examples of the `transfers_ethereum_erc20_rolling_day.sql` file and the `transfers_ethereum_schema.yml` file.\n\nIn summary, this section of the app technical guide offers a comprehensive understanding of the Spellbook Examples for the Dune Docs project, focusing on the daily aggregation of transfers, final daily balances, reformatted transfers, and rolling sum of daily transfers features. The guide is beneficial for developers who want to implement these features in their own projects and gain a deeper understanding of how they work within the Dune Docs app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\examples\\summary.md"}}],["108",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\contributing\\index.md)\n\nThe Spellbook technical guide is focused on providing information on how to cast a spell from scratch using the Spellbook app. The guide is divided into two main sections: Casting a Spell from Scratch and Video Guides. \n\nThe Casting a Spell from Scratch section provides a link to a guide on how to add a spell to the Spellbook app. This section is aimed at users who prefer to learn by doing and want to get started with the app. Additionally, the section provides a link to the Spellbook GitHub repository for users who want to take a look under the hood and understand the app's infrastructure.\n\nThe Video Guides section contains two video tutorials on how to use the Spellbook app. The first video is a DuneCon workshop by Megan Heintz, a Dune Team member, who walks users through Spellbook's infrastructure and how to migrate data to a spell. The second video tutorial is by Andrew Hong, who shows users the main protocol interactions and how to pull and transform data on Ethereum using the app. \n\nOverall, the Spellbook technical guide provides users with a comprehensive understanding of how to use the Spellbook app. The guide is aimed at users who want to learn by doing and those who want to understand the app's infrastructure. The video tutorials provide a step-by-step guide on how to use the app, making it easy for users to get started.\n## Questions: \n 1. What is the purpose of Spellbook and how does it relate to blockchain technology?\n   \n   The app technical guide does not provide clear information on the purpose of Spellbook or its relation to blockchain technology, so a blockchain SQL analyst might have to do further research or analysis to understand its relevance to their work.\n\n2. Are there any security considerations or vulnerabilities that need to be addressed when using Spellbook?\n\n   The app technical guide does not mention any security considerations or vulnerabilities related to Spellbook, so a blockchain SQL analyst might need to investigate further or consult with security experts to ensure the safety of their data.\n\n3. What programming languages or frameworks are used to develop Spellbook?\n\n   The app technical guide does not provide information on the programming languages or frameworks used to develop Spellbook, so a blockchain SQL analyst might need to examine the source code on GitHub or consult with the development team to understand the technical details of the app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\index.md"}}],["109",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\spellbook\\contributing)\n\nThe guide in the `Adding A Spell` folder is focused on guiding users through the process of creating and contributing a new Spell to the Spellbook feature within the Dune Docs project. The Spellbook is an open-source dbt repository that allows users to create and maintain high-level blockchain data tables using SQL and Jinja templating. It enables the community to build towards a standardized way to transform data into meaningful abstraction layers.\n\nThe guide covers various aspects of creating a new Spell, including setting up prerequisites and the Spellbook dbt environment, deciding on a Spell to cast, setting up the file structure for SQL, schema, and source files, identifying and defining sources, defining expectations with schema and tests, writing the Spell as a SELECT statement, configuring alias and materialization strategy, and making a pull request to contribute the Spell to the official Spellbook.\n\nThis guide is particularly useful for developers and analysts who want to contribute to the Dune Docs project by creating new Spells or migrating existing V1 abstractions to V2 Spells. By following the steps outlined in the guide, users can ensure that their Spells are properly structured, tested, and submitted for review by the Dune Docs team.\n\nFor example, a user might want to create a new Spell that aggregates data from multiple sources to analyze the performance of a specific decentralized finance (DeFi) protocol. By following the guide, the user can set up the necessary environment, create the required files, write the SQL logic, and submit their Spell for review and potential inclusion in the official Spellbook.\n\nOverall, the \"Adding A Spell\" folder provides a comprehensive and detailed guide for users who want to contribute to the Dune Docs project by creating and submitting new Spells. The guide is well-organized and easy to follow, making it an excellent resource for users who are new to the Spellbook feature or the Dune Docs project as a whole.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\contributing\\summary.md"}}],["110",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\index.md)\n\nThe app technical guide covers the Spells feature of the Dune project. Spells are custom tables that are built and maintained by Dune and the community. The guide explains that Spells are available on Dune V2 and can be queried from both Spark SQL and Dune SQL V2 Query Engines. The guide also provides a link to the Spellbook GitHub repository where the Spells can be found. \n\nThe guide explains that the Spellbook is a retooling of the existing abstractions repository and a first-in-class open-source analytics engineering tool called dbt. Abstractions are some of the most queried tables on Dune, and the Spellbook aims to make the experience of creating them better. The guide explains that dbt allows for the writing and management of unit tests to spot and prevent any issues in the abstractions. \n\nThe guide also explains that there are two types of Spells: Sector Spells and Project Spells. Sector Spells are tables that take in data from multiple contracts and projects, standardize the data across them, and make it easy to query for this data and compare the metrics of different projects with each other. Project Spells allow projects to assemble their data into one neat table that has all the data they need in one place. \n\nThe guide provides information on how to contribute to the Spellbook and how to view available Spells. It also warns that the abstractions for V1 are no longer open for contributions and will be sunsetted with the V1 engine soon. \n\nOverall, the app technical guide provides a detailed explanation of the Spells feature of the Dune project, including how to use it, how to contribute to it, and how it can benefit users.\n## Questions: \n 1. What is the purpose of Spells in Dune and how are they maintained?\n- Spells are custom tables that cover a type of activity on the blockchain and are built and maintained by Dune and their community.\n\n2. What is the difference between Abstractions and Spells in Dune?\n- Abstractions are snippets of SQL executed on the data platform for the V1 engine, while Spells are models or tables that can be materialized into views and tables using dbt for the V2 engine.\n\n3. How can a blockchain SQL analyst contribute to Spellbook and what are some benefits of using dbt?\n- A blockchain SQL analyst can contribute to Spellbook by creating new Spells and submitting pull requests to the public GitHub repository. Using dbt allows for classical software engineering practices to be injected into writing SQL, including managing dependencies, writing and managing unit tests, and adding data integrity tests with minimal effort.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\index.md"}}],["111",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\spellbook)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\spellbook` folder contains technical guides and resources for the Spells feature of the Dune project. Spells are custom tables that are built and maintained by Dune and the community, aiming to standardize and simplify data querying across multiple contracts and projects. The folder is divided into two subfolders: `contributing` and `top tables`.\n\nThe `contributing` subfolder provides a comprehensive guide on how to create and contribute a new Spell to the Spellbook. This guide is particularly useful for developers and analysts who want to contribute to the Dune Docs project by creating new Spells or migrating existing V1 abstractions to V2 Spells. For example, a user might want to create a new Spell that aggregates data from multiple sources to analyze the performance of a specific decentralized finance (DeFi) protocol. By following the guide, the user can set up the necessary environment, create the required files, write the SQL logic, and submit their Spell for review and potential inclusion in the official Spellbook.\n\nThe `top tables` subfolder contains technical guides for various features of the Dune Docs project, specifically focusing on data tables and their usage. These guides are essential for analysts working with different aspects of the project, such as token transfers, metadata, prices, address labels, and NFT trades. For instance, the `dex.trades.md` guide provides an overview of the dex.trades feature, which aggregates data across multiple decentralized exchange (DEX) platforms into one simple table. This guide is useful for users who want to query trading data for their favorite tokens without dealing with different DEX smart contracts.\n\nOverall, the guides in the `.autodoc\\docs\\json\\docs\\data tables\\spellbook` folder provide valuable information for analysts working with various aspects of the Dune Docs project. They offer detailed explanations, examples, and insights into how these features fit into the larger project and how they can be used effectively. By following these guides, users can ensure that their Spells are properly structured, tested, and submitted for review by the Dune Docs team, ultimately contributing to the standardization and simplification of data querying across the Dune ecosystem.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\summary.md"}}],["112",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\top tables\\dex.trades.md)\n\n# Dex.Trades App Technical Guide\n\nThis technical guide provides an overview of the dex.trades feature of the Dune Docs project. Dex.trades is a table that aggregates data across multiple decentralized exchange (DEX) platforms into one simple table. The purpose of this table is to standardize and normalize trading data across virtually all relevant DEXs, making it easier for users to query trading data for their favorite tokens without having to deal with all of the different DEX smart contracts themselves.\n\n## Column Data\n\nThe guide provides a detailed breakdown of the column data contained in the dex.trades table. The column names, data types, and descriptions are all listed in a table format. Some of the key columns include:\n\n- `block_time`: The timestamp of the block that included the transaction\n- `token_a_symbol` and `token_b_symbol`: The symbols of the two tokens that were traded\n- `token_a_amount` and `token_b_amount`: The amounts of token A and token B that were traded\n- `project`: The DEX on which the trade was executed\n- `usd_amount`: The USD value of the trade\n\n## Github Repo\n\nThe guide also provides a link to the public Github repo where the scripts that generate the dex.trades table can be found. The repo is located in the `ethereum/dex` folder of the Dune Analytics Spellbook.\n\nOverall, this technical guide provides a high-level overview of the dex.trades feature of the Dune Docs project, including its purpose, column data, and Github repo.\n## Questions: \n 1. What blockchains does dex.trades support?\n- The `blockchain` column in the table provides information on which blockchain the trade occurred on.\n\n2. Can dex.trades handle trades from all decentralized exchanges?\n- The app technical guide states that dex.trades standardizes and normalizes trading data across \"virtually all relevant decentralized exchanges,\" but it is unclear if there are any exchanges that are not supported.\n\n3. How is the USD value of a trade calculated?\n- The `usd_amount` column in the table provides the USD value of a trade, but it is unclear how this value is calculated.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\dex.trades.md"}}],["113",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\top tables\\labels.md)\n\nThe Labels technical guide is a documentation for the Address Labels feature on Dune. The guide explains what labels are, how to add them, and how to use them. Labels are metadata about an address, in the form of a key-value pair, where the key is the label type and the value is the label name. The Labels feature allows users to add, update, and query labels for any address. \n\nThe guide provides examples of what can be created with labels, such as labeling all addresses that used a certain dapp, all addresses that hold a certain amount of a token, or all addresses that use a dapp more than X times per month. Users can also come up with their own label types and names, as labels on Dune are open-ended and crowd-sourced. \n\nThe Labels table stores labels in the `labels.labels` table, which has a schema that includes columns such as `id`, `address`, `name`, `blockchain`, `author`, `source`, `updated_at`, `label_type`, and `model_name`. \n\nThe guide also provides a warning that the Using Labels section is currently under construction. \n\nOverall, the Labels technical guide provides a comprehensive explanation of the Address Labels feature on Dune, including what labels are, how to add them, and how to use them. It also provides examples of what can be done with labels and information on how labels are stored in the Labels table.\n## Questions: \n 1. What is the purpose of the labels.labels table and what data is stored in it?\n   \n   The labels.labels table stores metadata about labeled addresses, including the label name, type, author, source, and last update time, as well as the address and blockchain it describes. It also includes the label model name.\n\n2. How are labels added to addresses and what are some examples of labels that can be added?\n   \n   Labels can be added to addresses using Dune queries, which can be used to label addresses based on various criteria such as dapp usage, token holdings, and transaction history. Examples of labels that can be added include addresses that used a certain dapp, hold a certain amount of a token, or sent money to a specific address.\n\n3. Are there any limitations or delays when querying labels in SQL on dune.com?\n   \n   There might be a few minutes delay from adding the label on dune.com until it can be queried in SQL.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\labels.md"}}],["114",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\top tables\\nft.trades.md)\n\nThe `nft.trades` technical guide provides an overview of the effort to make NFT trading data easily available to everyone on Dune. The guide explains that the table aggregates and standardizes data between different data platforms and provides auxiliary information and metadata all in one table. The guide also lists the platforms that have been indexed so far, including OpenSea, Rarible, SuperRare, CryptoPunks, Foundation, and LooksRare.\n\nThe guide explains how single item trades work, including the exchange of an item between a buyer and a seller, the identification of the item through a combination of `nft_contract_address` and `token_id`, and the metadata associated with the trade. The guide also explains how bundle trades and aggregator trades work and provides recommendations for working with these types of trades.\n\nThe guide includes examples of SQL queries that can be used to retrieve data from the `nft.trades` table, including all trades for a given NFT, trades in the last 24 hours on a given platform, and platform volumes in the last year. The guide also includes examples of dashboards that utilize parameters and look across the entire ecosystem.\n\nThe guide provides a detailed list of column data, including the data type and description of each column. The guide also explains that the SQL code that processes the data for every marketplace is open source and available in the Dune Analytics GitHub repository, allowing anyone to review the code, make pull requests, and submit code to add more marketplaces.\n\nOverall, the `nft.trades` technical guide provides a comprehensive overview of the effort to make NFT trading data easily available to everyone on Dune, including how the table works, how different types of trades work, examples of SQL queries and dashboards, and a detailed list of column data.\n## Questions: \n 1. What platforms are currently indexed by nft.trades?\n- OpenSea, Rarible, SuperRare, CryptoPunks, Foundation, and LooksRare are currently indexed by nft.trades.\n\n2. What metadata is provided about the traded NFT?\n- The metadata provided about the traded NFT includes nft_project_name and erc_standard.\n\n3. What should be done if a platform is not indexed by nft.trades?\n- If a platform is not indexed by nft.trades, the SQL code that processes the data for every marketplace is open source and available in their GitHub repository. Anyone can review the code, make pull requests, and submit code to add more marketplaces.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\nft.trades.md"}}],["115",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\top tables\\prices.md)\n\n# Prices\n\nThis technical guide covers the `Prices` feature of the Dune Docs project. The `Prices` feature allows users to get the price of almost all relevant ERC20 tokens. The price data is pulled from the Coinpaprika API and is volume-weighted based on real-time market data, translated to USD.\n\nThe guide provides two tables for getting prices: `prices.usd` and `prices_from_dex_data`. The `prices.usd` table supports a range of ERC20 tokens. If the token you desire is not listed in this table, you can make a pull request to the GitHub repository or use the decentralized price feed `dex.view_token_prices` for V1 Engine.\n\nThe `prices_from_dex_data` table creates price feeds based on decentralized exchange trading data. This table covers much more assets than `prices.usd` since it covers all assets that are traded on any of the decentralized exchanges that are indexed in `dex.trades`. However, this table is very resource-intensive and can only be updated every few hours. The resolution is only hourly, so if you need minutely prices, you should refer to `prices.usd`.\n\nThe guide also explains how the `prices_from_dex_data` table works. The script generates median hourly prices based on data from decentralized exchanges found in `dex.trades`. It assigns asset prices based on a trading pair that has a price feed in `prices.usd`. For example, if the $SPELL/ETH pool is used, the script will dynamically calculate the price of $SPELL based on the price of $ETH that was exchanged for it.\n\nThe guide also highlights known issues with the `prices_from_dex_data` table. In rare cases, the script will generate price feeds that are based on illiquid pairs and therefore report wrong data. This happens when all liquid trading pools of this token do not have a price feed in `prices.usd`. In such cases, you have to manually construct a price feed.\n\nOverall, this technical guide provides a comprehensive explanation of the `Prices` feature of the Dune Docs project. It explains how to use the two tables provided to get prices and highlights known issues with the `prices_from_dex_data` table.\n## Questions: \n 1. What is the source of price data for this app?\n- The price data is pulled from the coinpaprika API.\n\n2. What is the difference between the `prices.usd` table and the table that creates price feeds based on decentralized exchange trading data?\n- The `prices.usd` table supports a range of erc20.tokens and has a resolution by minute, while the table that creates price feeds based on decentralized exchange trading data covers much more assets than `prices.usd` and has a resolution only by hour.\n\n3. What are the known issues with the script that generates median hourly prices based on data from decentralized exchanges found in `dex.trades`?\n- In rare cases, the script will generate price feeds that are based on illiquid pairs and therefore report wrong data. This happens when all liquid trading pools of a token do not have a price feed in `prices.usd`. In cases like this, a manual price feed must be constructed.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\prices.md"}}],["116",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables\\spellbook\\top tables)\n\nThe `.autodoc\\docs\\json\\docs\\data tables\\spellbook\\top tables` folder contains technical guides for various features of the Dune Docs project, specifically focusing on data tables and their usage. These guides are essential for analysts working with different aspects of the project, such as token transfers, metadata, prices, address labels, and NFT trades.\n\nFor example, the `dex.trades.md` guide provides an overview of the dex.trades feature, which aggregates data across multiple decentralized exchange (DEX) platforms into one simple table. This guide is useful for users who want to query trading data for their favorite tokens without dealing with different DEX smart contracts.\n\nThe `labels.md` guide covers the Address Labels feature on Dune, explaining what labels are, how to add them, and how to use them. This guide is helpful for users who want to label addresses based on specific criteria, such as usage of a certain dapp or holding a certain amount of a token.\n\nThe `nft.trades.md` guide provides a comprehensive overview of the effort to make NFT trading data easily available on Dune. This guide is useful for users who want to retrieve data from the `nft.trades` table, such as all trades for a given NFT or platform volumes in the last year.\n\nThe `prices.md` guide covers the `Prices` feature, which allows users to get the price of almost all relevant ERC20 tokens. This guide is helpful for users who want to use the `prices.usd` and `prices_from_dex_data` tables to get token prices and understand the limitations of each table.\n\nLastly, the `tokens.md` guide focuses on token transfers and metadata for both fungible (erc20) and non-fungible (erc721 and erc1155) tokens. This guide is essential for analysts working with tokens, as it covers metadata and transfer tables, as well as a guide on how to calculate native token balances.\n\nOverall, the guides in this folder provide valuable information for analysts working with various aspects of the Dune Docs project. They offer detailed explanations, examples, and insights into how these features fit into the larger project and how they can be used effectively.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\summary.md"}}],["117",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/data tables\\spellbook\\top tables\\tokens.md)\n\nThe Tokens section of the app technical guide for the Dune Docs project covers token transfers and metadata. The guide is aimed at analysts who will be working with both fungible (erc20) and non-fungible (erc721 and erc1155) tokens. The guide provides information on several tables that are essential for working with tokens.\n\nThe Metadata tables section of the guide covers two tables: tokens.erc20 and tokens.nft. The tokens.erc20 table contains useful information such as the token symbol and the decimals for any given contract_address. The latter is needed to get the actual amount from raw amounts in on-chain data. The tokens.nft table contains the collection name and symbol for any given contract_address. These tables are usually joined on contract_address at the end of a query to make everything more human-readable.\n\nThe Transfer tables section of the guide covers two tables: erc20_ethereum.evt_Transfer and nft.transfers. The erc20_ethereum.evt_Transfer table contains all transfer events for every erc20 token. Analysts can find how to get erc20 balances, mints, and burns using a provided guide. The nft.transfers table contains all transfer events for every erc721 or erc1155 token. Analysts can learn how to leverage this to find nft balances, transfers, and mints in a provided guide.\n\nFinally, the guide provides a link to a guide on how to calculate native token balances like ethereum (ETH) balances. This guide is useful for analysts who need to calculate balances for native tokens.\n\nOverall, the Tokens section of the app technical guide provides essential information for analysts working with tokens. The guide covers metadata and transfer tables for both fungible and non-fungible tokens, as well as a guide on how to calculate native token balances.\n## Questions: \n 1. What types of tokens does this app support?\n   - The app supports both fungible (erc20) and nonfungible (erc721 and erc1155) tokens.\n2. What information can be found in the metadata tables?\n   - The metadata tables contain information such as the token symbol, decimals, collection name, and symbol for a given contract address.\n3. What transfer events can be found in the transfer tables?\n   - The transfer tables contain all transfer events for erc20, erc721, and erc1155 tokens, which can be used to find balances, transfers, mints, and burns.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\spellbook\\top tables\\tokens.md"}}],["118",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\data tables)\n\nThe `index.md` file in the `.autodoc\\docs\\json\\docs\\data tables` folder provides a comprehensive overview of the tables and chains available in the Dune Analytics platform. This guide is essential for users who want to navigate and query the platform effectively. The guide is divided into two main sections: the four kinds of tables and available chains.\n\nThe first section explains the process of ingesting data from node providers to create raw tables, which are then decoded using contract ABIs to provide easier to work with decoded tables. The abstracted tables are then created to standardize and aggregate the data from all other tables, giving users the easiest to work with spell tables. The community providers like Reservoir and Flashbots are also explained, which can be thought of as spell level abstractions.\n\nThe second section provides a list of available chains that can be queried in Dune Analytics. Each chain is explained in detail, including Ethereum, Gnosis Chain, Polygon POS, Optimism, BNB Chain, Arbitrum, Avalanche (C-Chain), Ethereum's Goerli Testnet, Fantom, Solana, and Bitcoin. The guide also includes links to relevant documentation for each chain, such as Ethereum.org for Ethereum, and the Binance Smart Chain documentation for BNB Chain.\n\nFor example, if a user wants to query data from the Ethereum Mainnet, they can read the section on Ethereum, which explains the history of Ethereum, its updates, and provides a link to Ethereum.org for further documentation. The guide also explains that querying on Dune works exactly the same as querying on Ethereum Mainnet.\n\nThe guide also includes a suggestion to look in spellbook and community datasets first, and then if users can't find what they want, they can try decoded and raw tables.\n\nOverall, this technical guide provides a comprehensive overview of the tables and chains available in Dune Analytics, making it easier for users to navigate and query the platform. By following this guide, analysts can effectively work with various data tables and chains, analyze their data, and integrate them into their projects.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\data tables\\summary.md"}}],["119",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/index.md)\n\nThe Dune Quickstart technical guide is an introductory guide to using Dune, a platform for analyzing blockchain data. The guide is divided into three sections, each with a specific focus. \n\nThe first section explains why it is important to learn how to use Dune. It highlights the challenges of understanding, ingesting, and aggregating blockchain data, and how Dune can help overcome these challenges. The section also emphasizes the benefits of using Dune, such as the ability to perform cross-context analysis and showcase work to a large audience. \n\nThe second section provides a step-by-step guide on how to analyze Web3 data using Dune. It focuses on how to get the weekly USD volume traded by DEXs in the last six months on Ethereum. The section explains how to use the `dex.trades` table, which is a spellbook table that has been put together by hundreds of star analysts in the community, supported by the Dune team. The section also provides a link to the query used in the example and explains how to work with lower-level tables such as raw and decoded tables. \n\nThe third section provides resources and guides for beginners to learn SQL and blockchain basics. It includes links to the Dune Official Getting Started Video Series, Weekly Web3 SQL problems, All Ethereum and SQL Basics, and hackerrank. The section also encourages readers to join the Dune community on Discord and participate in the `#üê•Ô∏±beginners` and `#üôãÔ∏±query-questions` channels. \n\nThe guide concludes by providing information on how to hire expert freelancers to help with Dune-related projects. \n\nOverall, the Dune Quickstart technical guide is a comprehensive guide that provides an overview of Dune and how to use it to analyze blockchain data. It is a useful resource for beginners who want to learn how to use Dune and for experienced users who want to expand their knowledge of the platform.\n## Questions: \n 1. What kind of blockchain data can be analyzed using Dune? \n- The app technical guide mentions that Dune can analyze data from various chains including Ethereum, Polygon, Goerli, Optimism, Solana, and Bitcoin. \n\n2. What are the different types of tables in Dune's database? \n- The app technical guide mentions that there are spellbook tables, raw tables, and decoded tables. \n\n3. How can someone leverage a query in future queries using Dune? \n- The app technical guide mentions that anyone can leverage a query in future queries by tracking the query id, and there is a guide on how to do this mentioned later in the document.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\index.md"}}],["120",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\dunesql-changes.md)\n\nThe DuneSQL migration technical guide provides documentation on the changes made to DuneSQL on March 2nd, 2023. The guide is divided into several sections, each with a specific focus. The first section is a warning that some tables in DuneSQL are still experiencing datatype issues, and the affected tables are listed. The section also provides a temporary workaround for the issue.\n\nThe second section of the guide explains the changes made to DuneSQL. DuneSQL has exited its alpha stage and now uses the same data types as the underlying EVM blockchain. This means that addresses, transaction hashes, and other encoded data are now stored as `varbinary` datatype. The guide also explains that `uint256` and `int256` are now supported, allowing full wei-level precision calculations. Additionally, the guide explains that logs are now stored with the correct topic indexing, and the `from_hex` native function has been modified to transform varchar to varbinary.\n\nThe third section of the guide explains what the changes mean for users. The switch to the `varbinary` datatype should improve query speed, and users can get rid of all string casts and conversions, making queries more readable and easier to maintain. The introduction of `uint256` and `int256` allows for full wei-level precision calculations, and the indexing of logs topics has been corrected to match the rest of the blockchain ecosystem.\n\nThe fourth section of the guide explains what users need to do to adjust to the changes. Users need to remove the `-- dunesql_alpha_deprecated` comment from their queries, adjust all occurrences of `0x` strings to fit the new data types, and remove any `varchar -> double`, `varchar -> decimals`, or `varchar -> bigint` casts. If queries used columns from logs tables, users need to adjust the indexing of topics. The guide provides a table of common errors and fixes.\n\nThe final section of the guide explains what will happen if users do not adjust to the changes. Queries will continue to run against the old data types until March 23, 2023, after which they will no longer run. The guide provides examples of breaking queries and fixed queries. Overall, the DuneSQL migration technical guide provides comprehensive documentation on the changes made to DuneSQL and what users need to do to adjust to the changes.\n## Questions: \n 1. What are the affected tables and when will they be fixed?\n- The affected tables are `prices.usd`, some Spellbook tables, `flashbots.*`, `reservoir.*`, `snapshot.*`, and `cowswap.*`. The fix for `prices.usd` was on March 6th, 2023, while the fixes for `flashbots.*` and `reservoir.*` will be on March 10th, 2023. The fixes for `snapshot.*` and `cowswap.*` are still to be determined.\n\n2. How will the switch to `varbinary` datatype affect query speed?\n- Switching to the `varbinary` datatype should significantly improve the speed of queries by approximately 30%.\n\n3. What should be done if a query has incompatible functions?\n- A comment `-- dunesql_alpha_deprecated` has been appended to any query that has incompatible functions. This comment allows the query to be run against the old data types until March 23, 2023. It is recommended to remove the comment and convert the query to use compatible functions before the deprecation date.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\dunesql-changes.md"}}],["121",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\DuneSQL.md)\n\nThe DuneSQL technical guide provides information on the datatypes, functions, and operators used in DuneSQL. The guide is divided into two main sections: Numerical types and Byte Array Functions. The Numerical types section covers the supported numerical types, including `INTEGER`, `BIGINT`, `DOUBLE`, `DECIMAL`, `UINT256`, and `INT256`. The Byte Array Functions section covers the helper functions used to manipulate byte arrays, including `bytearray_concat`, `bytearray_length`, `bytearray_ltrim`, `bytearray_position`, `bytearray_replace`, `bytearray_reverse`, `bytearray_rtrim`, `bytearray_starts_with`, `bytearray_substring`, and `bytearray_to_numeric`. \n\nThe guide also provides information on how to query queries as views in Dune SQL. All non-parameterized queries written using Dune SQL can be queried as views in other queries using the identifier `query_<queryId>`. The guide provides an example query that queries a saved query using its `queryId`. \n\nThe guide also includes a warning that Dune SQL exited alpha on March 2nd, 2023, and some changes to datatypes and column names were introduced that may cause breaking changes. The guide provides a link to the DuneSQL changes page for more details. \n\nOverall, the DuneSQL technical guide provides a comprehensive overview of the datatypes, functions, and operators used in DuneSQL, as well as information on how to query queries as views. The guide is a valuable resource for developers working with DuneSQL.\n## Questions: \n 1. What numerical types does DuneSQL support?\n- DuneSQL supports the numerical types `INTEGER`, `BIGINT`, `DOUBLE`, and fixed precision `DECIMAL` with precision up to 38 digits (i.e., `DECIMAL(38, 0)`), as well as `UINT256` for representing unsigned 256 bit integers and `INT256` for signed 256 bit integers.\n\n2. What are the byte array manipulation functions available in DuneSQL?\n- The byte array manipulation functions available in DuneSQL include `bytearray_concat`, `bytearray_length`, `bytearray_ltrim`, `bytearray_position`, `bytearray_replace`, `bytearray_reverse`, `bytearray_rtrim`, `bytearray_starts_with`, `bytearray_substring`, and `bytearray_substring`.\n\n3. Can all queries written using DuneSQL be queried as views in other queries?\n- Yes, all non-parameterized queries written using DuneSQL can be queried as views in other queries using the identifier `query_<queryId>`. However, there are some limitations, such as the requirement that all output columns of the query being queried must be named, and that only saved queries can be queried.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\DuneSQL.md"}}],["122",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\index.md)\n\n# Query Overview\n\nThis technical guide covers the querying process for data on Dune using DuneSQL, a custom-built query engine optimized for blockchain data. DuneSQL is a fork of TrinoSQL, an open-source distributed SQL query engine for big data, with added blockchain-specific optimizations. The guide explains how DuneSQL utilizes parquet files as its storage format, which is a columnar storage format optimized for fast reads. \n\nThe guide provides an overview of how to query using DuneSQL, highlighting the differences between DuneSQL and TrinoSQL. DuneSQL supports blockchain varbinary data types, which are used to store addresses, hashes, and other encoded data. Additionally, DuneSQL natively supports unint256 and int256 data types, which are used to store large numbers in blockchain data. The guide provides a set of functions that allow users to easily work with these data types. \n\nThe guide also covers the storage format used by DuneSQL, which is important to understand when writing efficient queries. Data is stored in columns instead of rows, allowing for fast reads of a single column, which is useful for aggregations and filters. \n\nThe guide provides resources for users to get help with SQL questions, including Google, ChatAIs, and the Trino documentation site. The #dune-sql Discord channel is also available for users to get help from the Dune team and Wizard community. Finally, the guide encourages users to send feedback to dunesql-feedback@dune.com to help improve and optimize the platform. \n\nOverall, this technical guide provides a comprehensive overview of querying on Dune using DuneSQL, including the data types and storage format used, as well as resources for users to get help and provide feedback.\n## Questions: \n 1. What optimizations has DuneSQL added to TrinoSQL specifically for blockchain data?\n   \n   Answer: The app technical guide mentions that DuneSQL has added blockchain specific optimizations to TrinoSQL, but it does not provide specific details on what those optimizations are. A blockchain SQL analyst might want to know more about these optimizations and how they improve query performance for blockchain data.\n\n2. How does DuneSQL handle large numbers in blockchain data?\n   \n   Answer: The app technical guide mentions that DuneSQL natively supports unint256 and int256 data types for storing large numbers in blockchain data, but it does not provide specific details on how these data types are handled. A blockchain SQL analyst might want to know more about how DuneSQL handles these data types and what functions are available for working with them.\n\n3. How does the columnar storage format used by DuneSQL compare to other storage formats commonly used in blockchain data analysis?\n   \n   Answer: The app technical guide mentions that DuneSQL utilizes a columnar storage format that is optimized for fast reads, but it does not provide a comparison to other storage formats commonly used in blockchain data analysis. A blockchain SQL analyst might want to know more about the advantages and disadvantages of using a columnar storage format for blockchain data analysis compared to other storage formats such as row-based or document-based storage.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\index.md"}}],["123",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\querying-with-DuneSQL\\functions-and-operators.md)\n\nThe app technical guide provided describes the built-in SQL functions and operators supported by DuneSQL. These functions and operators allow for the implementation of complex functionality and behavior of the SQL executed by Trino operating on the underlying data sources. \n\nThe guide provides links to a full alphabetical list and a full list by topic of the available functions and operators. Additionally, using SHOW FUNCTIONS returns a list of all available functions, including custom functions, with all supported arguments and a short description. \n\nThe guide also recommends reviewing the SQL data types and the SQL statement and syntax reference. \n\nEach header in the guide corresponds to a specific category of functions and operators, such as Aggregate, Array, Binary, Bitwise, Color, Comparison, Conditional, Conversion, Date and time, Decimal, Geospatial, HyperLogLog, IP Address, JSON, Lambda, Logical, Machine learning, Map, Math, Quantile digest, Regular expression, Session, Set Digest, String, System, Table, Teradata, T-Digest, URL, UUID, and Window. \n\nFor example, the Aggregate header provides a link to the Trino documentation on aggregate functions, which are used to perform a calculation on a set of values and return a single value. The Array header provides a link to the Trino documentation on array functions, which are used to manipulate arrays. \n\nOverall, this guide serves as a reference for developers working with DuneSQL to understand the available SQL functions and operators and how to use them effectively in their code.\n## Questions: \n 1. What is the purpose of DuneSQL and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of DuneSQL or its relation to blockchain technology.\n\n2. Are there any specific SQL functions or operators that are particularly useful for analyzing blockchain data?\n- The app technical guide provides a list of built-in SQL functions and operators supported by DuneSQL, but does not specify any that are particularly useful for analyzing blockchain data.\n\n3. Does DuneSQL support any specialized data types or functions for working with blockchain-specific data structures, such as Merkle trees or cryptographic hashes?\n- The app technical guide does not provide information on whether DuneSQL supports specialized data types or functions for working with blockchain-specific data structures.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\querying-with-DuneSQL\\functions-and-operators.md"}}],["124",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\query\\querying-with-DuneSQL)\n\nThe guide in the `functions-and-operators.md` file covers the built-in SQL functions and operators supported by DuneSQL, which is a part of the larger project feature \"query.\" This guide is essential for developers working with DuneSQL to understand the available SQL functions and operators and how to use them effectively in their code. It provides a comprehensive list of functions and operators, categorized by their specific use cases, such as Aggregate, Array, Binary, Bitwise, Color, Comparison, Conditional, Conversion, Date and time, Decimal, Geospatial, HyperLogLog, IP Address, JSON, Lambda, Logical, Machine learning, Map, Math, Quantile digest, Regular expression, Session, Set Digest, String, System, Table, Teradata, T-Digest, URL, UUID, and Window.\n\nFor example, if a developer is working on a feature that requires manipulating arrays, they can refer to the Array header in the guide, which provides a link to the Trino documentation on array functions. This will help them understand how to use the available functions to manipulate arrays effectively.\n\nSimilarly, if a developer needs to perform calculations on a set of values and return a single value, they can refer to the Aggregate header in the guide. This header provides a link to the Trino documentation on aggregate functions, which will help them understand how to use these functions in their code.\n\nThe guide also provides information on how to use the SHOW FUNCTIONS command to return a list of all available functions, including custom functions, with all supported arguments and a short description. This can be useful for developers who want to explore the available functions and their usage in their code.\n\nIn addition to the categorized list of functions and operators, the guide recommends reviewing the SQL data types and the SQL statement and syntax reference. This will help developers gain a better understanding of the data types they are working with and how to write efficient SQL queries using DuneSQL.\n\nOverall, this guide serves as a valuable reference for developers working with DuneSQL in the larger project feature \"query.\" It helps them understand the available SQL functions and operators, their usage, and how to implement complex functionality and behavior of the SQL executed by Trino operating on the underlying data sources.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\querying-with-DuneSQL\\summary.md"}}],["125",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\storage.md)\n\n# Storage\n\nThe Storage section of the Dune Docs app technical guide explains the differences and thinking behind the V2 database structure. The guide explains how databases read data from storage into memory to allow that data to be operated on, and how read speed is an essential constraint of databases. The guide then goes on to explain the differences between row-oriented and column-oriented databases, and how Dune V2 runs on column-oriented tables. \n\nThe guide explains that in a row-oriented database, many pages with unneeded data are loaded when querying for one column across thousands or millions of rows. In contrast, column-oriented databases store pages within row groups which partition the data by rows inside the parquet files. Thus, the database is still roughly stored in a row-oriented format, but the individual values are stored in column orientation inside pages. \n\nThe guide also explains that the `min/max` values of strings are oftentimes not very useful, and that the performance cost is mostly relevant for base tables like `ethereum.transactions`, `bnb.logs`, `erc20_ethereum.erc20_evt_transfer`, etc. which contain very large datasets that aren‚Äôt pre-filtered. \n\nThe guide provides examples of Dune V2 queries, including querying for transaction hashes and aggregating data over a large amount of logical rows. The guide explains that querying for data across a large amount of logical rows is now much more efficient, and a lot of queries that were formerly impossible due to timing out are now able to be executed. \n\nFinally, the guide explains that Dune will continue to keep innovating on these datasets and their database architecture to make every query run as fast as possible on V2. If users have any feedback or run into trouble with the new system, they can reach out to the #dune-sql Discord channel or send an email to dunesql-feedback@dune.com. \n\nOverall, this guide provides a detailed explanation of the differences between row-oriented and column-oriented databases, and how Dune V2 runs on column-oriented tables. The guide also provides examples of Dune V2 queries and explains how the new system is more efficient than the previous system.\n## Questions: \n 1. How does the transition to a data lake in Dune V2 and separating storage and compute address the I/O bound challenge in databases?\n    \n    Answer: A blockchain SQL analyst might want to know more about how the transition to a data lake in Dune V2 and separating storage and compute addresses the I/O bound challenge in databases.\n\n2. How does Dune V2's column-oriented database structure differ from traditional row-oriented databases in terms of query speed and efficiency?\n\n    Answer: A blockchain SQL analyst might want to know more about how Dune V2's column-oriented database structure differs from traditional row-oriented databases in terms of query speed and efficiency.\n\n3. How does Dune V2 handle indexing and querying for data stored in strings like `tx_hash` and `address`?\n\n    Answer: A blockchain SQL analyst might want to know more about how Dune V2 handles indexing and querying for data stored in strings like `tx_hash` and `address`.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\storage.md"}}],["126",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\query)\n\nThe `functions-and-operators.md` file in the `querying-with-DuneSQL` subfolder provides a comprehensive guide on the built-in SQL functions and operators supported by DuneSQL, which is a part of the larger project feature \"query.\" This guide is essential for developers working with DuneSQL to understand the available SQL functions and operators and how to use them effectively in their code. It provides a categorized list of functions and operators, such as Aggregate, Array, Binary, Bitwise, Color, Comparison, Conditional, Conversion, Date and time, Decimal, Geospatial, HyperLogLog, IP Address, JSON, Lambda, Logical, Machine learning, Map, Math, Quantile digest, Regular expression, Session, Set Digest, String, System, Table, Teradata, T-Digest, URL, UUID, and Window.\n\nFor example, if a developer is working on a feature that requires manipulating arrays, they can refer to the Array header in the guide, which provides a link to the Trino documentation on array functions. This will help them understand how to use the available functions to manipulate arrays effectively.\n\nSimilarly, if a developer needs to perform calculations on a set of values and return a single value, they can refer to the Aggregate header in the guide. This header provides a link to the Trino documentation on aggregate functions, which will help them understand how to use these functions in their code.\n\nThe guide also provides information on how to use the SHOW FUNCTIONS command to return a list of all available functions, including custom functions, with all supported arguments and a short description. This can be useful for developers who want to explore the available functions and their usage in their code.\n\nIn addition to the categorized list of functions and operators, the guide recommends reviewing the SQL data types and the SQL statement and syntax reference. This will help developers gain a better understanding of the data types they are working with and how to write efficient SQL queries using DuneSQL.\n\nOverall, this guide serves as a valuable reference for developers working with DuneSQL in the larger project feature \"query.\" It helps them understand the available SQL functions and operators, their usage, and how to implement complex functionality and behavior of the SQL executed by Trino operating on the underlying data sources.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\summary.md"}}],["127",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/query\\syntax-differences.md)\n\nThe app technical guide provides a comprehensive guide for migrating queries from Postgres to Dune SQL and from SparkSQL to DuneSQL. The guide covers the syntax and operator differences between Postgres, Spark, and Dune SQL. It provides a table that highlights the differences in syntax between the three databases. The table covers topics such as bytea2numeric, doing math or numeric operations on a column, 0 vs 1 array-based indexing, implicit type conversions between character and numeric types, addresses, selecting keyword columns, alias naming, exponentiation notation, interval argument, generate_series(), handling decimals for prices.usd, define NULL array, encoding strings to hex, get JSON object differences, group by an alias, explicit date/time casting, checking if an item exists in an array, explode, median, using ‚Äúis True/False,‚Äù string data type, casting as strings, left() method, aggregate functions, user-generated views, and event logs topic indexing.\n\nThe guide also provides examples of how to use Dune SQL to migrate queries from Postgres and SparkSQL. It also highlights the differences between the three databases and provides recommendations on how to avoid errors when using Dune SQL. For example, the guide recommends avoiding the use of double quotes in DuneV2, even when the engine runs your query without returning an error. This is because the parser sometimes treats words in double quotes as a string and sometimes it treats them as an object like a column name. \n\nOverall, the app technical guide is a useful resource for developers who want to migrate their queries from Postgres and SparkSQL to Dune SQL. It provides a detailed comparison of the syntax and operator differences between the three databases and provides examples of how to use Dune SQL to migrate queries.\n## Questions: \n 1. What are the differences in handling decimals for prices.usd in Dune SQL compared to Postgres and Spark SQL?\n- Dune SQL replaces prices.usd decimals with tokens_[blockchain].erc20.decimals.\n2. How does Dune SQL handle implicit type conversions between character and numeric types compared to Postgres and Spark SQL?\n- Dune SQL does not have implicit type conversions between character and numeric types, unlike Postgres and Spark SQL.\n3. What is the recommended approach for using double quotes in DuneV2?\n- Double quotes are not recommended in DuneV2 as the parser sometimes treats them as a string and sometimes as an object like a column name.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\query\\syntax-differences.md"}}],["128",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\citing-dune.md)\n\nThe app technical guide titled \"Citing Dune\" provides instructions on how to correctly reference and cite Dune queries and dashboards. The guide is focused on the app feature of referencing and sharing data on the Dune platform. \n\nThe guide starts by emphasizing that the content on Dune is created by the \"Wizards\" who build the queries, visualizations, and dashboards. It then goes on to explain that any use or mention of data or visualizations found on the platform should reference Dune as the source of such information. The guide provides a format for crediting the creator(s) of the specific query, dashboard, or data. \n\nThe guide also explains how to find the creator's username and the dashboard or query name on the Dune platform. It provides screenshots to illustrate how to locate this information. Additionally, the guide directs users to another page for more information on how to get embed links for visualizations they want to share. \n\nFinally, the guide highlights the limitations of commercial use of the queries and public dashboard on the Dune platform. It warns against copying, transmitting, modifying, or creating derivative works from the original queries and dashboard. It also prohibits any form of exploiting any portion, use, or access to Dune without the express written permission by Dune. \n\nOverall, the \"Citing Dune\" app technical guide provides clear instructions on how to properly reference and cite data and visualizations found on the Dune platform. It also emphasizes the importance of respecting the limitations of commercial use of the queries and dashboard on the platform.\n## Questions: \n 1. What type of data does Dune Docs provide and how is it sourced?\n   \n   Dune Docs provides queries, visualizations, and dashboards. The data is sourced from the creators (\"Wizards\") who build them.\n\n2. What are the limitations of commercial use for Dune Docs?\n   \n   Any form of copying, transmitting, transferring, modifying or creating derivative works from the original Queries and the public Dashboard or wrapping them in a white label manner for free or resale is strictly prohibited. Similarly, reproducing, sublicensing, transferring, duplicating, copying, selling, reselling, or any other forms of exploiting any portion, use or access to Dune without the express written permission by Dune is not allowed.\n\n3. Is there any information on how to get Embed links for Visualizations on Dune Docs?\n   \n   Yes, for more info on how to get Embed links for Visualizations you want to share, see the page linked in the guide.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\citing-dune.md"}}],["129",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\dune-bounties.md)\n\nThe Dune Bounties technical guide is a comprehensive guide that explains how Dune Analytics empowers projects and Wizards to collaborate through incentive-based analytics tasks. The guide is divided into several sections, each of which provides detailed information on a specific aspect of the Dune Bounties project. \n\nThe guide starts by introducing Dune Analytics as a go-to solution for on-demand crypto analytics. It then highlights the problem of Wizards and Projects not being able to find each other and the lack of organization in analytics tasks. The solution to this problem is the creation of a marketplace that can handle task creation, application process, communication, reputation, and payments. \n\nThe guide then introduces Dune Bounties, which is a bounty board that manages Dune internal bounty programs and is accessible to other projects and organizations. Dune Bounties leverages dework.xyz, which is a web3 native Trello with payments and credentialing. The guide provides detailed instructions on how to use Dune Bounties for both projects and Wizards. \n\nThe guide also explains the two parts of Dune, the App Layer, and the Data Layer. The App Layer contains Queries, Visualizations, and Dashboards, while the Data Layer allows Wizards to produce scalable and persistent work by standardizing and normalizing data. The guide recommends working in the Data Layer first to take care of data engineering before building cool stuff in the App Layer to surface findings. \n\nThe guide also provides a FAQ section that answers common questions about Dune Bounties, such as how much to pay Wizards, whether Dune takes a cut of bounty payments, and how to choose the right applicant. \n\nOverall, the Dune Bounties technical guide is a comprehensive guide that provides detailed information on how to use Dune Bounties for both projects and Wizards. It explains the problem of Wizards and Projects not being able to find each other and the lack of organization in analytics tasks and provides a solution to this problem. The guide also provides detailed instructions on how to use Dune Bounties and how to work in the App Layer and the Data Layer.\n## Questions: \n 1. What is the purpose of Dune Bounties and how does it relate to blockchain data analysis?\n   \n   Dune Bounties is a marketplace that connects projects in need of web3 analytics with Wizards who want jobs. It allows for task creation, application process, communication, reputation, and payments, and is web3 native. Blockchain SQL analysts might be interested in using this platform to find work or to offer their services to projects in need of analytics.\n\n2. How does Dune's Data Layer work and why is it important for blockchain data analysis?\n   \n   Dune's Data Layer, called Spellbook, allows for scalable and persistent work by standardizing and normalizing data. It enables Wizards to easily work with data as it's cleaned and standardized, and to reference it in other Spellbook tables. This is important for blockchain data analysis because it makes it easier to work with large amounts of data and to build on top of existing work.\n\n3. How does Dune Bounties handle payments and what is the recommended approach for organizing bounties for a project's needs?\n   \n   Dune Bounties uses Dework's native payment feature, where Wizards simply connect their wallet in their Dework profile and get paid as soon as the bounty is paid out by the Project that created the task. The recommended approach for organizing bounties for a project's needs is to first run specific tasks for adding data to Spellbook, then run a Dashboard design contest using Dework's \"multiple submissions\" feature.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\dune-bounties.md"}}],["130",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\dune-v2\\dunesql-changes.md)\n\nThe DuneSQL migration technical guide provides documentation on the changes made to DuneSQL on March 2nd, 2023. The guide is divided into several sections, each with a specific focus. \n\nThe warning section highlights the issues with datatypes in some tables in DuneSQL and provides a temporary workaround for the affected tables. \n\nThe DuneSQL Alpha Deprecation and Data Type Changes section explains the changes made to DuneSQL. The changes include the use of the same data types as the underlying EVM blockchain, support for uint256 and int256, correction of an ancient mistake in the database, and modification of the from_hex native function. The section also explains the implications of these changes for users, including improved query speed, easier query maintenance, and full wei-level precision calculations. \n\nThe What do I need to do? section provides a step-by-step guide on what users need to do to adjust their queries to use compatible functions before the deprecation date. The section also highlights common errors and fixes, such as casting varchar to varbinary, casting to uint256, using bytearray_substring, and using bytearray_starts_with instead of LIKE expression. \n\nThe Changes section provides a summary of the changes made to DuneSQL, including the renaming of logs.topicX columns to topic0, topic1, topic2, topic3, and the removal of automatic coercion of breaking type changes of contract updates. \n\nOverall, the DuneSQL migration technical guide provides a comprehensive overview of the changes made to DuneSQL and the implications for users. The guide is useful for developers and users who want to understand the changes and how to adjust their queries to use compatible functions.\n## Questions: \n 1. What are the current issues with datatypes in some tables in DuneSQL and when are they expected to be resolved?\n- The current issues with datatypes in some tables in DuneSQL include some Spellbook tables, `flashbots.*`, `reservoir.*`, and `snapshot.*` and `cowswap.*`. The issue with `prices.usd` has already been fixed on March 6th, 2023. The issues with `flashbots.*` and `reservoir.*` are expected to be fixed by March 10th, 2023, while the issues with `snapshot.*` and `cowswap.*` are still to be determined.\n\n2. What are the benefits of switching to the `varbinary` datatype in DuneSQL?\n- Switching to the `varbinary` datatype in DuneSQL should significantly improve the speed of queries by approximately 30%. It also eliminates the need for string casts and conversions, making queries more readable and easier to maintain. Additionally, the introduction of `uint256` and `int256` allows for full wei-level precision calculations.\n\n3. What are some common errors and fixes when working with the new data types in DuneSQL?\n- Some common errors and fixes when working with the new data types in DuneSQL include casting varchar to varbinary using `from_hex(x))`, casting to uint256 using `cast(xxx as uint256)`, using `bytearray_substring` and `bytearray_starts_with` instead of LIKE expression, and adjusting the indexing of topics from `Topic1` to `Topic0`, `Topic2` to `Topic1`, etc.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\dune-v2\\dunesql-changes.md"}}],["131",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\dune-v2\\index.md)\n\nThe Dune V2 technical guide provides an overview of the new features and updates to the Dune Engine V2, which is a query engine and database that enables users to query, extract, and visualize blockchain data. The guide explains that Dune V2 brings a new level of performance, scalability, and functionality to the core tools that let Wizards query, extract, and visualize the vast amounts of blockchain data available. \n\nThe guide highlights two significant updates to the Dune V2: a scalable column-oriented database and two new query engines, Dune SQL and Spark SQL. The new database architecture is transitioning away from a PostgreSQL database to a scalable columnar database. The difference between the two systems is that V2 uses a columnar storage format in contrast to PostgreSQL‚Äôs row-oriented approach. Traditional indexes are replaced by block range indexes, which are chunk level min/max values. \n\nThe guide also explains that DuneV2 leverages two different query engines as it transitions away from a PostgreSQL database to a data lake house. Spark SQL was the initial choice for a V2 Query engine, but after gathering data and feedback from the Beta release, the team realized it won‚Äôt allow them to continue to have the best blockchain data querying experience as they scale. The solution is Dune SQL powered by Trino, and it is live in alpha. \n\nThe guide also explains that abstractions in DuneV2 run on dbt (data build tool), which enables analytics engineers to transform data in their warehouses by simply writing select statements, then dbt handles turning these select statements into tables and views. Spells currently run on Spark SQL in Dune v2 but can also be queried on Dune SQL. \n\nThe guide provides links to resources where users can find more information about the new query engines and built-in functions. The guide also encourages users to reach out to the Dune team for help and feedback. \n\nOverall, the Dune V2 technical guide provides a comprehensive overview of the new features and updates to the Dune Engine V2, which is a query engine and database that enables users to query, extract, and visualize blockchain data. The guide is useful for developers and data analysts who want to learn more about the new features and updates to the Dune Engine V2.\n## Questions: \n 1. What is the difference between Dune V2's column oriented database and PostgreSQL's row oriented approach?\n- Dune V2's database uses a columnar storage format, while PostgreSQL uses a row oriented approach.\n2. Why did the Dune team decide to transition from Spark SQL to Dune SQL?\n- After gathering data and feedback from their Beta release, the Dune team realized that Dune SQL powered by Trino would provide a better blockchain data querying experience as they scale.\n3. What is the best way to get help from the Dune team and Wizard community when encountering issues with Dune V2?\n- The best place to get help is the #dune-sql Discord channel, and users can also send an email to dunesql-feedback@dune.com for assistance with updating and optimizing the app.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\dune-v2\\index.md"}}],["132",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\dune-v2\\query-engine.md)\n\nThe app technical guide covers the transition from PostgreSQL to Dune SQL and Spark SQL query engines in Dune V2. It provides a detailed comparison of syntax and operator differences between the three engines, including examples for various operations such as casting, indexing, type conversions, and aggregate functions.\n\nThe guide also explains the data types and functions available in Dune SQL, with a focus on numerical types, byte array functions, and byte array to numeric functions. It provides a comprehensive list of helper functions for working with byte arrays and their respective descriptions.\n\nAdditionally, the guide explains how to query queries as views in Dune SQL using the `query_<queryId>` identifier and provides an example for reference. It also highlights the limitations and requirements for using this feature.\n\nFinally, the guide suggests using Google and the respective documentation for Spark SQL and Trino SQL to find answers to specific questions. It also recommends the #dune-sql Discord channel for community support and encourages users to provide feedback via email.\n## Questions: \n 1. **What are the differences in syntax and keyword operators between PostgreSQL, Spark SQL, and Dune SQL?**\n\n   The app technical guide provides a syntax comparison table that highlights the key differences between PostgreSQL, Spark SQL, and Dune SQL. Some examples include differences in casting hex/bytea to a number, handling decimals for prices.usd, and aggregate functions.\n\n2. **What are the available byte array functions in Dune SQL?**\n\n   Dune SQL offers several byte array functions such as `bytearray_concat`, `bytearray_length`, `bytearray_ltrim`, `bytearray_position`, `bytearray_replace`, `bytearray_reverse`, `bytearray_rtrim`, `bytearray_starts_with`, and `bytearray_substring`. These functions simplify interactions with byte arrays by accounting for the `0x`-prefix and using byte index instead of character index.\n\n3. **How can I query queries as views in Dune SQL?**\n\n   In Dune SQL, you can query non-parameterized queries as views using the identifier `query_<queryId>`. For example, `select * from query_1234`. Note that all output columns of the query being queried must be named, parameterized queries are not supported, only public queries can be queried, only saved queries can be queried, and only queries written in Dune SQL can be queried.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\dune-v2\\query-engine.md"}}],["133",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\reference\\dune-v2)\n\nThe Dune V2 technical guide, located in the `.autodoc\\docs\\json\\docs\\reference\\dune-v2` folder, focuses on the updates and new features introduced in the Dune Engine V2, a query engine and database for blockchain data. The guide is essential for developers and data analysts who want to learn more about the new features and updates to the Dune Engine V2.\n\nThe guide covers the following key aspects:\n\n1. **DuneSQL migration technical guide (dunesql-changes.md)**: This guide provides a comprehensive overview of the changes made to DuneSQL and their implications for users. It includes a step-by-step guide on adjusting queries to use compatible functions before the deprecation date and highlights common errors and fixes. This guide is useful for developers and users who want to understand the changes and how to adjust their queries accordingly.\n\n2. **Dune V2 overview (index.md)**: This guide provides an overview of the new features and updates to the Dune Engine V2, including the transition to a scalable column-oriented database and the introduction of two new query engines, Dune SQL and Spark SQL. The guide also explains the use of dbt (data build tool) for data transformation and the support for Spells in Dune v2. This guide is useful for developers and data analysts who want to learn more about the new features and updates to the Dune Engine V2.\n\n3. **Query engine transition (query-engine.md)**: This guide covers the transition from PostgreSQL to Dune SQL and Spark SQL query engines in Dune V2. It provides a detailed comparison of syntax and operator differences between the three engines, including examples for various operations such as casting, indexing, type conversions, and aggregate functions. The guide also explains the data types and functions available in Dune SQL, with a focus on numerical types, byte array functions, and byte array to numeric functions. This guide is useful for developers and data analysts who want to understand the differences between the query engines and how to work with them effectively.\n\nOverall, the guides in this folder provide a comprehensive understanding of the new features and updates in the Dune Engine V2, enabling users to query, extract, and visualize blockchain data more efficiently. The guides are essential for developers and data analysts who want to learn more about the new features and updates to the Dune Engine V2 and how they might fit into the larger project or work with other parts of the project.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\dune-v2\\summary.md"}}],["134",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\events.md)\n\n# Events\n\nThis section of the app technical guide covers the events feature of the Dune app. The purpose of this feature is to keep the community informed about upcoming events, both online and in-person. The header provides a brief overview of the feature and encourages users to join the Dune community Discord server to stay connected with other users.\n\nThe guide then goes on to provide instructions on how to access the events calendar on the Dune website. The calendar is hosted on Google Calendar and can be accessed by visiting [events.dune.com](https://events.dune.com). The guide also includes a GIF that demonstrates how to subscribe to the calendar and add it to a user's personal calendar.\n\nOverall, this section of the app technical guide is focused on providing users with information about upcoming events and how to stay connected with the Dune community. It is a useful resource for users who want to stay up-to-date on the latest events and engage with other users. \n\nExample: \nIf a user wants to attend an upcoming Dune event, they can visit the events calendar on the Dune website to see the date, time, and location of the event. They can also subscribe to the calendar to receive notifications about upcoming events. Additionally, the guide encourages users to join the Dune community Discord server to connect with other users and learn from them.\n## Questions: \n 1. What kind of events does Dune Docs host and how often?\n   - The app technical guide does not provide information on the frequency or type of events hosted by Dune Docs.\n2. Does Dune Docs integrate with any blockchain technology or databases?\n   - The app technical guide does not mention any integration with blockchain technology or databases.\n3. Are there any APIs or developer tools available for integrating Dune Docs events into other applications?\n   - The app technical guide does not provide information on any APIs or developer tools for integrating Dune Docs events into other applications.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\events.md"}}],["135",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\faq\\does-dune-have-a-token.md)\n\n# App Technical Guide: Does Dune Have a Token?\n\nThis guide covers the topic of whether or not the Dune app has a token. The purpose of this guide is to provide a clear answer to this question for users who may be wondering about the app's authentication system.\n\nThe header \"Does Dune have a Token?\" is a high-level question that sets the tone for the rest of the guide. The answer is provided in the next section, which states that \"Dune does not have a token.\" This information is important for users who may be looking for a token-based authentication system and need to know that Dune does not offer this feature.\n\nOverall, this guide is relevant to the app folder of the Dune Docs project, as it pertains to the app's authentication system. It is a short and straightforward guide that provides a clear answer to a common question. \n\nExample: \nIf a user is trying to integrate Dune with another app that requires a token-based authentication system, they can refer to this guide to confirm that Dune does not offer this feature. This can save the user time and effort in trying to implement a feature that is not available in the app.\n## Questions: \n 1. What is the purpose of Dune Docs and how does it relate to blockchain technology? \n- This app technical guide does not provide information on the purpose of Dune Docs or its relation to blockchain technology. \n\n2. Is there any integration between Dune Docs and blockchain databases? \n- This app technical guide does not provide information on any integration between Dune Docs and blockchain databases. \n\n3. Are there any plans to introduce a token for Dune Docs in the future? \n- This app technical guide states that Dune does not have a token, but it does not provide information on any plans to introduce one in the future.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\faq\\does-dune-have-a-token.md"}}],["136",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\faq\\does-dune-have-an-api.md)\n\n# App Technical Guide: Does Dune have an API?\n\nThis guide covers the topic of whether Dune has an API and how to access it. The purpose of this guide is to inform users that Dune does indeed have an API and to provide instructions on how to obtain access to it. \n\nThe first header confirms that Dune has an API. The second header provides instructions on how to obtain access to the API. Users must sign up for a paid plan and add on API access to gain access to the API. The guide provides a link to pricing details for users to determine which plan is best for them. \n\nThe third header provides a link to learn more about how to use the API. This section is likely to contain more detailed information on how to use the API, including authentication, endpoints, and parameters. \n\nThe final header provides options for users who do not have API access. Paid plan users can export results as CSV, while anyone can embed Dune charts on their page for free by clicking \"Embed\" on any query visualization. \n\nOverall, this guide is a brief overview of Dune's API and how to access it. It is likely that users who are interested in using the API will need to refer to additional documentation to fully understand how to use it. \n\nExample: \n\nIf a user is interested in using Dune's API, they can refer to this guide to learn that Dune does indeed have an API and how to obtain access to it. They can then follow the link to learn more about how to use the API and refer to additional documentation as needed. If a user does not have API access, they can still export results as CSV or embed Dune charts on their page for free.\n## Questions: \n 1. What kind of data can be accessed through Dune's API?\n- The app technical guide does not provide information on the specific data that can be accessed through Dune's API.\n\n2. Is there a limit to the number of API requests that can be made?\n- The app technical guide does not mention any limits on the number of API requests that can be made.\n\n3. Are there any authentication or security measures in place for accessing the API?\n- The app technical guide mentions that API access is only available to paid plan users, but does not provide information on any authentication or security measures in place for accessing the API.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\faq\\does-dune-have-an-api.md"}}],["137",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\faq\\how-are-results-refreshing.md)\n\n# App Technical Guide: How often do results get refreshed?\n\nThis technical guide provides information on how often results get refreshed in the Dune app. The guide starts by directing users to the Meta Monitoring dashboard to see the current time it takes for new data to be added to Dune. \n\nThe guide then explains how results get refreshed in the app. When a visualization is viewed on a query page or dashboard, the Dune backend inspects the age of the most recent result. If the result is stale (currently defined as >3 hours old), Dune automatically queues an execution for this query and runs it in the background. This ensures that dashboards are always kept up to date when they are being viewed, and the query creator does not need to set a refresh schedule. \n\nThe guide also notes that the query execution queue is separate from each individual user's queue when they create and run queries in the query editor. \n\nOverall, this guide provides important information on how the Dune app keeps results up to date and ensures that dashboards are always displaying the most recent data. It also highlights the Meta Monitoring dashboard as a resource for users to check the current time it takes for new data to be added to Dune. \n\nExample: If a user is viewing a dashboard and notices that the data is not up to date, they can refer to this guide to understand how results get refreshed in the app. They can also check the Meta Monitoring dashboard to see if there are any delays in adding new data to Dune.\n## Questions: \n 1. What is the definition of \"stale\" data in this app and how is it determined?\n   \n   The definition of \"stale\" data in this app is data that is more than 3 hours old. This is determined by the Dune backend when inspecting the age of the most recent result.\n\n2. Is there a way for users to manually refresh the data or set a custom refresh schedule?\n   \n   It is not mentioned in the app technical guide whether users can manually refresh the data or set a custom refresh schedule. However, it is stated that dashboards will always be kept up to date when they are being viewed and the query creator does not need to set a refresh schedule.\n\n3. How does the query execution queue work and is there a limit to the number of queries that can be queued at once?\n   \n   The app technical guide mentions that the query execution queue is separate from each individual user's queue when they create and run queries in the query editor. However, it does not provide information on how the query execution queue works or if there is a limit to the number of queries that can be queued at once.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\faq\\how-are-results-refreshing.md"}}],["138",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\faq\\how-does-dune-get-its-data.md)\n\n# Overview\n\nThis app technical guide provides an explanation of how Dune, a project focused on blockchain data analysis, obtains its data. The guide explains that Dune works with node providers across the industry to ingest raw historical data from various blockchains. The guide also clarifies that state data is not included in the data obtained by Dune. \n\n# How Dune Gets Its Data\n\nThe guide explains that Dune collaborates with node providers to obtain data from various blockchains. This data is then ingested into Dune's database. The guide emphasizes that Dune does not discriminate against any smart contract and that users can submit any contract via the decoding page. The only prerequisite for this is an ABI so that Dune can decode the contract. \n\n# Example\n\nFor instance, if a user wants to work with a smart contract on Dune, they can submit the contract via the decoding page. Dune will then decode the contract using the ABI and ingest the data into its database. This allows users to work with the contract in a matter of hours. \n\nOverall, this guide provides a clear explanation of how Dune obtains its data and highlights the importance of ABIs in the process. It is a useful resource for anyone looking to understand the data acquisition process in Dune.\n## Questions: \n 1. What blockchains does Dune Docs currently support for data ingestion?\n- The app technical guide does not provide specific information on which blockchains Dune Docs supports for data ingestion.\n\n2. Does Dune Docs provide access to state data?\n- The app technical guide states that Dune Docs does not include state data in its data ingestion process.\n\n3. How does Dune Docs decode smart contracts submitted through its decoding page?\n- The app technical guide mentions that the only prerequisite for submitting a smart contract through the decoding page is an ABI, which is used to decode the contract.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\faq\\how-does-dune-get-its-data.md"}}],["139",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\reference\\faq)\n\nThe FAQ folder in the Dune Docs project contains several guides that answer common questions and provide important information about the app, its features, and how it works. These guides are designed to help users understand various aspects of the Dune app and how to use it effectively.\n\n1. **Does Dune Have a Token?**: This guide clarifies that Dune does not have a token-based authentication system. This information is useful for users who are looking to integrate Dune with other apps that require token-based authentication. By referring to this guide, users can save time and effort in trying to implement a feature that is not available in the app.\n\n2. **Does Dune have an API?**: This guide informs users that Dune has an API and provides instructions on how to obtain access to it. Users interested in using Dune's API can refer to this guide to learn about the API and how to gain access. They can then follow the provided link to learn more about using the API and refer to additional documentation as needed. For users without API access, they can still export results as CSV or embed Dune charts on their page for free.\n\n3. **How often do results get refreshed?**: This guide explains how Dune keeps results up to date and ensures that dashboards are always displaying the most recent data. Users can refer to this guide to understand how results get refreshed in the app and check the Meta Monitoring dashboard to see if there are any delays in adding new data to Dune. This information is helpful for users who want to ensure that their dashboards are always displaying the most accurate and up-to-date information.\n\n4. **How does Dune get its data?**: This guide provides an explanation of how Dune obtains its data from various blockchains by collaborating with node providers. Users can refer to this guide to understand the data acquisition process in Dune and learn about the importance of ABIs in the process. For example, if a user wants to work with a smart contract on Dune, they can submit the contract via the decoding page, and Dune will decode the contract using the ABI and ingest the data into its database.\n\nOverall, the guides in the FAQ folder provide valuable information for users who are curious about various aspects of the Dune app. These guides can help users better understand the app's features and how to use them effectively, ultimately enhancing their experience with the Dune project.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\faq\\summary.md"}}],["140",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\index.md)\n\nThe app technical guide titled \"Reference\" is a section of the Dune Docs project that provides answers to frequently asked questions about the app. The guide covers topics such as the data available in Dune Tables, tools for building dashboards, and where to find Dune events and support. The purpose of this guide is to provide users with a quick and easy way to find answers to their questions.\n\nThe guide is organized into sections that correspond to the different types of questions users may have. For example, the section on Dune Tables provides information on the data available in the app's data tables. The section on building dashboards provides information on the tools that are helpful for this task. The section on events and support provides information on where to find help when needed.\n\nIn addition to answering questions, the guide also includes supplemental resources such as Wizard Tools. These resources are designed to help users in their work as a Wizard.\n\nOverall, the Reference section of the Dune Docs project is a valuable resource for users who need quick answers to their questions. The guide is well-organized and easy to navigate, making it a useful tool for both new and experienced users of the app.\n## Questions: \n 1. What is the purpose of the Dune Tables and how are they related to blockchain data? \n   - The app technical guide mentions Dune Tables, but it is unclear what data is stored in them and how they relate to blockchain data. \n2. Are there any specific SQL queries or commands that can be used to access the data in Dune Tables? \n   - The guide mentions tools for building dashboards, but it is unclear if there are any specific SQL queries or commands that can be used to access the data in Dune Tables. \n3. What kind of support is available for Dune events and how can it be accessed? \n   - The guide mentions support for Dune events, but it is unclear what kind of support is available and how it can be accessed.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\index.md"}}],["141",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\press-kit.md)\n\nThis app technical guide covers the Press Kit feature of the Dune app. The Press Kit is a collection of Dune's brand assets that can be used by external parties for promotional purposes. The guide provides information on the different types of logos available in the Press Kit and how they should be used.\n\nThe guide starts with an introduction to the Press Kit and its purpose. It then proceeds to describe the different types of logos available in the kit. The first logo described is the Primary - Standard Logo, which is the primary Dune logo and should be used whenever possible. The guide provides an example of the logo and lists the different file formats available for download.\n\nThe next logo described is the Vertical Logo, which is a variation of the primary logo in a vertical format. The guide provides an example of the logo and lists the different file formats available for download.\n\nThe third logo described is the Icon Only logo, which is a simplified version of the Dune logo without the text. The guide provides an example of the logo and lists the different file formats available for download.\n\nFinally, the guide provides a link to download the complete set of all logos available in the Press Kit.\n\nOverall, this guide provides a comprehensive overview of the different logos available in the Dune Press Kit and how they should be used. It is a useful resource for external parties who want to use Dune's brand assets for promotional purposes.\n## Questions: \n 1. What is the purpose of the Dune Docs app? \n- The app technical guide does not provide information on the purpose of the Dune Docs app. \n\n2. Are there any specific guidelines or restrictions on the usage of the Dune logos? \n- The app technical guide provides guidelines on the usage of the Dune logos, but it does not mention any restrictions. \n\n3. Is there any information on the file formats of the logo images provided? \n- The app technical guide provides information on the file formats of the logo images, including SVG and PNG.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\press-kit.md"}}],["142",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\pricing.md)\n\nThe Pricing section of the Dune app technical guide provides information on the premium plans offered by Dune and the additional features that come with them. The guide lists the features of the premium plan, including private queries and dashboards, CSV exports, faster executions, no Dune watermarks, and processing for up to six queries at once. The guide also provides a link to the pricing page where users can learn more about the plans and get started. \n\nThe FAQ section of the guide provides answers to general questions about billing history, upgrading, downgrading, or canceling subscriptions, and how billing works when upgrading or downgrading. The guide also explains which query engine will be billed and what to do if users have more questions. \n\nThe Query Execution section of the guide provides information on the performance tiers and the query engine they support. The guide explains the performance difference between tiers and when the rate for additional executions kicks in. The guide also explains how users can limit premium query usage when they have reached their limit to avoid paying extra fees. \n\nThe Features section of the guide provides information on what happens when users add a private query to a public dashboard and whether they can embed private queries on other websites. The guide also explains what happens to watermarks for Elite users. \n\nOverall, the guide provides a comprehensive overview of the premium plans offered by Dune, how billing works, and the additional features that come with the premium plans. The guide also provides answers to frequently asked questions about billing, query execution, and features.\n## Questions: \n 1. What additional features are available with Dune Premium accounts?\n- Dune Premium accounts offer private queries and dashboards, CSV exports, faster executions, no Dune watermarks, and processing for up to 6 queries at once.\n\n2. What is the difference in performance between the pricing tiers?\n- Each tier has 2-4x the amount of computational power of the previous tier, and the higher the tier, the faster queries will run.\n\n3. How does billing work when upgrading or downgrading a subscription?\n- Upgrading immediately resets the billing cycle to the day of the upgrade, while downgrades are applied at the end of the billing cycle. Unused days of the current plan will be refunded pro rata when upgrading.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\pricing.md"}}],["143",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\recommended-reading.md)\n\nThe \"Recommended Reading\" technical guide is a resource for users of the Dune Docs project who are interested in web3 data analytics. The guide provides a list of recommended reading resources that can help users in their journey. The guide is divided into several sections, each focusing on a specific topic related to web3 data analytics.\n\nThe first section of the guide is \"Wizard Content,\" which features content created by members of the Wizard community. The section provides links to their work, including \"Journey to the Centre of Arakis\" by @1chioku, \"Andrew Hong's Mirror.xyz\" by @ilemi, and \"NiftyTable\" by @niftytable.\n\nThe next section is \"General Blockchain Info,\" which provides a link to \"Immersion Den,\" a collection of web3 information sources. The following section is \"DeFi,\" which provides a link to \"Biggest DeFi Hacks.\"\n\nThe guide also includes sections on DAOs, Bridges/L2, EIPs, News and Info, Newsletters, and Cool Blockchain Data Websites. Each section provides links to relevant resources that can help users in their web3 data analytics journey.\n\nFor example, the \"DAOs\" section provides links to \"DAOs: Absorbing the Internet\" and \"DAO Central - Learn about DAOs.\" The \"Bridges/L2\" section provides a link to \"The ultimate guide to L2s on Ethereum.\" The \"EIPs\" section provides a link to the Ethereum Improvement Proposals website.\n\nOverall, the \"Recommended Reading\" technical guide is a valuable resource for users of the Dune Docs project who are interested in web3 data analytics. The guide provides a comprehensive list of recommended reading resources that can help users stay up-to-date with the latest developments in the field.\n## Questions: \n 1. What is the purpose of the Dune Docs app and how does it relate to blockchain SQL analysis?\n- The app technical guide does not provide information on the purpose of the Dune Docs app or its relation to blockchain SQL analysis.\n\n2. Are there any resources specifically related to blockchain SQL analysis included in the recommended reading?\n- The recommended reading includes resources related to web3 data analytics in general, but does not specifically mention blockchain SQL analysis.\n\n3. Can users suggest additional resources to be included in the recommended reading list?\n- Yes, users can suggest additional resources to be included in the recommended reading list by proposing changes on the GitHub page provided in the app technical guide.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\recommended-reading.md"}}],["144",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\reference)\n\nThe \"Citing Dune\" app technical guide, located in the `.autodoc\\docs\\json\\docs\\reference` folder, provides instructions on how to correctly reference and cite Dune queries and dashboards. This guide is focused on the app feature of referencing and sharing data on the Dune platform. It is essential for users who want to ensure they are properly crediting the creators of the queries, visualizations, and dashboards they use or mention in their work.\n\nFor example, if a user wants to include a Dune visualization in their blog post, they can refer to this guide to learn how to find the creator's username and the dashboard or query name on the Dune platform. The guide provides screenshots to illustrate how to locate this information. Additionally, the guide directs users to another page for more information on how to get embed links for visualizations they want to share.\n\nThe guide also highlights the limitations of commercial use of the queries and public dashboard on the Dune platform. It warns against copying, transmitting, modifying, or creating derivative works from the original queries and dashboard. It also prohibits any form of exploiting any portion, use, or access to Dune without the express written permission by Dune.\n\nOverall, the \"Citing Dune\" app technical guide provides clear instructions on how to properly reference and cite data and visualizations found on the Dune platform. It also emphasizes the importance of respecting the limitations of commercial use of the queries and dashboard on the platform. This guide is a valuable resource for users who want to ensure they are properly crediting the creators of the queries, visualizations, and dashboards they use or mention in their work.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\summary.md"}}],["145",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\support-feedback.md)\n\nThe app technical guide titled \"Support & Feedback\" provides users with information on how to get support and leave feedback for the Dune app. The guide is divided into two main sections: \"How to Get Support\" and \"How to Leave Feedback.\" \n\nUnder \"How to Get Support,\" users are provided with two options for getting help. The first option is to use the search bar located above the guide to search for answers. The second option is to join the Dune Discord server and ask for help in one of the relevant support channels. The guide lists seven different channels, each with a specific focus, such as query questions, data tables, and API-related questions. \n\nUnder \"How to Leave Feedback,\" users are provided with three different channels for leaving feedback. The first channel is the Canny board, where users can leave general feedback about the Dune app. The second channel is the \"bugs\" channel in the Dune Discord server, where users can report any bugs they encounter. The third channel is the \"feature-requests\" channel, where users can suggest new features for the app. \n\nThe guide also provides information on how to report issues related to user accounts, billing, or other administrative problems. Users are instructed to send an email to the support team at support@dune.com. \n\nOverall, this guide is a helpful resource for users who need assistance with the Dune app or want to provide feedback. The guide provides clear instructions on how to get help and leave feedback, and it directs users to the appropriate channels for their specific needs. The guide also includes helpful visuals, such as a screenshot of the pencil icon users can click to submit feedback fixes or additions.\n## Questions: \n 1. What is the purpose of the Dune app and what kind of data does it handle?\n- The app technical guide does not provide information on the purpose or data handled by the Dune app.\n\n2. Are there any APIs available for accessing data in the Dune app?\n- Yes, there is a support channel (#dune-api) specifically for API related questions.\n\n3. How can users contribute to the improvement of the Dune app documentation?\n- Users can click the pencil icon to the right of the page title and open a GitHub issue or submit a pull request to provide feedback fixes or additions to the documentation.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\support-feedback.md"}}],["146",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\v1-sunsetting.md)\n\nThe technical guide titled \"Sunsetting Dune V1\" provides information on the decommissioning of the V1 platform of the Dune Engine. The guide explains that with the release of the Polygon decoded tables on Dune Engine V2, all raw and decoded data that was on V1 is now available on V2. As a result, the V1 platform is being decommissioned, and the guide provides details on the decommissioning process.\n\nThe guide explains that once a chain is commissioned, queries referencing the V1 version won't be editable anymore until the user logs in and selects DuneV2 from the data explorer drop-down to re-run them as V2 queries. The guide also notes that no new contracts submitted for decoding on all blockchains will be decoded on V1, and no new Abstraction PRs will be merged on V1.\n\nThe guide provides a decommissioning schedule for Dune V1 databases, which includes the kickoff date for each blockchain, the date when the blockchain will be removed from the blockchain selection dropdown, the date when V1 queries for the given blockchain will become read-only, and the date when no new data will be ingested, and no new query executions on V1 databases will be allowed.\n\nThe guide also provides links to resources where users can learn more about how V2 works, how searching in V2 works, and general insights on Dune V2. Users can check out the DuneSQL to learn more about how V2 works, the Data Explorer guide to learn more about how searching in V2 works, and watch Dune Arcana videos for general insights. Additionally, users can join live Office Hours or ask in the #query-questions Discord channel to ask questions.\n\nOverall, the guide provides a comprehensive overview of the decommissioning process of the V1 platform of the Dune Engine and provides users with the necessary information to transition to the V2 platform.\n## Questions: \n 1. What is the reason for sunsetting Dune V1 and transitioning to V2 as the primary platform?\n- The reason for sunsetting Dune V1 and transitioning to V2 as the primary platform is due to the release of the Polygon decoded tables on Dune Engine V2, which now has all Raw and Decoded data that was on V1 on V2.\n\n2. What are the implications for existing and new contracts submitted for decoding on all blockchains?\n- No new contracts that are submitted for decoding (on all blockchains) will be decoded on V1, they will only be decoded on V2 (already decoded contracts will continue to work as normal).\n\n3. What is the timeline for decommissioning each blockchain on Dune V1?\n- The timeline for decommissioning each blockchain on Dune V1 is provided in the Decommissioning Schedule for Dune V1 Databases table, which includes the kickoff date for decommissioning, removal of the blockchain from the blockchain selection dropdown, read-only access to V1 queries, and the end of decommissioning.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\v1-sunsetting.md"}}],["147",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\wizard-tools\\blockchain-explorers.md)\n\n# Blockchain Explorers\n\nThis technical guide provides an overview of Blockchain Explorers, which are essential tools for Data Analysts/Scientists. The guide explains that Blockchain Explorers allow users to explore a blockchain by providing an online interface to retrieve data about transactions, addresses, blocks, and fees, among others. \n\nThe guide lists the primary web-based explorers for the most popular blockchains, including Ethereum, Solana, Arbitrum, Polygon, Optimism, Avalanche C-Chain, Binance Smart Chain, and Gnosis Chain. Each blockchain is accompanied by a link to its respective explorer. \n\nThe guide emphasizes that while Blockchain Explorers may not offer the same level of functionality as Dune, they are indispensable for understanding how certain protocols work and what data is required for queries. \n\nFor example, the Ethereum blockchain is explored using Etherscan, which provides a comprehensive view of the Ethereum network, including real-time data on transactions, blocks, and addresses. Similarly, Solscan is used to explore the Solana blockchain, while Arbiscan is used for the Arbitrum blockchain. \n\nOverall, this technical guide provides a useful introduction to Blockchain Explorers and their importance in the world of data analysis and science.\n## Questions: \n 1. What is the purpose of this app and how does it relate to blockchain data analysis?\n- The app is a collection of web-based blockchain explorers for popular blockchains, which allow data analysts/scientists to retrieve information about transactions, addresses, blocks, and fees. \n\n2. Are there any other blockchains that this app supports besides the ones listed?\n- The app only lists the primary web-based explorers for the most popular blockchains, so it's possible that there are other blockchains not included in this list. \n\n3. Does this app provide any tools or features beyond just retrieving blockchain data?\n- The app does not provide any tools or features beyond retrieving blockchain data, but it is noted that the explorers listed are not as comprehensive as the Dune platform.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\wizard-tools\\blockchain-explorers.md"}}],["148",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\wizard-tools\\helpful-dashboards.md)\n\n# Helpful Dashboards\n\nThis technical guide is focused on the app folder of the Dune Docs project. The guide provides a list of helpful dashboards for those looking to learn new Dune, Data Analytics, and Blockchain Analysis skills. The dashboards are divided into two categories: Tutorial Dashboards and Reference Dashboards.\n\nThe Tutorial Dashboards are great for learning new skills. The dashboards include Tips and Tricks for Dune V2 Queries and Visualizations, Data Visualization Cheat Sheet, Event and Function Signature Sleuthing, Getting Started, and Contract Quickstart. Each dashboard is created by a different user and provides a unique perspective on learning Dune.\n\nThe Reference Dashboards are helpful to refer to while building Queries. The dashboards include Meta Monitoring, Is my Contract Decoded Yet?, and Dune DB Guide. These dashboards are created by different users and provide a reference point for building queries.\n\nThe technical guide also provides a link to submit a GitHub Pull Request for any other dashboard that is helpful. If the dashboard is deemed helpful, it will be added to the list.\n\nFor example, if a user is looking to learn Dune V2 Queries and Visualizations, they can refer to the Tips and Tricks for Dune V2 Queries and Visualizations dashboard created by @springzhang. This dashboard provides tips and tricks for creating queries and visualizations in Dune V2.\n\nOverall, this technical guide provides a list of helpful dashboards for those looking to learn Dune, Data Analytics, and Blockchain Analysis skills. The dashboards are created by different users and provide a unique perspective on learning Dune.\n## Questions: \n 1. What is the purpose of the Dune Docs app?\n   \n   The app is not clearly defined in this technical guide, so a blockchain SQL analyst might have to look for additional documentation or context to understand the app's purpose.\n\n2. What kind of data analytics and blockchain analysis skills can be learned from the tutorial dashboards?\n   \n   The technical guide mentions that the tutorial dashboards are great for learning new Dune, Data Analytics, and Blockchain Analysis skills, but it does not provide specific examples or details about what those skills might be.\n\n3. How can a user submit a new dashboard to be added to the list?\n   \n   The technical guide mentions that users can submit a GitHub Pull Request to add a new dashboard to the list, but a blockchain SQL analyst might want more information on the submission process, such as what kind of criteria the Dune Analytics team uses to determine if a dashboard is helpful enough to be added to the list.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\wizard-tools\\helpful-dashboards.md"}}],["149",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\wizard-tools\\index.md)\n\n# Wizard Tools\n\nThis section of the app technical guide provides a list of non-Dune tools that the wizards use to make their work easier. The tools listed here are useful for learning how each ERC-xxx standard works, understanding the current crypto data ecosystem, auditing smart contracts, and digging into smart contracts to understand how they operate and their data structure. \n\nSome of the tools listed in this section include OpenZepplin's ERC-xxx Standards Docs, which are helpful for learning how each ERC-xxx standard works. The EVM Handbook is a curated list of EVM resources for aspiring blockchain data analysts. Solidity Visual Developer for VS Code is a helpful suite of tools for smart contract auditing inside of VS code. Deth.net is a set of Ethereum developer tools that help with blockchain data sleuthing. ZK Zhao's map of the Crypto Data Landscape is helpful for getting a sense of the current crypto data ecosystem. \n\nThe section also includes links to recommended reading lists for a bunch of guides on crypto data topics and projects to check out. DeepDAO provides stats on DAOs and their treasuries. DethCode lets you go into an Ethereum smart contract's code to read the comments or the actual logic can help to understand the smart contract's emitted data. Sidekik is useful for digging into smart contracts to understand how they operate and their data structure. Ethernaut is a wargame where you \"hack\" a set of smart contracts, useful for learning how smart contracts work. Advanced Ethereum Mini Courses are a good resource for understanding how theory applies to practice. \n\nOverall, this section of the app technical guide provides a comprehensive list of tools that can be used to make the work of the wizards easier. The tools listed here are useful for anyone who wants to learn more about blockchain data analysis, smart contract auditing, and the current crypto data ecosystem.\n## Questions: \n 1. What is the purpose of this app and how does it relate to blockchain technology?\n- The app technical guide provides a list of non-Dune tools that can be used by blockchain data analysts to understand and work with smart contracts and Ethereum transactions.\n\n2. Are there any specific tools listed that are particularly useful for analyzing blockchain data using SQL?\n- It is not explicitly stated in the app technical guide which tools are specifically useful for analyzing blockchain data using SQL.\n\n3. Are there any limitations or potential issues with using these tools for blockchain data analysis?\n- The app technical guide does not provide any information on limitations or potential issues with using these tools for blockchain data analysis.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\wizard-tools\\index.md"}}],["150",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs\\reference\\wizard-tools)\n\nThe `.autodoc\\docs\\json\\docs\\reference\\wizard-tools` folder contains a collection of technical guides that focus on providing resources, tools, and examples to help users better understand and utilize the Dune Docs project. These guides cover various aspects of the project, such as Blockchain Explorers, Helpful Dashboards, Wizard Tools, and Utility Queries.\n\nThe `blockchain-explorers.md` guide offers an overview of Blockchain Explorers, which are essential tools for Data Analysts/Scientists. It lists the primary web-based explorers for popular blockchains and emphasizes their importance in understanding how certain protocols work and what data is required for queries. For instance, Etherscan is used to explore the Ethereum blockchain, providing real-time data on transactions, blocks, and addresses.\n\nThe `helpful-dashboards.md` guide focuses on providing a list of helpful dashboards for users looking to learn new Dune, Data Analytics, and Blockchain Analysis skills. These dashboards are divided into Tutorial Dashboards and Reference Dashboards, each created by different users and offering unique perspectives on learning Dune. For example, the Tips and Tricks for Dune V2 Queries and Visualizations dashboard by @springzhang provides valuable insights for creating queries and visualizations in Dune V2.\n\nThe `index.md` guide lists non-Dune tools that wizards use to make their work easier. These tools are useful for learning how each ERC-xxx standard works, understanding the current crypto data ecosystem, auditing smart contracts, and digging into smart contracts to understand their operation and data structure. Some of the tools mentioned include OpenZepplin's ERC-xxx Standards Docs, EVM Handbook, Solidity Visual Developer for VS Code, Deth.net, and ZK Zhao's map of the Crypto Data Landscape.\n\nThe `utility-queries.md` guide provides a list of queries that can help users build their own queries. These queries are focused on decoding contracts, starting points for queries, and NFTs. For example, the \"Is my Contract decoded yet\" queries by @0xBoxer and @chenxiangli are focused on decoding contracts on different networks, which can be useful for developers who want to analyze the contract's data.\n\nOverall, the guides in this folder offer valuable resources and tools for users to better understand and utilize the Dune Docs project. They provide a comprehensive collection of information that can be helpful for analysts who are curious about using the project and want to learn more about its various aspects.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\wizard-tools\\summary.md"}}],["151",{"pageContent":"[View code on GitHub](https://dune.com/blob/master/reference\\wizard-tools\\utility-queries.md)\n\n# Utility Queries\n\nThis section of the Dune Docs project provides a list of queries that can help users build their own queries. The queries are organized in a table that includes the name/link and tag of each query. Users can propose changes to the list by following the link provided.\n\nThe queries listed in this section are focused on decoding contracts, starting points for queries, and NFTs. For example, the \"Is my Contract decoded yet\" queries by @0xBoxer and @chenxiangli are focused on decoding contracts on different networks (Ethereum, Polygon, xDAI, and BSC). These queries can be used to check if a contract has been decoded yet, which can be useful for developers who want to analyze the contract's data.\n\nThe queries by @ilemi are focused on providing starting points for queries related to common event signatures, functions called by signers, and functions called in traces for a contract. These queries can be used as a foundation for more complex queries that require this information.\n\nFinally, the query by @ilemi for getting all NFTs held by an address (ERC721 + ERC1155) is focused on NFTs. This query can be used to retrieve information about the NFTs held by a specific address, which can be useful for analyzing NFT markets.\n\nOverall, this section of the Dune Docs project provides a useful list of queries that can help users build their own queries. The queries are focused on decoding contracts, starting points for queries, and NFTs, and can be used as a foundation for more complex queries.\n## Questions: \n 1. What is the purpose of the Dune Docs app and how does it relate to blockchain SQL analysis?\n- The Dune Docs app provides a list of utility queries that can be used as starting points for building queries related to blockchain data analysis using SQL.\n2. How can a user propose changes or additions to the list of utility queries?\n- A user can propose changes or additions to the list of utility queries by clicking on the provided link to the app's GitHub repository and submitting a pull request.\n3. What types of blockchain data analysis can be performed using the utility queries provided in the app?\n- The utility queries provided in the app can be used for decoding contracts, finding common event signatures and functions called, retrieving NFTs held by an address, and getting addresses from ENS.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\reference\\wizard-tools\\utility-queries.md"}}],["152",{"pageContent":"[View code on GitHub](https://dune.com/tree/master/doc\\docs\\json\\docs)\n\nThe `functions-and-operators.md` file in the `querying-with-DuneSQL` subfolder is a comprehensive guide on the built-in SQL functions and operators supported by DuneSQL, which is a part of the larger project feature \"query.\" This guide is essential for developers working with DuneSQL to understand the available SQL functions and operators and how to use them effectively in their code. It provides a categorized list of functions and operators, such as Aggregate, Array, Binary, Bitwise, Color, Comparison, Conditional, Conversion, Date and time, Decimal, Geospatial, HyperLogLog, IP Address, JSON, Lambda, Logical, Machine learning, Map, Math, Quantile digest, Regular expression, Session, Set Digest, String, System, Table, Teradata, T-Digest, URL, UUID, and Window.\n\nFor example, if a developer is working on a feature that requires manipulating arrays, they can refer to the Array header in the guide, which provides a link to the Trino documentation on array functions. This will help them understand how to use the available functions to manipulate arrays effectively.\n\nSimilarly, if a developer needs to perform calculations on a set of values and return a single value, they can refer to the Aggregate header in the guide. This header provides a link to the Trino documentation on aggregate functions, which will help them understand how to use these functions in their code.\n\nThe guide also provides information on how to use the SHOW FUNCTIONS command to return a list of all available functions, including custom functions, with all supported arguments and a short description. This can be useful for developers who want to explore the available functions and their usage in their code.\n\nIn addition to the categorized list of functions and operators, the guide recommends reviewing the SQL data types and the SQL statement and syntax reference. This will help developers gain a better understanding of the data types they are working with and how to write efficient SQL queries using DuneSQL.\n\nOverall, this guide serves as a valuable reference for developers working with DuneSQL in the larger project feature \"query.\" It helps them understand the available SQL functions and operators, their usage, and how to implement complex functionality and behavior of the SQL executed by Trino operating on the underlying data sources.","metadata":{"source":".autodoc\\docs\\markdown\\docs\\summary.md"}}]]